//
// Worker thread routines for the fireworks test.
//

#INCLUDE "Fwt.hjk"

#DEFINE FWT_GRAVITY_AMT 10
#DEFINE FWT_INTERVAL_MS 16

FN (KeStartThreadF) FwtParticleThread (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

    // Main loop for a fireworks particle thread.

    interval : RtlUquad

#IF ( STRCMP PLATFORM "fox32" )
    // Because the timer interrupt on fox32 is just the vblank interrupt, a
    // delay of 1ms will always sync with vblank, making fireworks smooth.

    RtlSetUquadToUlong (
        &interval, // uquad
        1, // ulong
    )
#ELSE
    RtlSetUquadToUlong (
        &interval, // uquad
        FWT_INTERVAL_MS, // ulong
    )
#END

    thisfwd : ^FwtData
    thisfwd = CAST context1 TO ^FwtData
    
    angle := FwtRand () % (1 << FWT_FIXED_POINT)
    
    // Back the data up from thisfwd.

    x := thisfwd^.X
    y := thisfwd^.Y
    ExplosionRange := thisfwd^.ExplosionRange
    
    // And free it.

    MmFreeToPoolCache (
        FwtDataCache, // cache
        thisfwd, // ptr
    )
    
    actx := FWT_INT_TO_FP ( x )
    acty := FWT_INT_TO_FP ( y )

    velx := FWT_MUL_FP_FP_SM (
        FwtCos ( angle ), // fp1
        FwtRandFpSign (), // fp2
    ) * ExplosionRange

    vely := FWT_MUL_FP_FP_SM (
        FwtSin ( angle ), // fp1
        FwtRandFpSign (), // fp2
    ) * ExplosionRange
    
    expirein := 2000 + FwtRand () % 1000
    color := FwtRandomColor ()

    i := 0
    t := 0

    WHILE i < expirein DO
        FwtSetPixel (
            color, // color
            x, // x
            y, // y
        )

        KeSleep (
            &interval, // interval
            KE_KERNEL_MODE, // waitmode
            FALSE, // alertable
        )

        i += FWT_INTERVAL_MS
        
        FwtSetPixel (
            FWT_BACKGROUND_COLOR, // color
            x, // x
            y, // y
        )
        
        // Update the particle

        actx += velx * FWT_INTERVAL_MS / 1000
        acty += vely * FWT_INTERVAL_MS / 1000
        
        x = FWT_FP_TO_INT ( actx )
        y = FWT_FP_TO_INT ( acty )
        
        // Gravity

        vely += FWT_INT_TO_FP ( FWT_GRAVITY_AMT ) * FWT_INTERVAL_MS / 1000
    END
    
    PsuExitThread ()
END

FN (KeStartThreadF) FwtExplodeableThread (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

    // Main loop for an explodeable particle thread.

    interval : RtlUquad
    
#IF ( STRCMP PLATFORM "fox32" )
    // Because the timer interrupt on fox32 is just the vblank interrupt, a
    // delay of 1ms will always sync with vblank, making fireworks smooth.

    RtlSetUquadToUlong (
        &interval, // uquad
        1, // ulong
    )
#ELSE
    RtlSetUquadToUlong (
        &interval, // uquad
        FWT_INTERVAL_MS, // ulong
    )
#END

    fwd : FwtData
    
    offsetx := CAST ( FwtViewWidth * 400 / 1024 ) TO WORD
    
    x : WORD
    y : WORD

    actx := FWT_INT_TO_FP ( CAST FwtViewWidth / 2 TO WORD )
    acty := FWT_INT_TO_FP ( CAST FwtViewHeight - 1 TO WORD )

    velx : WORD = offsetx * FwtRandFpSign()
    vely : WORD = -FWT_INT_TO_FP ( CAST 100 + FwtRand () % 100 TO WORD )

    color := FwtRandomColor ()

    explosionrange := FwtRand () % 100 + 100
    
    expirein := 500 + FwtRand () % 500

    i := 0

    WHILE i < expirein DO
        FwtSetPixel (
            color, // color
            x, // x
            y, // y
        )

        KeSleep (
            &interval, // interval
            KE_KERNEL_MODE, // waitmode
            FALSE, // alertable
        )

        i += FWT_INTERVAL_MS

        FwtSetPixel (
            FWT_BACKGROUND_COLOR, // color
            x, // x
            y, // y
        )

        // Update the particle

        actx += velx * FWT_INTERVAL_MS / 1000
        acty += vely * FWT_INTERVAL_MS / 1000
        
        x = FWT_FP_TO_INT ( actx )
        y = FWT_FP_TO_INT ( acty )
        
        // Gravity

        vely += FWT_INT_TO_FP ( FWT_GRAVITY_AMT ) * FWT_INTERVAL_MS / 1000
    END
    
    // Explode it.
    // This spawns many, many threads, for fun.
    
    count := FwtRand () % 100 + 100
    i = 0
    
    WHILE i < count DO
        i += 1
        
        data : ^FwtData = MmAllocateFromPoolCache (
            FwtDataCache, // cache
            FALSE, // wait
        )
        
        IF NOT data THEN
            RtlPrint ( "FwtExplodeableThread: Out of memory\n" )

            BREAK
        END
        
        // Copy data into the FwtData instance.

        data^.X = x
        data^.Y = y
        data^.ExplosionRange = explosionrange
        
        IF NOT FwtCreateThread (
            &FwtParticleThread, // startroutine
            data, // fwd
        ) THEN

            RtlPrint ( "FwtExplodeableThread: Out of system resources\n" )

            MmFreeToPoolCache (
                FwtDataCache, // cache
                data, // ptr
            )
        END
    END
    
    PsuExitThread ()
END

FN FwtSpawnExplodeable ()
    IF NOT FwtCreateThread (
        &FwtExplodeableThread, // startroutine
        NULLPTR, // fwd
    ) THEN
        RtlPrint ( "FwtSpawnExplodeable: Out of fireworks\n" )
    END
END
