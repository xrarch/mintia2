//
// Architecture-specific part of the Ke.hjk header file.
//

#IF BLD_MP

#MACRO KeMemoryBarrier () [
    BARRIER
    INSERTASM "mb"
    BARRIER
]

#MACRO KeWriteMemoryBarrier () [
    BARRIER
    INSERTASM "wmb"
    BARRIER
]

#MACRO KeCurrentProcessorId () [
    ((CAST 0xFFFFCFF8 TO ^ULONG)^)
]

#MACRO KeCurrentVolatileNodeId () [
    ((CAST 0xFFFFCFF4 TO ^ULONG)^)
]

#ELSE

#MACRO KeMemoryBarrier () [ BARRIER ]
#MACRO KeWriteMemoryBarrier () [ BARRIER ]

#MACRO KeCurrentProcessorId () [ 0 ]

#MACRO KeCurrentVolatileNode () [(CAST KE_NODE_SPACE_START TO ^KeuNode)]

#END

#MACRO KeSpinPause () [
    BARRIER
    INSERTASM "pause"
    BARRIER
]

// The current thread pointer is stashed in the final 4 bytes of the Prb for
// rapid access. This works on XR/17032 MP systems because the Prb is a
// per-processor mapping maintained by a wired TB entry.

#MACRO KeCurrentThread () [
    ((CAST 0xFFFFCFFC TO ^^KeuThread)^)
]

#MACRO KepSetCurrentThreadForProcessor ( thread ) [
    NOTHING (CAST 0xFFFFCFFC TO ^^KeuThread)[0] = (thread)
]

#MACRO KepStashPrbId ( prb, id ) [
    NOTHING (CAST ((prb) + 0xFF8) TO ^ULONG)[0] = (id)
]

#MACRO KepStashNodePtr ( prb, node ) [
    NOTHING (CAST ((prb) + 0xFF4) TO ^^KeuNode)[0] = (node)
]

#DEFINE KE_CACHE_ALIGN 16

// Describes the start of the per-node spaces.
// Must be aligned to the size of a node space which must be a power of two.
// This information may seem misplaced but it belongs in Ke because it is used
// by all components and there's no reason to rule out its (very conservative)
// use by kernel modules either.

#DEFINE KE_NODE_SPACE_START 0xC0000000
#DEFINE KE_NODE_STRUCTURE_OFFSET 0x00000000
#DEFINE KE_NODE_PRB_OFFSET 0x00004000

#MACRO KeIsPointerInNodeSpace ( ptr ) [
    ((ptr) >= KE_NODE_SPACE_START)
]

#IF BLD_NUMA

#DEFINE KE_NODE_SPACE_SIZE 0x20000000

#DEFINE KE_BL_BUMP_SPACE_OFFSET 0x00020000

#DEFINE KE_POOL_SPACE_OFFSET 0x08000000
#DEFINE KE_POOL_SPACE_SIZE [(128 * 1024 * 1024)]

#DEFINE KE_DYNAMIC_SPACE_OFFSET 0x10000000
#DEFINE KE_DYNAMIC_SPACE_SIZE [(128 * 1024 * 1024)]

#DEFINE KE_CACHE_SPACE_OFFSET 0x18000000
#DEFINE KE_CACHE_SPACE_SIZE [(128 * 1024 * 1024)]

#MACRO KeNumaNodeFromSpacePointer ( ptr ) [
    // We map NUMA node spaces on XR/frame from 0xC0000000 to the top of the
    // address space in 512MB increments. Two nodes exist, so bit 29 is the node
    // ID. Masking off the low 29 bits is sufficient to calculate the pointer to
    // a node structure given a pointer within the node space since it lies at
    // the base of its node space.

    (CAST (ptr & 0xE0000000) TO ^KeuNode)
]

#MACRO KeNumaNodeById ( id ) [
    (CAST KE_NODE_SPACE_START + ((id) * KE_NODE_SPACE_SIZE) TO ^KeuNode)
]

#MACRO KeNumaNodeFromArbitraryPointer ( destnode, srcptr ) [
    // On an architecture with real NUMA support, this macro should defer to
    // KeNumaNodeFromSpacePointer in the event the srcptr is in dynamic
    // space, and should default to the boot node otherwise.

    IF (srcptr) >= KE_NODE_SPACE_START THEN
        (destnode) = KeNumaNodeFromSpacePointer ( srcptr )
    ELSE
        // Boot node is node 0.
        (destnode) = KeNumaNodeById ( 0 )
    END
]

#MACRO KeCurrentVolatileNode () [
    ((CAST 0xFFFFCFF4 TO ^^KeuNode)^)
]

#ELSE

#DEFINE KE_NODE_SPACE_SIZE 0x40000000

#DEFINE KE_BL_BUMP_SPACE_OFFSET 0x00020000

#DEFINE KE_POOL_SPACE_OFFSET 0x10000000
#DEFINE KE_POOL_SPACE_SIZE [(256 * 1024 * 1024)]

#DEFINE KE_DYNAMIC_SPACE_OFFSET 0x20000000
#DEFINE KE_DYNAMIC_SPACE_SIZE [(256 * 1024 * 1024)]

#DEFINE KE_CACHE_SPACE_OFFSET 0x30000000
#DEFINE KE_CACHE_SPACE_SIZE [(256 * 1024 * 1024)]

#MACRO KeNumaNodeFromSpacePointer ( ptr ) [
    // On an architecture with real NUMA support, this macro may do something
    // like subtract the base of dynamic space from the pointer and convert
    // some pointer bits into a NUMA node ID.

    (CAST KE_NODE_SPACE_START TO ^KeuNode)
]

#MACRO KeNumaNodeById ( id ) [
    (CAST KE_NODE_SPACE_START TO ^KeuNode)
]

#MACRO KeNumaNodeFromArbitraryPointer ( destnode, srcptr ) [
    // On an architecture with real NUMA support, this macro should defer to
    // KeNumaNodeFromSpacePointer in the event the srcptr is in dynamic
    // space, and should default to the boot node otherwise.

    NOTHING (destnode) = (CAST KE_NODE_SPACE_START TO ^KeuNode)
]

#MACRO KeCurrentVolatileNode () [
    (CAST KE_NODE_SPACE_START TO ^KeuNode)
]

#END