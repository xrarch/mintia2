//
// Architecture-specific part of the Ke.hjk header file.
//

#IF BLD_MP

#MACRO KeMemoryBarrier () [
    BARRIER
    INSERTASM "mb"
    BARRIER
]

#MACRO KeWriteMemoryBarrier () [
    BARRIER
    INSERTASM "wmb"
    BARRIER
]

#MACRO KeCurrentNodeLocalProcessorId () [
    ((CAST 0xFFFFCFF8 TO ^ULONG)^)
]

#MACRO KeCurrentVolatileNodeId () [
    ((CAST 0xFFFFCFF4 TO ^ULONG)^)
]

#ELSE

#MACRO KeMemoryBarrier () [ BARRIER ]
#MACRO KeWriteMemoryBarrier () [ BARRIER ]

#MACRO KeCurrentNodeLocalProcessorId () [ 0 ]

#MACRO KeCurrentVolatileNodeId () [ 0 ]

#END

#MACRO KeSpinPause () [
    BARRIER
    INSERTASM "pause"
    BARRIER
]

// The current thread pointer is stashed in the final 4 bytes of the Prb for
// rapid access. This works on XR/17032 MP systems because the Prb is a
// per-processor mapping maintained by a wired TB entry.

#MACRO KeCurrentThread () [
    ((CAST 0xFFFFCFFC TO ^^KeuThread)^)
]

#MACRO KepSetCurrentThreadForProcessor ( thread ) [
    NOTHING (CAST 0xFFFFCFFC TO ^^KeuThread)[0] = (thread)
]

#MACRO KepStashPrbId ( prb, id ) [
    NOTHING (CAST ((prb) + 0xFF8) TO ^ULONG)[0] = (id)
]

#MACRO KepStashNodePtr ( prb, kenode ) [
    NOTHING (CAST ((prb) + 0xFF4) TO ^^KeuNode)[0] = (kenode)
]

#DEFINE KE_CACHE_ALIGN 16

// Describes the start of the per-node spaces.
// Must be aligned to the size of a node space which must be a power of two.
// This information may seem misplaced but it belongs in Ke because it is used
// by all components and there's no reason to rule out its (very conservative)
// use by kernel modules either.

#DEFINE KE_NODE_SPACE_START 0xC0000000
#DEFINE KE_NODE_STRUCTURE_OFFSET 0x00000000
#DEFINE KE_NODE_PRB_OFFSET 0x00004000

#MACRO KeIsPointerInNodeSpace ( ptr ) [
    ((ptr) >= KE_NODE_SPACE_START)
]

#IF BLD_NUMA

#DEFINE KE_NODE_SPACE_SIZE 0x10000000

#DEFINE KE_BL_BUMP_SPACE_OFFSET 0x20000

#DEFINE KE_POOL_SPACE_OFFSET 0x4000000
#DEFINE KE_POOL_SPACE_SIZE [(64 * 1024 * 1024)]

#DEFINE KE_DYNAMIC_SPACE_OFFSET 0x8000000
#DEFINE KE_DYNAMIC_SPACE_SIZE [(64 * 1024 * 1024)]

#DEFINE KE_CACHE_SPACE_OFFSET 0xC000000
#DEFINE KE_CACHE_SPACE_SIZE [(64 * 1024 * 1024)]

#MACRO KeNumaNodeFromSpacePointer ( ptr ) [
    // We map the virtual NUMA node spaces on XR/frame from 0xC0000000 to the
    // top of the address space in 256MB increments. Four nodes exist, so bits
    // 29:28 are the node ID. Masking off bits 0:27 is sufficient to calculate
    // the pointer to a node structure given a pointer within the node space
    // since it lies at the base of its node space.

    (CAST ((ptr) & 0xF0000000) TO ^KeuNode)
]

#MACRO KeNumaNodeFromArbitraryPointer ( ptr ) [
    // This works even with pointers that are not in node space by ORing the
    // pointer with KE_NODE_SPACE_START. The effect is that for pointers in a
    // static section of the kernel or a module, we should get a pointer to
    // the boot node at 0xC0000000.

    (CAST (((ptr) & 0xF0000000) | KE_NODE_SPACE_START) TO ^KeuNode) 
]

#MACRO KeCurrentVolatileNode () [
    ((CAST 0xFFFFCFF4 TO ^^KeuNode)^)
]

#MACRO KeNumaNodeById ( id ) [
    (CAST KE_NODE_SPACE_START + ((id) * KE_NODE_SPACE_SIZE) TO ^KeuNode)
]

#ELSE

#DEFINE KE_NODE_SPACE_SIZE 0x40000000

#DEFINE KE_BL_BUMP_SPACE_OFFSET 0x00020000

#DEFINE KE_POOL_SPACE_OFFSET 0x10000000
#DEFINE KE_POOL_SPACE_SIZE [(256 * 1024 * 1024)]

#DEFINE KE_DYNAMIC_SPACE_OFFSET 0x20000000
#DEFINE KE_DYNAMIC_SPACE_SIZE [(256 * 1024 * 1024)]

#DEFINE KE_CACHE_SPACE_OFFSET 0x30000000
#DEFINE KE_CACHE_SPACE_SIZE [(256 * 1024 * 1024)]

#MACRO KeNumaNodeFromSpacePointer ( ptr ) [
    // On an architecture with real NUMA support, this macro may do something
    // like subtract the base of dynamic space from the pointer and convert
    // some pointer bits into a NUMA node ID.

    (CAST KE_NODE_SPACE_START TO ^KeuNode)
]

#MACRO KeNumaNodeById ( id ) [
    (CAST KE_NODE_SPACE_START TO ^KeuNode)
]

#MACRO KeNumaNodeFromArbitraryPointer ( ptr ) [
    (CAST KE_NODE_SPACE_START TO ^KeuNode)
]

#MACRO KeCurrentVolatileNode () [
    (CAST KE_NODE_SPACE_START TO ^KeuNode)
]

#END