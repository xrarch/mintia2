//
// Implements interrupt support for the XR/station HAL.
//

#INCLUDE "Halp.hjk"

#SECTION "text"
HalpIplToLsicIpl : UBYTE[32] = {
    [0] = 63,
    [1] = 63,
    [2] = 63,
    [3] = 63,
    [HALU_IPL_INTERACTIVE] = 47,
    [HALU_IPL_BOARDS] = 15,
    [HALU_IPL_SERIAL] = 3,
    [HALU_IPL_DISK] = 2,
    [8] = 2,
    [9] = 2,
    [10] = 2,
    [11] = 2,
    [12] = 2,
    [13] = 2,
    [14] = 2,
    [15] = 2,
    [16] = 2,
    [17] = 2,
    [18] = 2,
    [19] = 2,
    [20] = 2,
    [21] = 2,
    [22] = 2,
    [23] = 2,
    [24] = 2,
    [25] = 2,
    [26] = 2,
    [27] = 2,
    [28] = 2,
    [KEP_IPL_CLOCK] = 1,
    [KEP_IPL_IPI] = 0,
    [KEP_IPL_HIGH] = 0,
}

FN HaluRaiseHardwareIpl (
    IN ipl : UWORD,
) : UWORD

    // Raise the hardware IPL by programming the LSIC.
    // This isn't part of KepRaiseIpl since that is written in a tightly
    // optimized manner around the most common usage (changing between software
    // IPLs, which need not reprogram the hardware interrupt masks).

    prb := KEP_CURRENT_PRB_LOCAL

    // Disable interrupts so that changes to the software IPL and the LSIC's
    // view of IPL are atomic from the perspective of ISRs, to stop them from
    // getting confused.

    ints := KepDisableInterrupts ()

    // Set the new IPL in the Prb.

    oldipl := prb^.Ipl
    prb^.Ipl = ipl

    KeAssert ( ipl > KEP_IPL_DPC )
    KeAssert ( ipl >= oldipl )

    // Write the corresponding hardware IPL into the LSIC.

    lsic := CAST prb^.LsicBase TO ^HalpLsic

    lsic^.Ipl = HalpIplToLsicIpl[ipl]

    // Restore interrupts.

    KepRestoreInterrupts ( ints )

    RETURN oldipl
END

FN HaluLowerHardwareIpl (
    IN ipl : UWORD,
)

    // Set the hardware IPL by programming the LSIC.
    // This isn't part of KepLowerIpl since that is written in a tightly
    // optimized manner around the most common usage (changing between software
    // IPLs, which need not reprogram the hardware interrupt masks).

    prb := KEP_CURRENT_PRB_LOCAL

    // Disable interrupts so that changes to the software IPL and the LSIC's
    // view of IPL are atomic from the perspective of ISRs, to stop them from
    // getting confused.

    ints := KepDisableInterrupts ()

    KeAssert ( ipl <= prb^.Ipl )
    KeAssert ( prb^.Ipl > KEP_IPL_DPC )

    // Write the corresponding hardware IPL into the LSIC.

    lsic := CAST prb^.LsicBase TO ^HalpLsic

    lsic^.Ipl = HalpIplToLsicIpl[ipl]

    // Set the new IPL in the Prb.

    prb^.Ipl = ipl

    // Restore interrupts.

    KepRestoreInterrupts ( ints )

    // We don't need to check this in the disabled interrupts section because if
    // we get a stale PendingSoftwareInterrupts value from another processor, we
    // will harmlessly call KepDispatchSoftwareInterrupts which does nothing.
    // And we can't "miss" any since all events that switch us to another
    // processor will cause software interrupt dispatch anyway.

    IF prb^.PendingSoftwareInterrupts >> ipl THEN
        KepDispatchSoftwareInterrupts ( ipl )
    END
END

FN (KeInterruptF) HaluHandleDeviceInterrupt (
    IN interrupt : ^KeuInterrupt,
    IN context : ^OsContext,
)

    // Default handler for non-special interrupts.

    prb := KEP_CURRENT_PRB_LOCAL

    lsic := CAST prb^.LsicBase TO ^HalpLsic

    // Set the LSIC IPL.

    lsic^.Ipl = HalpIplToLsicIpl[interrupt^.Ipl]
    BARRIER

    // Capture old IPL and set new in Prb.

    oldipl := prb^.Ipl
    prb^.Ipl = interrupt^.Ipl
    context^.OldIpl = oldipl

    // Safe to enable interrupts now since we won't re-take the same IRQ after
    // masking it off.

    KepEnableInterrupts ()

    // Acquire the interrupt object's spinlock. This synchronizes against
    // other processors which have a driver trying to run code that is
    // synchronized against their ISR, to access some shared data.

#IF BLD_MP
    KepAcquireSpinlock ( &interrupt^.Spinlock )
#END

    // Call the routine.

    interrupt^.Routine (
        interrupt, // interrupt
        context, // context
    )

#IF BLD_MP
    KepReleaseSpinlock ( &interrupt^.Spinlock )
#END

    // Disable interrupts.

    KepDisableInterrupts ()

    // Reset the LSIC IPL.

    lsic^.Ipl = HalpIplToLsicIpl[oldipl]
    BARRIER

    // Reset the Prb IPL.

    prb^.Ipl = oldipl
END

#IF BLD_MP

FN (KeInterruptF) HalpHandlePerCpuInterrupt (
    IN interrupt : ^KeuInterrupt,
    IN context : ^OsContext,
)

    // Optimized handler for per-cpu interrupts.
    // Namely, the timer interrupt.
    // There is no need to take a spinlock for such interrupts so we don't.

    prb := KEP_CURRENT_PRB_LOCAL

    lsic := CAST prb^.LsicBase TO ^HalpLsic

    // Set the LSIC IPL.

    lsic^.Ipl = HalpIplToLsicIpl[interrupt^.Ipl]
    BARRIER

    // Capture old IPL and set new in Prb.

    oldipl := prb^.Ipl
    prb^.Ipl = interrupt^.Ipl
    context^.OldIpl = oldipl

    // Safe to enable interrupts now since we won't re-take the same IRQ after
    // masking it off.

    KepEnableInterrupts ()

    // Call the routine.

    interrupt^.Routine (
        interrupt, // interrupt
        context, // context
    )

    // Disable interrupts.

    KepDisableInterrupts ()

    // Reset the LSIC IPL.

    lsic^.Ipl = HalpIplToLsicIpl[oldipl]
    BARRIER

    // Reset the Prb IPL.

    prb^.Ipl = oldipl
END

#END

FN HaluInterrupt (
    IN context : ^OsContext,
)

    // Called by architecture-specific code in Ke when an interrupt is detected.

    prb := KEP_CURRENT_PRB_LOCAL

    lsic := CAST prb^.LsicBase TO ^HalpLsic

    vector := lsic^.ClaimComplete
    BARRIER

    // Immediately complete the interrupt.

    lsic^.ClaimComplete = vector
    BARRIER

    int := prb^.IrqDispatchTable[vector]

    // Call the handler.

    int^.Handler (
        int, // interrupt
        context, // context
    )
END

FN HaluEnableInterrupt (
    IN prb : ^KepPrb,
    IN vector : UWORD,
)

    // Enable the interrupt with the given vector.
    // Interrupts are disabled and we are running on the target processor.

    lsic := CAST prb^.LsicBase TO ^HalpLsic

    maskptr := &lsic^.Mask0

    IF vector >= 32 THEN
        vector -= 32
        maskptr = &lsic^.Mask1
    END

    // Read the current LSIC mask.

    mask := maskptr^

    // Clear the bit for this interrupt (enabling it).

    mask &= ~(1 << vector)

    // Set the new mask.

    maskptr^ = mask
END

FN HaluDisableInterrupt (
    IN prb : ^KepPrb,
    IN vector : UWORD,
)

    // Disable the interrupt with the given vector.
    // Interrupts are disabled and we are running on the target processor.

    lsic := CAST prb^.LsicBase TO ^HalpLsic

    maskptr := &lsic^.Mask0

    IF vector >= 32 THEN
        vector -= 32
        maskptr = &lsic^.Mask1
    END

    // Read the current LSIC mask.

    mask := maskptr^

    // Set the bit for this interrupt (disabling it).

    mask |= 1 << vector

    // Set the new mask.

    maskptr^ = mask
END

#IF BLD_MP

FN HaluTriggerIpi (
    IN target : ^KepPrb,
    IN type : UWORD,
)

    // Acquire the stashed LSIC pointer.

    lsic := CAST target^.LsicBase TO ^HalpLsic

    // Write the IPI interrupt into the LSIC interrupt pending register for the
    // target processor. This will atomically OR it in.

    // On XR/station, we use IRQ1 (the highest priority IRQ supported by the
    // interrupt controller) for the synchronous IPI and IRQ63 for the async
    // IPI.

    IF type == KEP_IPI_SYNCHRONOUS THEN
        lsic^.Pending0 = 1 << 1

    ELSE
        lsic^.Pending1 = 1 << 31
    END
END

FN HaluBroadcastIpi (
    IN except : ^KepPrb,
    IN type : UWORD,
)

    // Broadcast IPIs to all processors except the one provided, which is
    // also guaranteed to be the one we're executing on. We have to do this
    // one at a time on XR/station.

    kenode := KeBootNode
    targetprb := KepPrbFromNodeAndNumber ( kenode, 0 )
    count := kenode^.ProcessorCount
    i := 0

    // Now send IPIs to all of the processors in the system (other than me).

    WHILE i < count DO
        // Don't IPI the processor if it's me.

        IF targetprb != except THEN
            HaluTriggerIpi (
                targetprb, // target
                type, // type
            )
        END

        i += 1
        targetprb += BL_PRB_SIZE
    END
END

FN (KeInterruptF) HalpDismissInterrupt (
    IN interrupt : ^KeuInterrupt,
    IN context : ^OsContext,
)

    NOTHING
END

#END