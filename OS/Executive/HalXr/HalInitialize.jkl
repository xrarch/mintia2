//
// Implements initialization for the XR/station HAL.
//

#INCLUDE "Halp.hjk"

#SECTION "INITtext"
FN HalpConfigureTimer ()

    // Configure the timer interrupt to interrupt at 5ms intervals.

    timer := CAST KeuLoaderBlock.U.Xr.CitronBase + 0x80 TO ^HalpTimer

    timer^.DataPort = HALU_TIMER_INTERVAL
    BARRIER

    timer^.CmdPort = 1
    BARRIER
END

#SECTION "INITtext"
FN HalpInitializeLsic (
    IN prb : ^KepPrb,
)

    // Initialize the interrupt controller to mask out all interrupts except
    // for the timer interrupt and IPI interrupt. Then enable interrupts.
    // Guaranteed to be called on the given processor.

    lsic := CAST KeuLoaderBlock.U.Xr.LsicBase +
        KepCurrentProcessorHwId () * HALP_LSIC_GAP TO ^HalpLsic

    // Stash the LSIC base.

    prb^.LsicBase = lsic

    // Reset the pending registers.

    lsic^.Pending0 = 0
    lsic^.Pending1 = 0
    BARRIER

    // Initially set the IPL to 63 to enable all.

    lsic^.Ipl = 63
    BARRIER

    // Configure the mask to enable IPIs and the timer.

    lsic^.Mask0 = 0xFFFFFFF9
    lsic^.Mask1 = 0x7FFFFFFF
    BARRIER

    // Initialize the timer interrupt object.

    int := &prb^.TimerInterrupt

    KeuInitializeInterrupt (
        int, // interrupt
        &KepClockTick, // routine
        0, // context
        2, // vector
        KEP_IPL_CLOCK, // ipl
        FALSE, // edgetriggered
        FALSE, // sharevector
        prb, // prb
    )

#IF BLD_MP
    // Override the high level handler to the special optimized one.

    int^.Handler = &HalpHandlePerCpuInterrupt
#END

    // Manually insert in PRB.

    prb^.IrqDispatchTable[2] = int

#IF BLD_MP
    // Initialize the synchronous IPI interrupt object.

    int = &prb^.IpiInterrupt1

    KeuInitializeInterrupt (
        int, // interrupt
        0, // routine
        0, // context
        1, // vector
        KEP_IPL_IPI, // ipl
        FALSE, // edgetriggered
        FALSE, // sharevector
        prb, // prb
    )

    // Override the high level handler to bypass all the unnecessary general
    // interrupt stuff and just directly call the kernel's IPI service routine.

    int^.Handler = &KepServiceIpi

    // Manually insert in PRB.

    prb^.IrqDispatchTable[1] = int

    // Initialize the asynchronous IPI interrupt object.

    int = &prb^.IpiInterrupt2

    KeuInitializeInterrupt (
        int, // interrupt
        0, // routine
        0, // context
        63, // vector
        KEP_IPL_IPI, // ipl
        FALSE, // edgetriggered
        FALSE, // sharevector
        prb, // prb
    )

    // Override the high level handler to do absolutely nothing, because no
    // action is required upon an asynchronous IPI other than to process
    // software interrupts on the way out.

    int^.Handler = &HalpDismissInterrupt

    prb^.IrqDispatchTable[63] = int
#END

    // Enable interrupts.

    KepEnableInterrupts ()
END

#SECTION "INITtext"
FN HaluProcessorInitialize (
    IN prb : ^KepPrb,
)

    // Do whatever is needed to initialize the given processor.
    // Guaranteed to be called on that processor.

    HalpInitializeLsic ( prb )
END

#SECTION "INITtext"
FN HaluEarlyInitialize (
    IN kenode : ^KeuNode,
)

    // This initialization routine is called before there is a system thread
    // context. Here we have to establish everything required for base line
    // functionality, including a simple boot console of some variety.

    HalpInitializeConsole ()

    HalpConfigureTimer ()
END

#IF BLD_MP

#SECTION "INITtext"
FN HaluStartProcessors (
    IN startfunc : HaluStartProcessorF,
)

    // Call the Loader to do platform-specific stuff to start the processors.
    // We have to call the firmware with paging disabled. We can't do that from
    // here, but on XR/station the Loader lives in an identity mapping of low
    // memory, so he can do that just fine.

    KeuLoaderBlock.U.Xr.StartProcessors ( CAST startfunc TO BlStartProcessorF )
END

#END