//
// Implementation of a simple boot console.
//

#INCLUDE "Halp.hjk"

HalpUseFramebuffer := FALSE
HalpDebugConsole := FALSE
HalpFramebufferBytes := 0
HalpFont : ^HaluConsoleFont
HalpCursorX := 0
HalpCursorY := 0
HalpWidth := 0
HalpHeight := 0

#IF BLD_MP

PUBLIC HalpConsoleLock : HaluSpinlock

#END

#DEFINE HALU_CONSOLE_FG 0x00
#DEFINE HALU_CONSOLE_BG 0xFF

FN HalpDrawCharacter (
    IN c : UWORD,
    IN x : UWORD,
    IN y : UWORD,
)

    font := HalpFont
    w := font^.Width
    h := font^.Height

    j : UWORD
    byte : UWORD
    left : UWORD

    dest : ^UBYTE =
        KeuLoaderBlock.BootFbBase + x + (y * KeuLoaderBlock.BootFbWidth)

    mod := KeuLoaderBlock.BootFbWidth - w

    bmp := CAST font + SIZEOF HaluConsoleFont TO ^UBYTE
    bmp += ((w + 7) >> 3) * h * c

    IF font^.Flags & HCF_FLAG_REVERSE == 0 THEN
        WHILE h DO
            left = w >> 3

            WHILE left DO
                byte = bmp^

                IF byte & 128 THEN
                    dest[0] = HALU_CONSOLE_FG
                ELSE
                    dest[0] = HALU_CONSOLE_BG
                END

                IF byte & 64 THEN
                    dest[1] = HALU_CONSOLE_FG
                ELSE
                    dest[1] = HALU_CONSOLE_BG
                END

                IF byte & 32 THEN
                    dest[2] = HALU_CONSOLE_FG
                ELSE
                    dest[2] = HALU_CONSOLE_BG
                END

                IF byte & 16 THEN
                    dest[3] = HALU_CONSOLE_FG
                ELSE
                    dest[3] = HALU_CONSOLE_BG
                END

                IF byte & 8 THEN
                    dest[4] = HALU_CONSOLE_FG
                ELSE
                    dest[4] = HALU_CONSOLE_BG
                END

                IF byte & 4 THEN
                    dest[5] = HALU_CONSOLE_FG
                ELSE
                    dest[5] = HALU_CONSOLE_BG
                END

                IF byte & 2 THEN
                    dest[6] = HALU_CONSOLE_FG
                ELSE
                    dest[6] = HALU_CONSOLE_BG
                END

                IF byte & 1 THEN
                    dest[7] = HALU_CONSOLE_FG
                ELSE
                    dest[7] = HALU_CONSOLE_BG
                END

                dest += 8
                left -= 1
                bmp += 1
            END

            left = w & 7

            IF left THEN
                byte = bmp^
                bmp += 1
                
                IF w >> 3 THEN
                    j = 128

                ELSE
                    j = 1 << left
                END

                WHILE left DO
                    IF byte & j THEN
                        dest^ = HALU_CONSOLE_FG
                    ELSE
                        dest^ = HALU_CONSOLE_BG
                    END

                    dest += 1
                    j >>= 1
                    left -= 1
                END
            END

            dest += mod
            h -= 1
        END

    ELSE
        WHILE h DO
            left = w >> 3

            WHILE left DO
                byte = bmp^

                IF byte & 128 THEN
                    dest[7] = HALU_CONSOLE_FG
                ELSE
                    dest[7] = HALU_CONSOLE_BG
                END

                IF byte & 64 THEN
                    dest[6] = HALU_CONSOLE_FG
                ELSE
                    dest[6] = HALU_CONSOLE_BG
                END

                IF byte & 32 THEN
                    dest[5] = HALU_CONSOLE_FG
                ELSE
                    dest[5] = HALU_CONSOLE_BG
                END

                IF byte & 16 THEN
                    dest[4] = HALU_CONSOLE_FG
                ELSE
                    dest[4] = HALU_CONSOLE_BG
                END

                IF byte & 8 THEN
                    dest[3] = HALU_CONSOLE_FG
                ELSE
                    dest[3] = HALU_CONSOLE_BG
                END

                IF byte & 4 THEN
                    dest[2] = HALU_CONSOLE_FG
                ELSE
                    dest[2] = HALU_CONSOLE_BG
                END

                IF byte & 2 THEN
                    dest[1] = HALU_CONSOLE_FG
                ELSE
                    dest[1] = HALU_CONSOLE_BG
                END

                IF byte & 1 THEN
                    dest[0] = HALU_CONSOLE_FG
                ELSE
                    dest[0] = HALU_CONSOLE_BG
                END

                dest += 8
                left -= 1
                bmp += 1
            END

            left = w & 7

            IF left THEN
                byte = bmp^
                bmp += 1
                j = 1

                WHILE left DO
                    IF byte & j THEN
                        dest^ = HALU_CONSOLE_FG
                    ELSE
                        dest^ = HALU_CONSOLE_BG
                    END

                    dest += 1
                    j <<= 1
                    left -= 1
                END
            END

            dest += mod
            h -= 1
        END
    END
END

FN HalpClearScreen ()

    // Fill the framebuffer with blue pixels.

    ulong := (HALU_CONSOLE_BG << 24) |
        (HALU_CONSOLE_BG << 16) |
        (HALU_CONSOLE_BG << 8) |
        HALU_CONSOLE_BG

    RtlFillMemoryWithUlong (
        KeuLoaderBlock.BootFbBase, // ptr
        HalpFramebufferBytes, // sz
        ulong, // ulong
    )

    HalpCursorX = 0
    HalpCursorY = 0
END

FN HalpScrollScreen ()

    // Scroll the framebuffer up by 1 line. This is REALLY slow but the HAL
    // console isn't a performance concern (if it shows up in runtime, the
    // system is either being debugged, or something broke) so simplicity beats
    // speed here. The primary system console used during runtime is *not* this
    // one.

    font := HalpFont

    RtlCopyBytes (
        KeuLoaderBlock.BootFbBase, // dest
        KeuLoaderBlock.BootFbBase +
        KeuLoaderBlock.BootFbWidth * font^.Height, // src
        KeuLoaderBlock.BootFbWidth *
        (KeuLoaderBlock.BootFbHeight - font^.Height), // sz
    )

    // Clear the last line.

    ulong := (HALU_CONSOLE_BG << 24) |
        (HALU_CONSOLE_BG << 16) |
        (HALU_CONSOLE_BG << 8) |
        HALU_CONSOLE_BG

    RtlFillMemoryWithUlong (
        KeuLoaderBlock.BootFbBase +
        KeuLoaderBlock.BootFbWidth *
        (HalpHeight - 1) * font^.Height, // ptr
        KeuLoaderBlock.BootFbWidth * font^.Height, // sz
        ulong, // ulong
    )
END

FN HaluPutCharacter (
    IN byte : UBYTE,
)

    oldstate : UWORD

    dbg := HalpDebugConsole

    IF NOT dbg THEN
        oldstate = HalpAcquireConsole ()
    END

    IF HalpUseFramebuffer AND NOT dbg THEN
        // Write to the framebuffer console.

        IF byte == '\n' OR HalpCursorX >= HalpWidth THEN
            HalpCursorX = 0
            HalpCursorY += 1
        END

        IF HalpCursorY >= HalpHeight THEN
            HalpCursorX = 0
            HalpCursorY = HalpHeight - 1

            HalpScrollScreen ()
        END

        IF byte != '\n' THEN
            HalpDrawCharacter (
                byte, // c
                HalpCursorX * HalpFont^.Width, // x
                HalpCursorY * HalpFont^.Height, // y
            )

            HalpCursorX += 1
        END

    ELSE
        // Write to serial port.

        HaluDebugWrite ( byte )
    END

    IF NOT dbg THEN
        HalpReleaseConsole ( oldstate )
    END
END

FN HaluCrashConsole ()

    // We assume the system is in a globally single-threaded uniprocessor state
    // right now (since KeCrash has disabled interrupts and made any other
    // processors quiescent). Don't bother taking locks.

    IF HalpUseFramebuffer AND NOT HalpDebugConsole THEN
        // Set the console cursor to x=0 y=0.

        HalpCursorX = 0
        HalpCursorY = 0

        // Draw a cool shutter effect.

        size := HalpFramebufferBytes
        addr := CAST KeuLoaderBlock.BootFbBase TO ^UBYTE

        height := KeuLoaderBlock.BootFbHeight

        WHILE height DO
            width := KeuLoaderBlock.BootFbWidth

            off := height & 1

            WHILE width >= 2 DO
                addr[off] = 0

                width -= 2
                addr += 2
            END

            height -= 1
        END
    END
END

FN HaluQueryConsoleSize (
    OUT width : UWORD,
    OUT height : UWORD,
)

    IF HalpUseFramebuffer THEN
        width = HalpWidth
        height = HalpHeight

    ELSE
        // Assume VT terminal.

        width = 80
        height = 24
    END
END

FN HaluQueryConsolePosition (
    OUT x : UWORD,
    OUT y : UWORD,
)

    IF HalpUseFramebuffer THEN
        x = HalpCursorX
        y = HalpCursorY

    ELSE
        x = 0
        y = 0
    END
END

FN HaluSetConsolePosition (
    IN x : UWORD,
    IN y : UWORD,
)

    IF x >= HalpWidth THEN
        x = HalpWidth - 1
    END

    IF y >= HalpHeight THEN
        y = HalpHeight - 1
    END

    HalpCursorX = x
    HalpCursorY = y
END

FN HaluCenterPrint (
    IN str : ^UBYTE,
)

    len := RtlMeasureString ( str )

    IF str[len - 1] == '\n' THEN
        len -= 1
    END

    pad := (HalpWidth / 2) - (len / 2)

    WHILE pad DO
        RtlPrint ( " " )

        pad -= 1
    END

    RtlPrint ( "%s", str )
END

#SECTION "INITtext"
FN HalpInitializeConsole ()

    // First see if we got a boot framebuffer.

    IF KeuLoaderBlock.BootFbBase THEN
        // We did! Try to find the HAL console font resource.

        rsrc := KeFindResource (
            "HalFont", // name
            OUT HalpFont, // data
        )

        IF rsrc AND HalpFont^.Magic == HCF_MAGIC THEN
            KePinResource ( rsrc )

            HalpUseFramebuffer = TRUE

            HalpFramebufferBytes =
                KeuLoaderBlock.BootFbWidth * KeuLoaderBlock.BootFbHeight

            HalpWidth = KeuLoaderBlock.BootFbWidth / HalpFont^.Width
            HalpHeight = KeuLoaderBlock.BootFbHeight / HalpFont^.Height

            // Draw the background.

            HalpClearScreen ()
        END
    END
END

EXPORT FN HaluSetDebugConsole (
    IN new : UWORD,
) : UWORD

    RETURN KeFetchAndSetUlong (
        &HalpDebugConsole, // ptr
        new, // newvalue
    )
END