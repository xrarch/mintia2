//
// Management for name string internment for the MINTIA namespace.
//

#INCLUDE "Nsp.hjk"

#DEFINE NSP_NAME_BUCKETS 32

STRUCT NspNameBucket
    TreeRoot : RtlAvlNode,
    Lock : KeLock,
END

NspNameBuckets : NspNameBucket[NSP_NAME_BUCKETS]

#SECTION "INITtext"
FN NspInitializeNames ()

    // Initialize the interned name buckets for the namespace.

    i := 0

    WHILE i < NSP_NAME_BUCKETS DO
        RtlInitializeAvl ( &NspNameBuckets[i].TreeRoot )

        KeInitializeLock ( &NspNameBuckets[i].Lock )

        i += 1
    END
END

#SECTION "PAGEtext"
FN (RtlAvlLessThanF) NspCompareNameNodes (
    IN a : ^RtlAvlNode,
    IN b : ^RtlAvlNode,
) : UWORD

    // Return whether A < B, lexicographically.

    RETURN CAST RtlCompareString (
        NspNameToString ( CONTAINEROF a TO NspName.Entry ), // str1
        NspNameToString ( CONTAINEROF b TO NspName.Entry ), // str2
    ) TO WORD < 0
END

#SECTION "PAGEtext"
FN NspHash (
    IN str : ^UBYTE,
    OUT len : UWORD,
) : UWORD

    // Simple hash for a string.

    hash := 0
    len = 0

    WHILE str^ DO
        hash += str^
        hash += hash << 10
        hash $= hash >> 6

        str += 1
        len += 1
    END

    hash += hash << 3
    hash $= hash >> 11
    hash += hash << 15

    RETURN hash
END

#SECTION "PAGEtext"
FN NspFindName (
    IN name : ^UBYTE,
) : ^NspName

    // Find a name in the string internment buckets.

    node : ^NspName

    // Hash the name.

    len : UWORD

    hash := NspHash (
        name, // name
        OUT len, // len
    )

    // Get the hash bucket.

    bucket := &NspNameBuckets[hash & (NSP_NAME_BUCKETS - 1)]

    // Lock the bucket.

    KeAcquireLockExclusive ( &bucket^.Lock )

    // Look up the name in the bucket, which is an AVL tree keyed by string and
    // ordered lexicographically.

    avlnode := bucket^.TreeRoot.Right

    WHILE TRUE DO
        IF NOT avlnode THEN
            // Didn't find it, we'll need to create it.

            BREAK
        END

        node = CONTAINEROF avlnode TO NspName.Entry

        res := CAST RtlCompareString (
            name, // str1
            NspNameToString ( node ), // str2
        ) TO WORD

        IF res == 0 THEN
            // Found it! Unlock the bucket and return the node.

            node^.References += 1

            KeReleaseLock ( &bucket^.Lock )

            RETURN node
        END

        IF res < 0 THEN
            avlnode = avlnode^.Left
        ELSE
            avlnode = avlnode^.Right
        END
    END

    // Add space for a null terminator.

    len += 1

    // Round up name length.

    len = (len + RTL_MACHINE_WORD_SIZE - 1) & ~(RTL_MACHINE_WORD_SIZE - 1)

    // Create a node.

    node = MmAllocatePool (
        MM_PAGED_POOL, // poolindex
        SIZEOF NspName + len, // bytes
        'Name', // tag
        TRUE, // wait
    )

    IF NOT node THEN
        // Failed to allocate the name.

        KeReleaseLock ( &bucket^.Lock )

        RETURN NULLPTR
    END

    // Initialize the name.

    node^.References = 1
    node^.BucketIndex = hash & (NSP_NAME_BUCKETS - 1)

    RtlCopyString (
        NspNameToString ( node ), // dest
        name, // src
        -1, // bufsize
    )

    // Insert into the tree.

    RtlInsertAvl (
        &bucket^.TreeRoot, // root
        &node^.Entry, // node
        &NspCompareNameNodes, // comparisonfunc
    )

    // Unlock bucket and return node.

    KeReleaseLock ( &bucket^.Lock )

    RETURN node
END

#SECTION "PAGEtext"
FN NspUnreferenceName (
    IN name : ^NspName,
)

    // Unreference the name node.

    bucket := &NspNameBuckets[name^.BucketIndex]

    // Lock the bucket.

    KeAcquireLockExclusive ( &bucket^.Lock )

    // Decrement the reference count.

    oldcount := name^.References
    name^.References = oldcount - 1

    IF oldcount == 1 THEN
        // Remove from tree.

        RtlPrint ( "free %s\n", NspNameToString ( name ) )

        RtlRemoveAvl (
            &bucket^.TreeRoot, // root
            &name^.Entry, // node
        )

        // Free.

        MmFreePool (
            name, // ptr
            'Name', // tag
        )
    END

    // Unlock the bucket.

    KeReleaseLock ( &bucket^.Lock )
END