//
// Implements executive-level process objects.
//

#INCLUDE "Psp.hjk"

STRUCT PspProcessContext
    Name : ^UBYTE,
    Partition : ^MiPartition,
    QuotaUid : ULONG,
    Flags : ULONG,
END

#SECTION "PAGEtext"
FN PsBlockRundownProcess (
    IN process : ^PsProcess,
) : UWORD

    // Prevent the rundown (clean-up) of the process until the next
    // PsUnblockRundownProcess. This works by locking the process lock shared,
    // so recursive nesting of this state is inadvisable (if not prohibited).
    //
    // If needsthread is set, atomically check for the existence of a living
    // thread who is going to tear down the process if its terminated. This is
    // intended to provide a guarantee that terminating a process, even one that
    // is only partially constructed, will reliably tear down certain resources
    // like handles and memory mappings. Returns TRUE on success, FALSE
    // otherwise.

    KeAcquireLockShared ( &process^.Pcb.Lock )

    IF NOT process^.Pcb.SignalThread THEN
        // No living thread.

        KeReleaseLock ( &process^.Pcb.Lock )

        RETURN FALSE
    END

    RETURN TRUE
END

#SECTION "PAGEtext"
FN PspSignalActivation (
    IN process : ^PsProcess,
    IN status : OsStatus,
)

    // Signal the activation of the process.

    paged := process^.Paged

    KeAcquireLockExclusive ( &paged^.ActivationLock )

    event := paged^.ActivationEvent

    IF NOT event THEN
        // Already activated.

        KeReleaseLock ( &paged^.ActivationLock )

        LEAVE
    END

    paged^.ActivationStatus = status

    paged^.ActivationEvent = NULLPTR

    KeReleaseLock ( &paged^.ActivationLock )

    // Wake anyone awaiting activation of this process.

    KeSignalEvent (
        &event^.Used.Event, // event
        0, // priorityboost
    )

    // Decrement the reference count on the event counter.

    ExUnreferenceEventCounter ( event )
END

#SECTION "PAGEtext"
FN PspAwaitActivation (
    IN process : ^PsProcess,
    IN timeout : ^RtlUquad,
    IN alertable : UWORD,
    OUT activationstatus : OsStatus,
) : OsStatus

    // Wait for the activation of the process.

    paged := process^.Paged

    KeAcquireLockShared ( &paged^.ActivationLock )

    event := paged^.ActivationEvent

    IF NOT event THEN
        // Already activated.

        KeReleaseLock ( &paged^.ActivationLock )

        activationstatus = paged^.ActivationStatus

        RETURN OS_STATUS_SUCCESS
    END

    ExReferenceEventCounter ( event )

    KeReleaseLock ( &paged^.ActivationLock )

    // Wait on the event counter.

    status := KeWaitForSingleObject (
        KE_USER_MODE, // waitmode
        KE_ALERTABLE, // alertable
        timeout, // timeout
        &event^.Used.Event.Header, // object
    )

    ExUnreferenceEventCounter ( event )

    activationstatus = paged^.ActivationStatus

    IF status == 0 THEN
        status = OS_STATUS_SUCCESS
    END

    RETURN status
END

#SECTION "PAGEtext"
FN PspExitProcess (
    IN process : ^PsProcess,
    IN status : OsStatus,
)

    // The process has exited and exit-time teardown must be performed. This can
    // occur in two situations:
    //
    //  1. The process's final thread has terminated, and called this routine.
    //  2. The process never had any threads, and the object is being deleted.
    //
    // We distinguish between exit-time and deletion-time teardown for the
    // process object so that it's more difficult for a malicious or buggy
    // program to hog system resources by keeping a long-lived handle to a
    // process that has terminated. The second thing we do is to forbid certain
    // operations (like memory mapping) from being performed until the first
    // thread for a process has been created. That way there's always someone
    // obvious to terminate, who will make their way through this codepath here,
    // and relinquish all of the resources associated with the process.

    paged := process^.Paged

    IF NOT paged^.TerminationStatus THEN
        paged^.TerminationStatus = status
    END

#IF BLD_CHK
    IF paged^.CleanedUp THEN
        KeCrash ( "PspExitProcess: already exited\n" )
    END
#END

    paged^.CleanedUp = TRUE

    IF paged^.Job THEN
        // Indicate termination to job.

        PspExitJobProcess ( process )
    END

    // Uninitialize the process with respect to Ob.

    ObUninitializeProcess ( process )

    // Uninitialize the process's virtual memory structures.

    MmUninitializeProcess ( process )

    // Remove from process group.

    IF paged^.ProcessGroup THEN
        PspRemoveProcessGroup ( process )
    END

    // If activation hasn't been signaled, do so now in order to get rid of the
    // activation event counter.

    IF paged^.ActivationEvent THEN
        PspSignalActivation (
            process, // process
            status, // status
        )
    END

    // Signal the termination event.

    KeSignalEvent (
        &process^.TerminationEvent, // event
        0, // priorityboost
    )
END

#SECTION "PAGEtext"
FN (ObTypeDeleteF) PspDeleteProcessObject (
    IN object : ^VOID,
) : UWORD

    // Delete a process object.

    process := CAST object TO ^PsProcess

    paged := process^.Paged

    IF NOT paged^.CleanedUp THEN
        // Clean up the process. It had no "final thread" to do this earlier.

        PspExitProcess (
            process, // process
            0, // status
        )
    END

    // Remove from the global process list.

    KeAcquireLockExclusive ( &PspProcessListLock )

    RtlRemoveEntryList ( &paged^.GlobalEntry )

    KeReleaseLock ( &PspProcessListLock )

    // Delete the PID.

    PspDeleteId ( paged^.Pid )

    // Uninitialize the root and current directory of the process.

    NsUninitializeProcess ( process )

    // Perform deletion of the page directory, etc.

    MmDeleteProcess ( process )

    // Unreference the name.

    ExUnreferenceName ( paged^.Name )

#IF ( STRCMP ARCHITECTURE "xr17032" )
    // Free the AsidTable.

    MmFreePool (
        process^.Pcb.AsidTable, // ptr
        'Asid', // tag
    )
#END

    // Unreference the quota block.

    MmUnreferenceQuotaBlock ( paged^.HandleTable.QuotaBlock )

    RETURN TRUE
END

#SECTION "PAGEtext"
FN (ObTypeInitializeF) PspInitializeProcessObject (
    IN object : ^VOID,
    IN context : ^VOID,
) : OsStatus

    process := CAST object TO ^PsProcess
    ctx := CAST context TO ^PspProcessContext

    status : OsStatus

    // Initialize the process object.

    currentprocess := PsCurrentProcess ()

    flags := ctx^.Flags

    IF flags & (OS_PROCESS_DETACH_JOB | OS_PROCESS_NEW_SESSION) THEN
        // If either of these flags were specified, we can only do this if we
        // are an admin.

        IF currentprocess^.Paged^.Cred.Gid != OS_SYSTEM_GID THEN
            RETURN OS_STATUS_ACCESS_DENIED
        END
    END

    // Set the paged part.

    paged := CAST ObFindPagedPart ( process ) TO ^PsPagedProcess

    process^.Paged = paged
    paged^.Process = process

    quotablock := PsQuotaBlock ( currentprocess )

    IF flags & (OS_PROCESS_NEW_SESSION | OS_PROCESS_DETACH_QUOTA) ==
        (OS_PROCESS_NEW_SESSION | OS_PROCESS_DETACH_QUOTA) THEN

        // Assign a new quota block.

        quotablock = MmLookupQuotaBlock (
            ctx^.QuotaUid, // uid
            quotablock, // copyquotablock
        )

        IF NOT quotablock THEN
            RETURN OS_STATUS_NO_MEMORY
        END

    ELSE
        // Inherit the current process's quota block.

        MmReferenceQuotaBlock ( quotablock )
    END

    // Initialize the process for usage by Ke.

#IF ( STRCMP ARCHITECTURE "xr17032" )
    // Allocate an AsidTable.

    process^.Pcb.AsidTable = MmAllocatePool (
        MM_NONPAGED_POOL, // poolindex
        SIZEOF KiAsidInfoEntry * KeLoaderBlock.ProcessorCount, // bytes
        'Asid', // tag
        TRUE, // wait
    )

    IF NOT process^.Pcb.AsidTable THEN
        status = OS_STATUS_NO_MEMORY

        GOTO Error2
    END
#END

    KeInitializeProcess (
        &process^.Pcb, // process
        ctx^.Name, // name
    )

    // Initialize the process for usage by Ob.
    // This also sets the quotablock for the process.

    ObInitializeProcess (
        currentprocess, // parentprocess
        process, // process
        quotablock, // quotablock
    )

    // Initialize the process for usage by Ns.

    NsInitializeProcess (
        process, // process
        currentprocess, // parentprocess
    )

    // Initialize the process for usage by Mm.

    status = MmInitializeProcess (
        process, // process
        ctx^.Partition, // partition
    )

    IF OsError ( status ) THEN
        GOTO Error3
    END

    // Initialize the process for usage by Ps.

    // Intern the name.

    paged^.Name = ExFindName ( ctx^.Name )

    IF NOT paged^.Name THEN
        status = OS_STATUS_NO_MEMORY

        GOTO Error4
    END

    // Initialize the termination event.

    KeInitializeEvent (
        &process^.TerminationEvent, // event
        "Termination", // name
        TRUE, // notification
        FALSE, // signalstate
    )

    // Stash the parent PID into the child. This is just a hint, nothing
    // maintains this or relies on it to be completely accurate.

    paged^.ParentPid = currentprocess^.Paged^.Pid

    // Set not cleaned up yet.

    paged^.CleanedUp = FALSE

    // Create the activation event.

    paged^.ActivationEvent = ExAllocateEventCounter ( TRUE )

    IF NOT paged^.ActivationEvent THEN
        status = OS_STATUS_NO_MEMORY

        GOTO Error5
    END

    KeInitializeLock ( &paged^.ActivationLock )

    paged^.ActivationStatus = 0
    paged^.TerminationStatus = 0

    paged^.Job = NULLPTR
    paged^.ProcessGroup = NULLPTR

    IF flags & OS_PROCESS_DETACH_JOB == 0 THEN
        // Inherit the parent process's job object.
        // This is also the point where we'll notice that a job has been terminated
        // and that this process creation should not be allowed to proceed.

        status = PspInheritJob (
            process, // child
            currentprocess, // parent
        )

        IF OsError ( status ) THEN
            GOTO Error6
        END
    END

    IF flags & OS_PROCESS_DETACH_CONSOLE == 0 THEN
        // Inherit the parent process's console group.

        PspInheritProcessGroup (
            process, // child
            currentprocess, // parent
        )
    END

    // Put on the global process list.

    KeAcquireLockExclusive ( &PspProcessListLock )

    RtlInsertAtTailList (
        &PspProcessListHead, // head
        &paged^.GlobalEntry, // entry
    )

    KeReleaseLock ( &PspProcessListLock )

    // Give the process a PID. Do this last so that users can't look up an
    // incomplete process.

    status = PspCreateId (
        process, // object
        OUT paged^.Pid, // id
    )

    IF OsError ( status ) THEN
        GOTO Error7
    END

    RETURN OS_STATUS_SUCCESS

@Error7

    KeAcquireLockExclusive ( &PspProcessListLock )

    RtlRemoveEntryList ( &paged^.GlobalEntry )

    KeReleaseLock ( &PspProcessListLock )

    IF paged^.ProcessGroup THEN
        PspRemoveProcessGroup ( process )
    END

    IF paged^.Job THEN
        PspExitJobProcess ( process )
    END

@Error6

    ExUnreferenceEventCounter ( paged^.ActivationEvent )

@Error5

    ExUnreferenceName ( paged^.Name )

@Error4

    MmUninitializeProcess ( process )

    MmDeleteProcess ( process )

@Error3

    NsUninitializeProcess ( process )

    ObUninitializeProcess ( process )

#IF ( STRCMP ARCHITECTURE "xr17032" )
    MmFreePool (
        process^.Pcb.AsidTable, // ptr
        'Asid', // tag
    )
#END

@Error2

    MmUnreferenceQuotaBlock ( quotablock )

    RETURN status
END

#SECTION "PAGEtext"
PUBLIC PsProcessType : ObType = {
    [Name] = "Process",

    [Delete] = &PspDeleteProcessObject,

    [Initialize] = &PspInitializeProcessObject,

    [WaitOffset] = OFFSETOF PsProcess.TerminationEvent,
    [TypeIdentifier] = OS_PROCESS_TYPE,
    [Tag] = 'Proc',

    [IsPaged] = FALSE,
}

#SECTION "PAGEtext"
FN PsCreateProcessObject (
    IN params : ^NsOpenParameters,
    IN partition : ^MiPartition,
    IN name : ^UBYTE,
    IN quotauid : UWORD,
    IN flags : UWORD,
    OUT process : ^PsProcess,
) : OsStatus

    // Create a process object.

    ctx : PspProcessContext

    ctx.Name = name
    ctx.QuotaUid = quotauid
    ctx.Flags = flags
    ctx.Partition = partition

    obparams : ObParameters

    obparams.Type = &PsProcessType
    obparams.BodySize = SIZEOF PsProcess
    obparams.PagedBodySize = SIZEOF PsPagedProcess
    obparams.NpQuotaBias = 0
    obparams.PgQuotaBias = MmGetOverheadOfBytes ( SIZEOF PsPagedProcess )

    obparams.Context = &ctx

    RETURN NsCreateObject (
        params, // params
        &obparams, // obparams
        OUT process, // object
    )
END