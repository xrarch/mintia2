//
// Implements executive-level process objects.
//

#INCLUDE "Psp.hjk"
#INCLUDE "<ll>/System/OsQuota.hjk"

STRUCT PspProcessContext
    Name : ^RtlString,
    Partition : ^MmpPartition,
    QuotaUid : ULONG,
    Flags : ULONG,
END

// FORWARD
EXTERN FN PspExitProcess (
    IN process : ^PsuProcess,
)

#SECTION "PAGEtext"
FN PsuBlockRundownProcess (
    IN process : ^PsuProcess,
) : UWORD

    // Prevent the rundown (clean-up) of the process until the next
    // PsuUnblockRundownProcess. If it is already being run down, tell the
    // caller.

    IF process^.Pcb.ThreadCount == 0 THEN
        // If the process has no threads, we shouldn't allow anybody else to be
        // able to defer rundown, so just reject this request. This just makes
        // sure that the time between process termination and rundown is finite
        // and spamming system calls that block rundown can't extend the time
        // indefinitely. There's no functional reason to have this check other
        // than that, so there's no need to hold a lock or perform a memory
        // barrier.
        //
        // It also serves another purpose which is to prevent certain things
        // from being done to a process object that *does not yet* have a
        // thread, such as memory mapping. This makes sure we can reliably empty
        // out a process's address space (and release lots of resources) by
        // terminating it; if it has such resources, it will have at least one
        // thread who can release them promptly on its way out, even if many
        // references exist to the process object itself.

        RETURN FALSE
    END

    paged := process^.Paged

    oldcount := paged^.RundownDefermentCount

    WHILE TRUE DO
        IF oldcount == 0 THEN
            // Already being run down.

            RETURN FALSE
        END

        new := KeCompareSwapPtr (
            &paged^.RundownDefermentCount, // ptr
            oldcount + 1, // newvalue
            oldcount, // expectedvalue
        )

        IF new == oldcount THEN
            // Got it. The previous count was nonzero so we know the process was
            // not being run down.

            RETURN TRUE
        END

        oldcount = new
    END
END

#SECTION "PAGEtext"
FN PsuUnblockRundownProcess (
    IN process : ^PsuProcess,
)

    // Decrement the rundown deferment count and perform process rundown if it
    // reaches zero.

    oldcount := KeIncrementUlong (
        &process^.Paged^.RundownDefermentCount, // ulong
        0xFFFFFFFF, // inc
    )

    IF oldcount == 1 THEN
        // Rundown is no longer deferred, do it now.

        PspExitProcess ( process )
    END
END

#SECTION "PAGEtext"
FN PspSignalActivation (
    IN process : ^PsuProcess,
    IN status : OsStatus,
)

    // Signal the activation of the process.

    paged := process^.Paged

    KeAcquireLockExclusive ( &paged^.ActivationLock )

    event := paged^.ActivationEvent

    IF NOT event THEN
        // Already activated.

        KeReleaseLock ( &paged^.ActivationLock )

        LEAVE
    END

    paged^.ActivationStatus = status

    paged^.ActivationEvent = NULLPTR

    KeReleaseLock ( &paged^.ActivationLock )

    // Wake anyone awaiting activation of this process.

    KeSignalEvent (
        &event^.Event, // event
        0, // priorityboost
    )

    // Decrement the reference count on the event counter.

    ExUnreferenceEventCounter ( event )
END

#SECTION "PAGEtext"
FN PspAwaitActivation (
    IN process : ^PsuProcess,
    IN timeout : ^RtlUquad,
    IN alertable : UWORD,
    OUT activationstatus : OsStatus,
) : OsStatus

    // Wait for the activation of the process.

    paged := process^.Paged

    KeAcquireLockExclusive ( &paged^.ActivationLock )

    event := paged^.ActivationEvent

    IF NOT event THEN
        // Already activated.

        KeReleaseLock ( &paged^.ActivationLock )

        activationstatus = paged^.ActivationStatus

        RETURN OS_STATUS_SUCCESS
    END

    ExReferenceEventCounter ( event )

    KeReleaseLock ( &paged^.ActivationLock )

    // Wait on the event counter.

    status := KeuWaitForSingleObject (
        KE_USER_MODE, // waitmode
        KE_ALERTABLE, // alertable
        timeout, // timeout
        &event^.Event.Header, // object
    )

    ExUnreferenceEventCounter ( event )

    activationstatus = paged^.ActivationStatus

    IF status == 0 THEN
        status = OS_STATUS_SUCCESS
    END

    RETURN status
END

#SECTION "PAGEtext"
FN PspExitProcess (
    IN process : ^PsuProcess,
)

    // The process has exited and exit-time teardown must be performed. This can
    // occur in two situations:
    //
    //  1. The process's final thread has terminated, and called this routine.
    //  2. The process never had any threads, and the object is being deleted.
    //
    // We distinguish between exit-time and deletion-time teardown for the
    // process object so that it's more difficult for a malicious or buggy
    // program to hog system resources by keeping a long-lived handle to a
    // process that has terminated. The second thing we do is to forbid certain
    // operations (like memory mapping) from being performed until the first
    // thread for a process has been created. That way there's always someone
    // obvious to terminate, who will make their way through this codepath here,
    // and relinquish all of the resources associated with the process.

    paged := process^.Paged

    IF paged^.Job THEN
        // Indicate termination to job.

        PspExitJobProcess ( process )
    END

    // Uninitialize the process with respect to Ob.

    ObuUninitializeProcess ( process )

    // Uninitialize the process's virtual memory structures.

    MmuUninitializeProcess ( process )

    // If activation hasn't been signaled, do so now in order to get rid of the
    // activation event counter.

    IF paged^.ActivationEvent THEN
        PspSignalActivation (
            process, // process
            paged^.TerminationStatus, // status
        )
    END

    // Signal the termination event.

    KeSignalEvent (
        &process^.TerminationEvent, // event
        0, // priorityboost
    )
END

#SECTION "PAGEtext"
FN (ObuTypeDeleteF) PspDeleteProcessObject (
    IN object : ^VOID,
) : UWORD

    // Delete a process object.

    process := CAST object TO ^PsuProcess

    paged := process^.Paged

    IF paged^.RundownDefermentCount != 0 THEN
        KeAssert ( paged^.RundownDefermentCount == 1 )

        // Clean up the process.
        // It never reached a terminated state, so its initial rundown deferment
        // count of 1 wasn't removed. This can happen if the process object is
        // deleted before any threads are ever added to it.

        PspExitProcess ( process )
    END

    // Remove from the global process list.

    KeAcquireLockExclusive ( &PspProcessListLock )

    RtlRemoveEntryList ( &paged^.GlobalEntry )

    PsuActiveProcessCount -= 1

    KeReleaseLock ( &PspProcessListLock )

    // Delete the PID.

    group := paged^.ProcessGroup

    IF group AND group^.LeaderPid == paged^.Pid THEN
        // We were the process group leader, so we need to exchange the PID
        // table entry with a pointer to the process group, to reserve it
        // until the last process group member has died. A process group ID not
        // being reused as a PID until all members are gone is a requirement of
        // POSIX.

        group^.LeaderDied = TRUE

        PspExchangeId (
            paged^.Pid, // id
            group, // object
        )

    ELSE
        PspDeleteId ( paged^.Pid )
    END

    IF group THEN
        PspRemoveProcessGroup ( process )
    END

    // Uninitialize the root and current directory of the process.

    NsuUninitializeProcess ( process )

    // Perform deletion of the page directory, etc.

    MmuDeleteProcess ( process )

    // Unreference the name.

    ExUnreferenceName ( paged^.Name )

    // Unreference the quota block.

    MmuUnreferenceQuotaBlock ( paged^.HandleTable.QuotaBlock )

    RETURN TRUE
END

#SECTION "PAGEtext"
FN (ObuTypeInitializeF) PspInitializeProcessObject (
    IN object : ^VOID,
    IN context : ^VOID,
) : OsStatus

    process := CAST object TO ^PsuProcess
    ctx := CAST context TO ^PspProcessContext

    status : OsStatus

    // Initialize the process object.

    currentprocess := PsuCurrentProcess ()

    flags := ctx^.Flags

    IF flags & OS_PROCESS_DETACH_JOB AND
        NOT PsuCheckPrivilege ( currentprocess, OS_PRIVILEGE_DETACH_JOB ) THEN

        RETURN OS_STATUS_PRIVILEGE_NOT_HELD
    END

    IF flags & OS_PROCESS_NEW_SESSION AND
        NOT PsuCheckPrivilege ( currentprocess, OS_PRIVILEGE_NEW_SESSION ) THEN

        RETURN OS_STATUS_PRIVILEGE_NOT_HELD
    END

    // Set the paged part.

    paged := CAST ObuFindPagedPart ( process ) TO ^PsuPagedProcess

    process^.Paged = paged
    paged^.Process = process

    quotablock : ^MmpQuotaBlock = NULLPTR

    IF flags & (OS_PROCESS_NEW_SESSION | OS_PROCESS_DETACH_QUOTA) ==
        (OS_PROCESS_NEW_SESSION | OS_PROCESS_DETACH_QUOTA) THEN

        // Assign a new quota block.

        quotablock = MmuLookupQuotaBlock (
            ctx^.QuotaUid, // uid
            quotablock, // copyquotablock
        )

        IF NOT quotablock THEN
            RETURN OS_STATUS_NO_MEMORY
        END

    ELSE
        // Inherit the current process's quota block.

        quotablock = PsuQuotaBlock ( currentprocess )

        MmuReferenceQuotaBlock ( quotablock )
    END

    // Initialize the process for usage by Ke.

#IF ( STRCMP ARCHITECTURE "xr17032" )
    // Enough space for the AsidTable was allocated at the end of the nonpaged
    // part of the process object.

    process^.Pcb.AsidTable =
        CAST (process + SIZEOF PsuProcess) TO ^KepAsidInfoEntry
#END

    KeuInitializeProcess (
        &process^.Pcb, // process
        ctx^.Name^.Data, // name
    )

    // Initialize the process for usage by Ob.
    // This also sets the quotablock for the process.

    ObuInitializeProcess (
        currentprocess, // parentprocess
        process, // process
        quotablock, // quotablock
    )

    // Initialize the process for usage by Ns.

    NsuInitializeProcess (
        process, // process
        currentprocess, // parentprocess
    )

    // Initialize the process for usage by Mm.

    status = MmuInitializeProcess (
        currentprocess, // parentprocess
        process, // process
        ctx^.Partition, // partition
    )

    IF OsError ( status ) THEN
        GOTO Error3
    END

    // Initialize the process for usage by Ps.

    // Initialize the privilege lock.

    KeInitializeLock ( &process^.Paged^.PrivilegeLock )

    // Inherit the granted privileges from the parent process.

    RtlCopyBytes (
        &process^.Paged^.GrantedPrivileges[0], // dest
        &currentprocess^.Paged^.GrantedPrivileges[0], // src
        SIZEOFVALUE process^.Paged^.GrantedPrivileges, // sz
    )

    // Zero out the enabled privileges.

    RtlFillMemoryWithUlong (
        &process^.Paged^.EnabledPrivileges[0], // ptr
        SIZEOFVALUE process^.Paged^.EnabledPrivileges, // sz
        0, // ulong
    )

    // Initialize the group lock.

    KeInitializeLock ( &paged^.GroupLock )

    // Intern the name.

    paged^.Name = ExFindName ( ctx^.Name )

    IF NOT paged^.Name THEN
        status = OS_STATUS_NO_MEMORY

        GOTO Error4
    END

    // Initialize the termination event.

    KeInitializeEvent (
        &process^.TerminationEvent, // event
        "Termination", // name
        TRUE, // notification
        FALSE, // signalstate
    )

    // Stash the parent PID into the child. This is just a hint, nothing
    // maintains this or relies on it to be completely accurate.

    paged^.ParentPid = currentprocess^.Paged^.Pid

    // Set rundown deferment count to 1. This will be decremented when the
    // process enters a terminated state after its last thread exits, which
    // will cause immediate rundown of hefty resources like memory mappings.

    paged^.RundownDefermentCount = 1

    // Create the activation event.

    paged^.ActivationEvent = ExAllocateEventCounter ( TRUE )

    IF NOT paged^.ActivationEvent THEN
        status = OS_STATUS_NO_MEMORY

        GOTO Error5
    END

    KeInitializeLock ( &paged^.ActivationLock )

    paged^.ActivationStatus = 0
    paged^.TerminationStatus = OS_STATUS_SUCCESS

    paged^.Job = NULLPTR

    IF flags & OS_PROCESS_DETACH_JOB == 0 THEN
        // Inherit the parent process's job object.
        // This is also the point where we'll notice that a job has been terminated
        // and that this process creation should not be allowed to proceed.

        status = PspInheritJob (
            process, // child
            currentprocess, // parent
        )

        IF OsError ( status ) THEN
            GOTO Error6
        END
    END

    // Inherit the parent process's group and session.

    PspInheritProcessGroup (
        process, // child
        currentprocess, // parent
    )

    // Put on the global process list.

    KeAcquireLockExclusive ( &PspProcessListLock )

    RtlInsertAtTailList (
        &PspProcessListHead, // head
        &paged^.GlobalEntry, // entry
    )

    PsuActiveProcessCount += 1

    KeReleaseLock ( &PspProcessListLock )

    // Give the process a PID. Do this last so that users can't look up an
    // incomplete process.

    status = PspCreateId (
        process, // object
        OUT paged^.Pid, // id
    )

    IF OsError ( status ) THEN
        GOTO Error7
    END

    RETURN OS_STATUS_SUCCESS

@Error7

    KeAcquireLockExclusive ( &PspProcessListLock )

    RtlRemoveEntryList ( &paged^.GlobalEntry )

    PsuActiveProcessCount -= 1

    KeReleaseLock ( &PspProcessListLock )

    IF paged^.ProcessGroup THEN
        PspRemoveProcessGroup ( process )
    END

    IF paged^.Job THEN
        PspExitJobProcess ( process )
    END

@Error6

    ExUnreferenceEventCounter ( paged^.ActivationEvent )

@Error5

    ExUnreferenceName ( paged^.Name )

@Error4

    MmuUninitializeProcess ( process )

    MmuDeleteProcess ( process )

@Error3

    NsuUninitializeProcess ( process )

    ObuUninitializeProcess ( process )

    MmuUnreferenceQuotaBlock ( quotablock )

    RETURN status
END

#SECTION "PAGEtext"
FN PsuEnablePrivilegeProcessObject (
    IN process : ^PsuProcess,
    IN privilege : UWORD,
) : OsStatus

    // Attempt to enable the privilege for the provided process.

    paged := process^.Paged

    status := OS_STATUS_SUCCESS

    // Acquire the privilege lock.

    KeAcquireLockExclusive ( &paged^.PrivilegeLock )

    IF paged^.GrantedPrivileges[privilege / 8] &
        (1 << (privilege & 7)) == 0 THEN

        // The privilege isn't granted.

        status = OS_STATUS_PRIVILEGE_NOT_GRANTED

        GOTO Exit
    END

    // Set the enabled bit.

    paged^.EnabledPrivileges[privilege / 8] |= (1 << (privilege & 7))

@Exit

    KeReleaseLock ( &paged^.PrivilegeLock )

    RETURN status
END

#SECTION "PAGEtext"
FN OsEnablePrivilegeProcess (
    IN processhandle : UWORD,
    IN privilege : UWORD,
) : OsStatus

    // Enable a privilege in the specified process, system service.

    IF privilege >= OS_PRIVILEGE_MAX THEN
        RETURN OS_STATUS_INVALID_ARGUMENT
    END

    process : ^PsuProcess
    access : UWORD

    status := ObuReferenceByHandle (
        processhandle, // handle
        &PsuProcessType, // type
        OUT process, // object
        OUT access, // access
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    IF access | OS_ACCESS_WRITE != access THEN
        status = OS_STATUS_ACCESS_DENIED

        GOTO Exit
    END

    status = PsuEnablePrivilegeProcessObject (
        process, // process
        privilege, // privilege
    )

@Exit

    ObUnreferenceObject ( process )

    RETURN status
END

#SECTION "PAGEtext"
FN PsuDisablePrivilegeProcessObject (
    IN process : ^PsuProcess,
    IN privilege : UWORD,
) : OsStatus

    // Disable the privilege for the provided process.

    paged := process^.Paged

    status := OS_STATUS_SUCCESS

    // Acquire the privilege lock.

    KeAcquireLockExclusive ( &paged^.PrivilegeLock )

    IF paged^.EnabledPrivileges[privilege / 8] &
        (1 << (privilege & 7)) == 0 THEN

        // The privilege isn't enabled.
        // Strictly speaking we don't really need to check this but it
        // maximizes usefulness if we tell the caller whether we really disabled
        // it or not.

        status = OS_STATUS_PRIVILEGE_NOT_HELD

        GOTO Exit
    END

    // Clear the enabled bit.

    paged^.EnabledPrivileges[privilege / 8] &= ~(1 << (privilege & 7))

@Exit

    KeReleaseLock ( &paged^.PrivilegeLock )

    RETURN status
END


#SECTION "PAGEtext"
FN OsDisablePrivilegeProcess (
    IN processhandle : UWORD,
    IN privilege : UWORD,
) : OsStatus

    // Disable a privilege in the specified process, system service.

    IF privilege >= OS_PRIVILEGE_MAX THEN
        RETURN OS_STATUS_INVALID_ARGUMENT
    END

    process : ^PsuProcess
    access : UWORD

    status := ObuReferenceByHandle (
        processhandle, // handle
        &PsuProcessType, // type
        OUT process, // object
        OUT access, // access
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    IF access | OS_ACCESS_WRITE != access THEN
        status = OS_STATUS_ACCESS_DENIED

        GOTO Exit
    END

    status = PsuDisablePrivilegeProcessObject (
        process, // process
        privilege, // privilege
    )

@Exit

    ObUnreferenceObject ( process )

    RETURN status
END

#SECTION "PAGEtext"
FN PsuGrantPrivilegeProcessObject (
    IN process : ^PsuProcess,
    IN privilege : UWORD,
) : OsStatus

    // Grant a privilege to the specified process.

    currentprocess := PsuCurrentProcess ()

    // We can only grant this privilege if we either already have it or are an
    // admin.

    IF NOT PsuCheckPrivilege ( currentprocess, privilege ) AND
        NOT PsuCheckPrivilege ( currentprocess, OS_PRIVILEGE_ADMIN ) THEN

        RETURN OS_STATUS_PRIVILEGE_NOT_HELD
    END

    // Set the granted bit under the privilege lock.

    paged := process^.Paged

    KeAcquireLockExclusive ( &paged^.PrivilegeLock )

    paged^.GrantedPrivileges[privilege / 8] |= (1 << (privilege & 7))

    KeReleaseLock ( &paged^.PrivilegeLock )

    RETURN OS_STATUS_SUCCESS
END


#SECTION "PAGEtext"
FN OsGrantPrivilegeProcess (
    IN processhandle : UWORD,
    IN privilege : UWORD,
) : OsStatus

    // Grant a privilege to the specified process, system service.

    IF privilege >= OS_PRIVILEGE_MAX THEN
        RETURN OS_STATUS_INVALID_ARGUMENT
    END

    process : ^PsuProcess
    access : UWORD

    status := ObuReferenceByHandle (
        processhandle, // handle
        &PsuProcessType, // type
        OUT process, // object
        OUT access, // access
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    IF access | OS_ACCESS_WRITE != access THEN
        status = OS_STATUS_ACCESS_DENIED

        GOTO Exit
    END

    status = PsuGrantPrivilegeProcessObject (
        process, // process
        privilege, // privilege
    )

@Exit

    ObUnreferenceObject ( process )

    RETURN status
END

#SECTION "PAGEtext"
FN PsuRevokePrivilegeProcessObject (
    IN process : ^PsuProcess,
    IN privilege : UWORD,
) : OsStatus

    // Revoke a privilege from the specified process.

    // Clear the granted and enable bits under the privilege lock.

    paged := process^.Paged

    KeAcquireLockExclusive ( &paged^.PrivilegeLock )

    paged^.GrantedPrivileges[privilege / 8] &= ~(1 << (privilege & 7))
    paged^.EnabledPrivileges[privilege / 8] &= ~(1 << (privilege & 7))

    KeReleaseLock ( &paged^.PrivilegeLock )

    RETURN OS_STATUS_SUCCESS
END

#SECTION "PAGEtext"
FN OsRevokePrivilegeProcess (
    IN processhandle : UWORD,
    IN privilege : UWORD,
) : OsStatus

    // Revoke a privilege from the specified process, system service.

    IF privilege >= OS_PRIVILEGE_MAX THEN
        RETURN OS_STATUS_INVALID_ARGUMENT
    END

    process : ^PsuProcess
    access : UWORD

    status := ObuReferenceByHandle (
        processhandle, // handle
        &PsuProcessType, // type
        OUT process, // object
        OUT access, // access
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    IF access | OS_ACCESS_WRITE != access THEN
        status = OS_STATUS_ACCESS_DENIED

        GOTO Exit
    END

    status = PsuRevokePrivilegeProcessObject (
        process, // process
        privilege, // privilege
    )

@Exit

    ObUnreferenceObject ( process )

    RETURN status
END

#SECTION "PAGEtext"
FN OsSignalProcess (
    IN handle : UWORD,
    IN signal : UWORD,
) : OsStatus

    // Signal a process, system service.

    IF KeuInvalidSignal ( signal ) THEN
        RETURN OS_STATUS_INVALID_ARGUMENT
    END

    process : ^PsuProcess
    access : UWORD

    status := ObuReferenceByHandle (
        handle, // handle
        &PsuProcessType, // type
        OUT process, // object
        OUT access, // access
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    IF access | OS_ACCESS_EXEC != access THEN
        status = OS_STATUS_ACCESS_DENIED

        GOTO Exit
    END

    KeSignalProcess (
        &process^.Pcb, // process
        signal, // signal
    )

@Exit

    ObUnreferenceObject ( process )

    RETURN status
END

#SECTION "PAGEtext"
FN OsSignalActivationProcess (
    IN status : OsStatus,
)

    // Signal activation for the current process, system service.

    PspSignalActivation (
        PsuCurrentProcess (), // process
        status, // status
    )
END

#SECTION "PAGEtext"
FN OsAwaitActivationProcess (
    IN handle : UWORD,
    IN timeout : ^RtlUquad,
    IN alertable : UWORD,
    OUT activationstatus : OsStatus,
) : OsStatus

    // Await activation for the given process, system service.

    IF KeuInvalidAlertability ( alertable ) THEN
        RETURN OS_STATUS_INVALID_ARGUMENT
    END

    sysinterval : RtlUquad

    status := MmSafeCopyIn (
        &sysinterval, // dest
        timeout, // src
        SIZEOF RtlUquad, // size
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    process : ^PsuProcess
    access : UWORD

    status = ObuReferenceByHandle (
        handle, // handle
        &PsuProcessType, // type
        OUT process, // object
        OUT access, // access
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    status = PspAwaitActivation (
        process, // process
        &sysinterval, // timeout
        alertable, // alertable
        OUT activationstatus, // activationstatus
    )

    ObUnreferenceObject ( process )

    RETURN status
END

PUBLIC PsuProcessType : ObuType = {
    [Name] = "Process",

    [Delete] = &PspDeleteProcessObject,

    [Initialize] = &PspInitializeProcessObject,

    [WaitOffset] = OFFSETOF PsuProcess.TerminationEvent,
    [TypeIdentifier] = OS_PROCESS_TYPE,
    [Tag] = 'Proc',

    [TypicalBodySize] = SIZEOF PsuProcess,
    [TypicalPgBodySize] = SIZEOF PsuPagedProcess,

    [IsPaged] = FALSE,
}

#SECTION "PAGEtext"
FN PsuCreateProcessObject (
    IN params : ^NsOpenParameters,
    IN partition : ^MmpPartition,
    IN name : ^RtlString,
    IN quotauid : UWORD,
    IN flags : UWORD,
    OUT process : ^PsuProcess,
) : OsStatus

    // Create a process object.

    ctx : PspProcessContext

    ctx.Name = name
    ctx.QuotaUid = quotauid
    ctx.Flags = flags
    ctx.Partition = partition

    obparams : ObParameters

    NsInitializeObjectParameters (
        &obparams, // obparams
        params, // params
        &PsuProcessType, // type
        &ctx, // context
        SIZEOF PsuProcess, // bodysize
        SIZEOF PsuPagedProcess, // pagedbodysize
        0, // npquotabias
        0, // pgquotabias
    )

#IF ( STRCMP ARCHITECTURE "xr17032" )
    // Put enough space at the end of the nonpaged part of the process for the
    // ASID table.

    obparams.BodySize += SIZEOF KepAsidInfoEntry * KeQueryProcessorCount ()
#END

    RETURN NsuCreateObject (
        params, // params
        &obparams, // obparams
        OUT process, // object
    )
END

EXTERN MmuPartitionType : ObuType

#SECTION "PAGEtext"
FN PsuCreateProcess (
    IN params : ^NsOpenParameters,
    IN partitionhandle : UWORD,
    IN name : ^RtlString,
    IN quotauid : UWORD,
    IN flags : UWORD,
    OUT handle : UWORD,
) : OsStatus

    // Create a process object - handle interface.

    partition : ^MmpPartition = NULLPTR
    access : UWORD
    status : OsStatus

    IF partitionhandle != OS_NULL_HANDLE THEN
        status = ObuReferenceByHandle (
            partitionhandle, // handle
            &MmuPartitionType, // type
            OUT partition, // object
            OUT access, // access
        )

        IF OsError ( status ) THEN
            RETURN status
        END

        IF access | OS_ACCESS_WRITE != access THEN
            // Not a subset of the required access.

            status = OS_STATUS_ACCESS_DENIED

            GOTO Exit
        END
    END

    process : ^PsuProcess

    status = PsuCreateProcessObject (
        params, // params
        partition, // partition
        name, // name
        quotauid, // quotauid
        flags, // flags
        OUT process, // process
    )

    IF OsError ( status ) THEN
        GOTO Exit
    END

    status = ObuInsertObject (
        PsuCurrentProcess (), // process
        process, // object
        params^.Captured.Access, // access
        OUT handle, // handle
    )

    IF OsError ( status ) THEN
        ObUnreferenceObject ( process )
    END

@Exit

    IF partition THEN
        ObUnreferenceObject ( partition )
    END

    RETURN status
END

#SECTION "PAGEtext"
FN OsCreateProcess (
    IN params : ^OsOpenParameters,
    IN partitionhandle : UWORD,
    IN name : ^RtlString,
    IN quotauid : UWORD,
    IN flags : UWORD,
    OUT handle : UWORD,
) : OsStatus

    // Create a thread object, system service.

    sysname : RtlString

    status := MmCaptureString (
        name, // string
        &sysname, // output
        OS_NAME_MAX, // maxlen
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    sysparams : NsOpenParameters

    status = NsuCaptureOpenParameters (
        params, // userparams
        &sysparams, // sysparams
    )

    IF OsError ( status ) THEN
        GOTO Exit
    END

    status = PsuCreateProcess (
        &sysparams, // params
        partitionhandle, // partitionhandle
        &sysname, // name
        quotauid, // quotauid
        flags, // flags
        OUT handle, // handle
    )

    NsuFreeOpenParameters ( &sysparams )

@Exit

    MmFreeCapturedString ( &sysname )

    RETURN status
END

#SECTION "PAGEtext"
FN OsOpenProcessByPid (
    IN pid : UWORD,
    IN access : UWORD,
    OUT handle : UWORD,
) : OsStatus

    // Open a process object by PID, system service.

    process : ^PsuProcess

    // Get a referenced pointer to the process object.

    status := PspReferenceById (
        pid, // pid
        &PsuProcessType, // type
        OUT process, // object
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    // Check for appropriate access rights to the process.

    IF NOT ObCheckAccessForCurrent (
        process, // object
        access, // access
    ) THEN

        status = OS_STATUS_ACCESS_DENIED

        GOTO Exit
    END

    // Insert the process object into the handle table.

    status = ObuInsertObject (
        PsuCurrentProcess (), // process
        process, // process
        access, // access
        OUT handle, // handle
    )

    IF OsError ( status ) THEN
        GOTO Exit
    END

    RETURN status

@Exit

    ObUnreferenceObject ( process )

    RETURN status
END

#SECTION "PAGEtext"
FN PsuReadStatusProcessObject (
    IN process : ^PsuProcess,
) : OsStatus

    // Read the termination status of a process.

    IF NOT process^.Pcb.Terminated THEN
        RETURN OS_STATUS_PROCESS_IS_ALIVE
    END

    RETURN process^.Paged^.TerminationStatus
END

#SECTION "PAGEtext"
FN OsReadStatusProcess (
    IN handle : UWORD,
) : OsStatus

    // Read the termination status of a process, system service.

    process : ^PsuProcess
    access : UWORD

    status := ObuReferenceByHandle (
        handle, // handle
        &PsuProcessType, // type
        OUT process, // object
        OUT access, // access
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    IF access | OS_ACCESS_READ != access THEN
        status = OS_STATUS_ACCESS_DENIED

        GOTO Exit
    END

    status = PsuReadStatusProcessObject ( process )

@Exit

    ObUnreferenceObject ( process )

    RETURN status
END

#SECTION "PAGEtext"
FN PsuQueryProcessObject (
    IN process : ^PsuProcess,
    IN query : ^OsProcessQuery,
)

    // Query information about a process object.

    RtlFillMemoryWithUlong (
        query, // dest
        SIZEOF OsProcessQuery, // sz
        0, // ulong
    )

    paged := process^.Paged

    query^.Pid = paged^.Pid
    query^.ParentPid = paged^.ParentPid

    query^.OwningUid = paged^.Cred.Uid
    query^.OwningGid = paged^.Cred.Gid

    KeAcquireLockExclusive ( &process^.Pcb.Lock )

    IF process^.Pcb.SignalThread THEN
        query^.Status = process^.Pcb.SignalThread^.Status
        query^.Priority = process^.Pcb.SignalThread^.Priority
    END

    KeReleaseLock ( &process^.Pcb.Lock )

    query^.ThreadCount = process^.Pcb.ThreadCount
    query^.TerminationStatus = paged^.TerminationStatus

    KeAcquireLockExclusive ( &paged^.GroupLock )

    IF paged^.SessionGroup THEN
        query^.Sid = paged^.SessionGroup^.LeaderPid
        query^.Pgid = paged^.ProcessGroup^.LeaderPid
    ELSE
        query^.Sid = 0
        query^.Pgid = 0
    END

    KeReleaseLock ( &paged^.GroupLock )

    MmuQueryProcess (
        process, // process
        query, // query
    )

    RtlCopyString (
        &query^.Name[0], // dest
        ExuNameToString ( paged^.Name )^.Data, // src
        OS_NAME_MAX + 1, // bufsize
    )

    // TODO copy name of controlling tty
END

#SECTION "PAGEtext"
FN PsuQueryProcess (
    IN handle : UWORD,
    IN query : ^OsProcessQuery,
) : OsStatus

    // Query information about a process handle.

    process : ^PsuProcess
    access : UWORD

    status := ObuReferenceByHandle (
        handle, // handle
        &PsuProcessType, // type
        OUT process, // object
        OUT access, // access
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    IF access | OS_ACCESS_READ != access THEN
        status = OS_STATUS_ACCESS_DENIED

        GOTO Exit
    END

    PsuQueryProcessObject (
        process, // process
        query, // query
    )

@Exit

    ObUnreferenceObject ( process )

    RETURN status
END

#SECTION "PAGEtext"
FN OsQueryProcess (
    IN handle : UWORD,
    IN query : ^OsProcessQuery,
) : OsStatus

    // Query information about a process, system service.

    sysquery : OsProcessQuery

    status := PsuQueryProcess (
        handle, // handle
        &sysquery, // query
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    // Copy the information to userspace.

    RETURN MmSafeCopyOut (
        query, // dest
        &sysquery, // src
        SIZEOF OsProcessQuery, // size
    )
END

#SECTION "PAGEtext"
FN PsuQueryProcessByPid (
    IN pid : UWORD,
    IN query : ^OsProcessQuery,
) : OsStatus

    // Open a process object by PID, system service.

    process : ^PsuProcess

    // Get a referenced pointer to the process object.

    status := PspReferenceById (
        pid, // pid
        &PsuProcessType, // type
        OUT process, // object
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    // Check for appropriate access rights to the process.

    IF NOT ObCheckAccessForCurrent (
        process, // object
        OS_ACCESS_READ, // access
    ) THEN

        status = OS_STATUS_ACCESS_DENIED

        GOTO Exit
    END

    // Query the process object.

    PsuQueryProcessObject (
        process, // process
        query, // query
    )

@Exit

    ObUnreferenceObject ( process )

    RETURN status
END

#SECTION "PAGEtext"
FN OsQueryProcessByPid (
    IN pid : UWORD,
    IN query : ^OsProcessQuery,
) : OsStatus

    // Query information about a process by PID, system service.

    sysquery : OsProcessQuery

    status := PsuQueryProcessByPid (
        pid, // pid
        &sysquery, // query
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    // Copy the information to userspace.

    RETURN MmSafeCopyOut (
        query, // dest
        &sysquery, // src
        SIZEOF OsProcessQuery, // size
    )
END

#SECTION "PAGEtext"
FN OsSetBasePriorityProcess (
    IN processhandle : UWORD,
    IN priority : UWORD,
) : OsStatus

    // Set the base priority of a process, system service.

    IF priority >= OS_PRIORITY_MAX THEN
        RETURN OS_STATUS_INVALID_ARGUMENT
    END

    process : ^PsuProcess
    access : UWORD

    status := ObuReferenceByHandle (
        processhandle, // handle
        &PsuProcessType, // type
        OUT process, // object
        OUT access, // access
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    IF access | OS_ACCESS_WRITE != access THEN
        status = OS_STATUS_ACCESS_DENIED

        GOTO Exit
    END

    IF priority >= process^.Pcb.BasePriority THEN
        // Raising base priority requires special privileges.

        currentprocess := PsuCurrentProcess ()

        IF priority >= OS_PRIORITY_LOW_REALTIME THEN
            IF NOT PsuCheckPrivilege ( currentprocess,
                OS_PRIVILEGE_RAISE_PRIORITY_REALTIME ) THEN

                status = OS_STATUS_PRIVILEGE_NOT_HELD

                GOTO Exit
            END

        ELSEIF NOT PsuCheckPrivilege ( currentprocess,
            OS_PRIVILEGE_RAISE_PRIORITY ) THEN

            status = OS_STATUS_PRIVILEGE_NOT_HELD

            GOTO Exit
        END
    END

    KeSetBasePriorityProcess (
        &process^.Pcb, // process
        priority, // priority
    )

@Exit

    ObUnreferenceObject ( process )

    RETURN status
END

#SECTION "PAGEtext"
FN PsuTerminateProcessObject (
    IN process : ^PsuProcess,
    IN status : OsStatus,
)

    // Terminate the provided process.

    IF status != OS_STATUS_SUCCESS THEN
        process^.Paged^.TerminationStatus = status
    END

    KeSignalProcess (
        &process^.Pcb, // process
        OS_SIGNAL_KILL, // signal
    )
END

#SECTION "PAGEtext"
FN OsTerminateProcess (
    IN processhandle : UWORD,
    IN status : OsStatus,
) : OsStatus

    // Terminate a process, system service.

    process : ^PsuProcess
    access : UWORD

    retstatus := ObuReferenceByHandle (
        processhandle, // handle
        &PsuProcessType, // type
        OUT process, // object
        OUT access, // access
    )

    IF OsError ( retstatus ) THEN
        RETURN retstatus
    END

    IF access | OS_ACCESS_EXEC != access THEN
        retstatus = OS_STATUS_ACCESS_DENIED

        GOTO Exit
    END

    PsuTerminateProcessObject (
        process, // process
        status, // status
    )

@Exit

    ObUnreferenceObject ( process )

    RETURN retstatus
END

#SECTION "PAGEtext"
FN OsQueryProcessCount () : UWORD

    // Return the number of processes in the system.

    RETURN PsuActiveProcessCount
END

#SECTION "PAGEtext"
FN OsQueryProcesses (
    IN query : ^OsProcessQuery,
    IN maxcount : UWORD,
) : OsStatus

    // Query all of the processes on the system into an array of query
    // structures.

    // Allocate a buffer in paged pool.
    // We don't copy directly out to the user buffer while holding the process
    // list lock because it could be backed by literally anything, so we can't
    // trust page faults on it, and we don't want any chances of being able to
    // engineer a denial-of-service against process creation (e.g. an
    // intentional network failure causing an excessively long timeout on a page
    // fault on a memory mapped network file while holding the process list
    // lock).

    IF maxcount == 0 THEN
        RETURN OS_STATUS_INVALID_ARGUMENT
    END

    bufsize := maxcount * SIZEOF OsProcessQuery

    IF bufsize / maxcount != SIZEOF OsProcessQuery THEN
        // The buffer size overflowed.

        RETURN OS_STATUS_INVALID_ARGUMENT
    END

    buf : ^VOID

    status := MmAllocateAndChargeSysBuffer (
        bufsize, // bytes
        MM_PAGED_POOL, // poolindex
        'PsQu', // tag
        OUT buf, // ptr
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    sysquery := buf

    KeAcquireLockExclusive ( &PspProcessListLock )

    IF maxcount != PsuActiveProcessCount THEN
        // Caller should re-query the process count and try again.

        status = OS_STATUS_TRY_AGAIN

        GOTO Exit
    END

    // Query all of the processes in the system.

    listhead := &PspProcessListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        process :=
            (CONTAINEROF listentry TO PsuPagedProcess.GlobalEntry)^.Process

        PsuQueryProcessObject (
            process, // process
            sysquery, // query
        )

        sysquery += SIZEOF OsProcessQuery
        listentry = listentry^.Next
    END

@Exit

    KeReleaseLock ( &PspProcessListLock )

    IF NOT OsError ( status ) THEN
        // Copy out to the user buffer outside of the process list lock.

        status = MmSafeCopyOut (
            query, // dest
            buf, // src
            bufsize, // sz
        )
    END

    // Deallocate the system buffer.

    MmDeallocateAndUnchargeSysBuffer (
        buf, // ptr
        'PsQu', // tag
        bufsize, // bytes
        MM_PAGED_POOL, // poolindex
    )

    RETURN status
END

#SECTION "PAGEtext"
FN PsuSetQuotaProcess (
    IN processhandle : UWORD,
    IN quota : ^OsQuotaQuery,
) : OsStatus

    // Set the quota for a process, handle interface.

    process : ^PsuProcess
    access : UWORD

    status := ObuReferenceByHandle (
        processhandle, // handle
        &PsuProcessType, // type
        OUT process, // object
        OUT access, // access
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    IF access | OS_ACCESS_WRITE != access THEN
        status = OS_STATUS_ACCESS_DENIED

        GOTO Exit
    END

    MmuSetQuotaLimits (
        PsuQuotaBlock ( process ), // quotablock
        quota, // quota
    )

@Exit

    ObUnreferenceObject ( process )

    RETURN status
END

#SECTION "PAGEtext"
FN OsSetQuotaProcess (
    IN processhandle : UWORD,
    IN quota : ^OsQuotaQuery,
) : OsStatus

    // Set the quota for a process, system service.

    IF NOT PsuCheckPrivilege ( PsuCurrentProcess (), OS_PRIVILEGE_SET_QUOTA ) THEN
        RETURN OS_STATUS_PRIVILEGE_NOT_HELD
    END

    sysquota : OsQuotaQuery

    // Copy the userspace quota buffer into system space.

    status := MmSafeCopyIn (
        &sysquota, // dest
        quota, // src
        SIZEOF OsQuotaQuery, // sz
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    // Call the handle oriented interface.

    RETURN PsuSetQuotaProcess (
        processhandle, // processhandle
        &sysquota, // quota
    )
END

#SECTION "PAGEtext"
FN PsuQueryQuotaProcess (
    IN processhandle : UWORD,
    IN quota : ^OsQuotaQuery,
) : OsStatus

    // Query the quota for a process, handle interface.

    process : ^PsuProcess
    access : UWORD

    status := ObuReferenceByHandle (
        processhandle, // handle
        &PsuProcessType, // type
        OUT process, // object
        OUT access, // access
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    IF access | OS_ACCESS_READ != access THEN
        status = OS_STATUS_ACCESS_DENIED

        GOTO Exit
    END

    MmuQueryQuota (
        PsuQuotaBlock ( process ), // quotablock
        quota, // query
    )

@Exit

    ObUnreferenceObject ( process )

    RETURN status
END

#SECTION "PAGEtext"
FN OsQueryQuotaProcess (
    IN processhandle : UWORD,
    IN quota : ^OsQuotaQuery,
) : OsStatus

    // Query the quota for a process, system service.

    sysquota : OsQuotaQuery

    status := PsuQueryQuotaProcess (
        processhandle, // processhandle
        &sysquota, // query
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    RETURN MmSafeCopyOut (
        quota, // dest
        &sysquota, // src
        SIZEOF OsQuotaQuery, // sz
    )
END