//
// Implements executive-level thread objects.
//

#INCLUDE "Psp.hjk"

STRUCT PspThreadContext
    Name : ^UBYTE,
    StartFunc : KeStartThreadF,
    Context1 : UWORD,
    Context2 : UWORD,
    Process : ^PsProcess,
    Flags : ULONG,
END

#DEFINE PSP_TURNSTILE_EXTENSION 16

PspTurnstileLock : KeLock = KE_INITIAL_LOCK

PUBLIC PspTurnstileZone : MmZoneHeader

#SECTION "PAGEtext"
FN PspAllocateTurnstile () : ^KiTurnstile

    // Allocate a turnstile from the free list.

    KeAcquireLockExclusive ( &PspTurnstileLock )

    turnstile := CAST MmAllocateZone (
        &PspTurnstileZone, // zone
    ) TO ^KiTurnstile

    IF NOT turnstile THEN
        // Allocate a new hunk of turnstiles.

        turnstile = MmAllocatePool (
            MM_NONPAGED_POOL, // poolindex
            SIZEOF KiTurnstile * PSP_TURNSTILE_EXTENSION +
            MM_ZONE_OVERHEAD, // bytes
            'Turn', // tag
            TRUE, // wait
        )

        IF turnstile THEN
            // Extend the zone starting from the second turnstile in the hunk.
            // We take the first for ourselves.

            MmExtendZone (
                &PspTurnstileZone, // zone
                turnstile + SIZEOF KiTurnstile, // hunk
                SIZEOF KiTurnstile * (PSP_TURNSTILE_EXTENSION - 1) +
                MM_ZONE_OVERHEAD, // bytes
            )
        END
    END

    KeReleaseLock ( &PspTurnstileLock )

    RETURN turnstile
END

#SECTION "PAGEtext"
FN PspFreeTurnstile (
    IN turnstile : ^KiTurnstile,
)

    // Free a turnstile to the free list.

    KeAcquireLockExclusive ( &PspTurnstileLock )

    MmFreeZone (
        &PspTurnstileZone, // zone
        turnstile, // ptr
    )

    KeReleaseLock ( &PspTurnstileLock )
END

#SECTION "PAGEtext"
FN (ObTypeDeleteF) PspDeleteThreadObject (
    IN object : ^VOID,
) : UWORD

    // Delete a thread object.

    thread := CAST object TO ^PsThread

    paged := thread^.Paged

    process := CONTAINEROF thread^.Tcb.Process TO PsProcess.Pcb

    // Delete the TID.

    PspDeleteId ( paged^.Tid )

    // Unreference the interned name.

    ExUnreferenceName ( paged^.Name )

    // Free the turnstile.

    PspFreeTurnstile ( thread^.Tcb.Turnstile )

    // Free the kernel stack.

    MmFreeKernelStack (
        process, // process
        thread^.Tcb.KernelStackTop - (KE_STACK_PAGES << RTL_PAGE_SHIFT), // kstack
    )

    IF paged^.IpcBlock THEN
        // Free the IPC block.

        MmFreePool (
            paged^.IpcBlock, // ptr
            'Ipcb', // tag
        )
    END

    // Unreference the process.

    ObUnreferenceObject ( process )

    RETURN TRUE
END

#SECTION "PAGEtext"
FN PsExitThread ()

    // This thread has reached the end of its life. Usermode will never regain
    // control.

    thread := PsCurrentThread ()

    process := PsCurrentProcess ()

    // Make our priority the lowest real-time priority to expedite the releasing
    // of this thread's resources.

    KeSetPriorityThread (
        &thread^.Tcb, // thread
        OS_PRIORITY_LOW_REALTIME, // priority
    )

    // Ignore events so nothing weird happens while we're cleaning up.

    KeIgnoreEvents ()

    // If there are any asynchronous I/O operations in-flight, try to cancel
    // them and wait for completion.

    IF NOT RtlEmptyList ( &thread^.IopListHead ) THEN
        // It's safe to check this list in this manner because the current
        // thread is the only one who will ever enqueue items to this list,
        // and we ain't doing that right now. Although, I/O completion APCs
        // can asynchronously remove items from it in our context, but that
        // doesn't matter when we're just checking for emptiness.

        IoRundownThread ( thread )
    END

    IF thread^.Paged^.Mode == KE_USER_MODE THEN
        // This was a usermode thread, so uninitialize the userspace structures
        // created previously for it.

        MmUninitializeThread (
            process, // process
            thread, // thread
        )
    END

    // Uninitialize the thread with respect to Ke.

    IF KeUninitializeThread ( &thread^.Tcb ) THEN
        // Ke marked the thread's process terminated. Threads can no longer be
        // created within the process and early exit processing should be
        // performed.

        PspExitProcess (
            process, // process
            thread^.Paged^.TerminationStatus, // status
        )
    END

    // Now exit the thread. This does not return.
    // The thread object will be enqueued to the reaper thread.

    KeExitThread ( &thread^.Tcb )
END

#SECTION "PAGEtext"
FN (KeStartThreadF) PspUserThreadEntry (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

    // Entry point for all usermode threads.

    thread := PsCurrentThread ()

    // Build the TEB.

    // ...

    // Copy the TEB to userspace.

    // ...

    // Enter usermode for the first time, in some architecture-dependent way.

    // ...

    KeCrash ( "NYI PspUserThreadEntry\n" )
END

#SECTION "PAGEtext"
FN (ObTypeInitializeF) PspInitializeThreadObject (
    IN object : ^VOID,
    IN context : ^VOID,
) : OsStatus

    thread := CAST object TO ^PsThread
    ctx := CAST context TO ^PspThreadContext

    status : OsStatus

    // Initialize the thread object.

    flags := ctx^.Flags
    process := ctx^.Process

    paged := CAST ObFindPagedPart ( thread ) TO ^PsPagedThread

    thread^.Paged = paged

    // Intern the name.

    paged^.Name = ExFindName ( ctx^.Name )

    IF NOT paged^.Name THEN
        RETURN OS_STATUS_NO_MEMORY
    END

    // Allocate the kernel stack.

    kstack : ^VOID

    status = MmCreateKernelStack (
        process, // process
        OUT kstack, // kstack
    )

    IF OsError ( status ) THEN
        GOTO Error2
    END

    // Create a TID.
    // Keep the lookup lock held so that the thread can't be looked up until it
    // is fully initialized.

    PspLockLookupShared ()

    status = PspCreateId (
        thread, // object
        OUT paged^.Tid, // id
    )

    IF OsError ( status ) THEN
        GOTO Error3
    END

    paged^.TerminationStatus = 0

    // Allocate a turnstile.

    turnstile := PspAllocateTurnstile ()

    IF NOT turnstile THEN
        status = OS_STATUS_NO_MEMORY

        GOTO Error4
    END

    IF ctx^.StartFunc == &PspUserThreadEntry THEN
        // This is a user thread, so it should get userspace virtual memory
        // structures.

        status = MmInitializeThread (
            process, // process
            thread, // thread
        )

        IF OsError ( status ) THEN
            GOTO Error5
        END

        paged^.Mode = KE_USER_MODE

    ELSE
        paged^.Mode = KE_KERNEL_MODE
    END

    // Initialize the thread for usage by Io.

    RtlInitializeList ( &thread^.IopListHead )

    RtlInitializeList ( &thread^.DeferredIopListHead )

    // Initialize for usage by Ipc.

    paged^.IpcBlock = NULLPTR

    // Initialize the thread for usage by Ke.
    // The thread should be initialized enough that its visibility to the
    // process via the thread list is safe, since it's added to that by Ke here.

    // Attach to the process to ensure it is resident.

    KeAttachProcess (
        &process^.Pcb, // process
        FALSE, // try
    )

    IF NOT KeInitializeThread (
        &process^.Pcb, // process
        &thread^.Tcb, // thread
        ctx^.Name, // name
        kstack, // kstack
        KE_STACK_PAGES << RTL_PAGE_SHIFT, // kstacksize
        turnstile, // turnstile
        ctx^.StartFunc, // startfunc
        ctx^.Context1, // context1
        ctx^.Context2, // context2
    ) THEN
        // The process was terminated already.

        KeDetachProcess ( &process^.Pcb )

        status = OS_STATUS_WAS_TERMINATED

        GOTO Error6
    END

    KeDetachProcess ( &process^.Pcb )

    // Inherit the signal mask from the current thread.

    thread^.Tcb.SignalAcceptMask = PsCurrentThread()^.Tcb.SignalAcceptMask

    // Bias the reference count of the thread object.
    // This reflects an active execution context existing, which means its
    // kernel stack and other resources should remain in existence. This bias is
    // removed by the reaper thread after the thread terminates.

    ObReferenceObject ( thread )

    // Bias the reference count of the process object.
    // This reflects an active thread existing within it. This bias is removed
    // when the thread object is deleted.

    ObReferenceObject ( process )

    // Unlock lookup to allow the thread to be looked up by TID.

    PspUnlockLookup ()

    IF flags & OS_THREAD_SUSPENDED THEN
        // Suspend the thread. It will block on the suspension event upon return
        // to usermode.

        KeSuspendThread ( &thread^.Tcb )
    END

    // Set the thread a-runnin'.

    KeReadyThread ( &thread^.Tcb )

    RETURN OS_STATUS_SUCCESS

@Error6

    IF paged^.Mode == KE_USER_MODE THEN
        MmUninitializeThread (
            process, // process
            thread, // thread
        )
    END

@Error5

    PspFreeTurnstile ( turnstile )

@Error4

    PspDeleteId ( paged^.Tid )

@Error3

    PspUnlockLookup ()

    MmFreeKernelStack (
        process, // process
        kstack, // kstack
    )

@Error2

    ExUnreferenceName ( paged^.Name )

    RETURN status
END

#SECTION "PAGEtext"
PUBLIC PsThreadType : ObType = {
    [Name] = "Thread",

    [Delete] = &PspDeleteThreadObject,

    [Initialize] = &PspInitializeThreadObject,

    [WaitOffset] = OFFSETOF PsThread.Tcb.TerminationEvent,
    [TypeIdentifier] = OS_THREAD_TYPE,
    [Tag] = 'Thrd',

    [IsPaged] = FALSE,
}

#SECTION "PAGEtext"
FN PsCreateThreadObject (
    IN params : ^NsOpenParameters,
    IN name : ^UBYTE,
    IN startfunc : KeStartThreadF,
    IN context1 : UWORD,
    IN context2 : UWORD,
    IN process : ^PsProcess,
    IN flags : UWORD,
    OUT thread : ^PsThread,
) : OsStatus

    // Create a thread object.

    ctx : PspThreadContext

    ctx.Name = name
    ctx.StartFunc = startfunc
    ctx.Context1 = context1
    ctx.Context2 = context2
    ctx.Process = process
    ctx.Flags = flags

    obparams : ObParameters

    obparams.Type = &PsThreadType
    obparams.BodySize = SIZEOF PsThread
    obparams.PagedBodySize = SIZEOF PsPagedThread
    obparams.NpQuotaBias = 0
    obparams.PgQuotaBias = MmGetOverheadOfBytes ( SIZEOF PsPagedThread )

    obparams.Context = &ctx

    RETURN NsCreateObject (
        params, // params
        &obparams, // obparams
        OUT thread, // object
    )
END

FN (KeStartThreadF) PspReaperThread (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

    // Implements the thread reaper.

    KeSetBasePriorityThread (
        KeCurrentThread (), // thread
        OS_PRIORITY_HIGH_REALTIME, // priority
        TRUE, // setcurrentpriority
    )

    WHILE TRUE DO
        // Wait for a thread to reap.

        KeWaitForSingleObject (
            KE_KERNEL_MODE, // waitmode
            KE_UNALERTABLE, // alertable
            NULLPTR, // timeout
            &KeReaperEvent.Header, // object
        )

        WHILE TRUE DO
            thread := KePopReaperList ()

            IF NOT thread THEN
                // No more threads to reap.

                BREAK
            END

            psthrd := CONTAINEROF thread TO PsThread.Tcb

            // Unreference the thread object.

            ObUnreferenceObject ( psthrd )
        END
    END
END