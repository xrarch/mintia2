//
// Initialization for the Process Manager for the MINTIA Executive.
//

#INCLUDE "Psp.hjk"

#INCLUDE "<ll>/System/OsObject.hjk"

PUBLIC PspProcessListLock : KeLock = KE_INITIAL_LOCK
PUBLIC PspProcessListHead : RtlListEntry

PUBLIC PsuActiveProcessCount : UWORD = 0

PUBLIC PsuSystemProcess : ^PsuProcess
PUBLIC PsuInitialThread : ^PsuThread

PUBLIC PspReaperTimedWorkItem : ExuTimedWorkItem

PspIdleProcessPaged : PsuPagedProcess

PspIdTable : ExuHandleTable
PspIdLock : KeLock = KE_INITIAL_LOCK

#DEFINE PSP_ID_INDEXU_SHIFT 10
#DEFINE PSP_ID_SEQUENCE_MASK [((1 << PSP_ID_INDEXU_SHIFT) - 1)]

STRUCT PspIdEntry
    Object : ^VOID,
    Sequence : UWORD,
END

#MACRO PspLockIdExclusive () [
    KeAcquireLockExclusive ( &PspIdLock )
]

#MACRO PspLockIdShared () [
    KeAcquireLockShared ( &PspIdLock )
]

#MACRO PspUnlockId () [
    KeReleaseLock ( &PspIdLock )
]

#SECTION "PAGEtext"
FN PspCreateId (
    IN object : ^VOID,
    OUT id : UWORD,
) : OsStatus

    // Insert an object into the PID/TID table. Should be fully initialized in
    // all relevant ways or people will be able to get a pointer to a bad
    // object.

    entry : ^PspIdEntry

    PspLockIdExclusive ()

    status := ExuCreateHandle (
        &PspIdTable, // handletable
        &PspIdLock, // lock
        OUT id, // handle
        OUT entry, // entryptr
    )

    IF OsError ( status ) THEN
        GOTO Exit
    END

    IF id == 0 THEN
        KeAssert ( PsuSystemProcess == NULLPTR )

        // Fix the sequence number to be 1 for the system process so that we
        // never hand out a PID of 0. Why? Just seems nasty to, especially
        // because we use it as the PGID for the system session later.

        entry^.Sequence = 1
    END

    // Bitwise OR the sequence number into the ID.

    id = (id << PSP_ID_INDEXU_SHIFT) | (entry^.Sequence & PSP_ID_SEQUENCE_MASK)

    // Increment the sequence number.

    entry^.Sequence += 1

    // Set the object.

    entry^.Object = object

@Exit

    PspUnlockId ()

    RETURN status
END

#SECTION "PAGEtext"
FN PspDeleteId (
    IN id : UWORD,
)

    // Delete an ID from the table.

    PspLockIdExclusive ()

    ExuDeleteHandle (
        &PspIdTable, // handletable
        id >> PSP_ID_INDEXU_SHIFT, // handle
        NULLPTR, // entry
    )

    PspUnlockId ()
END

#SECTION "PAGEtext"
FN PspExchangeId (
    IN id : UWORD,
    IN object : ^VOID,
)

    // Exchange an ID with a new object pointer.

    PspLockIdExclusive ()

    entry := CAST ExuLookupHandle (
        &PspIdTable, // handletable
        id >> PSP_ID_INDEXU_SHIFT, // handle
    ) TO ^PspIdEntry

    KeAssert ( entry != NULLPTR )

    entry^.Object = object

    PspUnlockId ()
END

#SECTION "PAGEtext"
FN PspReferenceById (
    IN pid : UWORD,
    IN type : ^ObuType,
    OUT object : ^VOID,
) : OsStatus

    // Reference an object by its PID or TID.

    status := OS_STATUS_SUCCESS

    PspLockIdShared ()

    entry := CAST ExuLookupHandle (
        &PspIdTable, // handletable
        pid >> PSP_ID_INDEXU_SHIFT, // handle
    ) TO ^PspIdEntry

    IF NOT entry THEN
        // No such ID.

        status = OS_STATUS_INVALID_HANDLE

        GOTO Exit
    END

    object = entry^.Object

    IF pid & PSP_ID_SEQUENCE_MASK !=
        entry^.Sequence & PSP_ID_SEQUENCE_MASK THEN

        // Wrong sequence number.

        status = OS_STATUS_INVALID_HANDLE

        GOTO Exit
    END

    IF ObuFindHeader ( object )^.Type != type THEN
        // Not the correct object type.

        IF ObuFindHeader ( object )^.Type == &PsuProcessType AND
            type == &PsuGroupType THEN

            // We're looking for a process group and this is a process.
            // If it's the group leader then we can find the process group
            // through it.

            paged := (CAST object TO ^PsuProcess)^.Paged

            KeAcquireLockExclusive ( &paged^.GroupLock )

            IF paged^.ProcessGroup AND
                paged^.ProcessGroup^.LeaderPid == pid THEN

                // What we were *really* looking for was the process group.
                // Since we found the leader, we can return the group object.

                object = paged^.ProcessGroup

                ObuReferenceObject ( object )

                KeReleaseLock ( &paged^.GroupLock )

                GOTO Exit
            END

            KeReleaseLock ( &paged^.GroupLock )
        END

        status = OS_STATUS_INVALID_OBJECT_TYPE

        GOTO Exit
    END

    IF NOT ObuConditionallyReferenceObject ( object ) THEN
        // Object is being deleted.

        status = OS_STATUS_INVALID_HANDLE
    END

@Exit

    PspUnlockId ()

    RETURN status
END

#ENTERSECTION "INITtext"

FN PsuInitializeIdleProcess ()

    // Initialize the idle process enough to bootstrap other stuff.

    idleproc := &KeuIdleProcess

    idleproc^.Paged = &PspIdleProcessPaged

    idleproc^.Paged^.Cred.Uid = OS_SYSTEM_UID
    idleproc^.Paged^.Cred.Gid = OS_SYSTEM_GID
END

FN PsuInitializeStage1 ()

    // Stage 1 initialization for Ps.

    // Initialize the process type.

    ObuInitializeType ( &PsuProcessType )

    // Initialize the thread type.

    ObuInitializeType ( &PsuThreadType )

    // Initialize the job type.

    ObuInitializeType ( &PsuJobType )

    // Initialize the group type.

    ObuInitializeType ( &PsuGroupType )

    // Initialize the turnstile cache.

#LEAVESECTION

    PspTurnstileCache = MmuCreatePoolCache (
        PsuCurrentNode (), // node
        "Turnstiles", // name
        SIZEOF KepTurnstile, // size
        MMU_NONPAGED_POOL, // poolindex
        'Turn', // tag
    )

#ENTERSECTION "INITtext"

    IF NOT PspTurnstileCache THEN
        KeCrash ( "%sfailed to create turnstile cache\n",
            "PsuInitializeStage1: " )
    END

    // Initialize the PID/TID table.

    // Note that entrysizelog = 0 means the size of a handle table entry will be
    // two pointers, which fits our PspIdEntry structure, since the size of
    // an entry is calculated by (SIZEOF ^VOID * 2) << entrysizelog.

    ExuInitializeHandleTable (
        &PspIdTable, // handletable
        0, // entrysizelog
        PsuQuotaBlock ( PsuCurrentProcess () ), // quotablock
    )

    // Initialize the global process list.

    RtlInitializeList ( &PspProcessListHead )

    // Create the system process.

    params : NsuOpenParameters

    params.Path.Data = NULLPTR

    params.Captured.Flags = 0
    params.Captured.ObuFlags = 0
    params.Captured.Permissions = OS_ACCESS_OWNER_ALL

    name : RtlString

    RtlInitializeString ( &name, "System" )

    status := PsuCreateProcessObject (
        &params, // params
        NULLPTR, // partition
        &name, // name
        -1, // quotauid
        0, // flags
        OUT PsuSystemProcess, // process
    )

    IF OsError ( status ) THEN
        KeCrash ( "%sfailed to create system process (%x)\n",
            "PsuInitializeStage1: ", status )
    END

    // Set the system process's session.

    status = PsuSetGroupProcess (
        PsuSystemProcess, // process
        NULLPTR, // group
        TRUE, // newsession
    )

    IF OsError ( status ) THEN
        KeCrash ( "%sfailed to set system session (%x)\n",
            "PsuInitializeStage1: ", status )
    END

    // Initialize the reaper custody list. Threads are placed on this list when
    // they terminate, to transfer custody to the reaper thread.

    KeuInitializeCustodyList (
        &KeuReaperCustodyList, // list
        &PspActivateReaper, // activateroutine
        0, // context
    )

    ExuInitializeTimedWorkItem (
        &PspReaperTimedWorkItem, // item
        &PsuReaperWorker, // routine
    )

    // Create the balance manager thread, which will perform stage 2
    // initialization of the system.

    RtlInitializeString ( &name, "Balance Manager" )

    status = PsuCreateExecutiveThread (
        &name, // name
        &ExuStartSystemProcess, // startfunc
        0, // context1
        0, // context2
        0, // flags
        OUT PsuInitialThread, // thread
    )

    IF OsError ( status ) THEN
        KeCrash ( "%sfailed to create bal mgr (%x)\n", "PsuInitializeStage1: ",
            status )
    END

    ObuUnreferenceObject ( PsuInitialThread )
END

FN PsuInitializeStage2 ()

    // Stage 2 initialization for Ps.

    // Parse OSDLL and figure out where some symbols are.

    // ... NYI ...

    // Create the SystemInit.exe process.

    // ... NYI ...

    // Set it to the highest non-realtime priority.

    // ... NYI ...

    // Create its main thread.

    // ... NYI ...

    // Unreference the main thread.

    // ... NYI ...
END

#LEAVESECTION