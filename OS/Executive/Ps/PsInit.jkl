//
// Initialization for the Process Manager for the MINTIA Executive.
//

#INCLUDE "Psp.hjk"

#INCLUDE "<ll>/System/OsObject.hjk"

PUBLIC PspProcessListLock : KeLock = KE_INITIAL_LOCK
PUBLIC PspProcessListHead : RtlListEntry

PUBLIC PsuActiveProcessCount : UWORD = 0

PUBLIC PsuInitialThread : ^PsuThread

PspIdleProcessPaged : PsuPagedProcess

PspIdTable : ExuHandleTable
PspIdLock : KeLock = KE_INITIAL_LOCK

#DEFINE PSP_ID_INDEXU_SHIFT 10
#DEFINE PSP_ID_SEQUENCE_MASK [((1 << PSP_ID_INDEXU_SHIFT) - 1)]

STRUCT PspIdEntry
    Object : ^VOID,
    Sequence : UWORD,
END

#MACRO PspLockIdExclusive () [
    KeAcquireLockExclusive ( &PspIdLock )
]

#MACRO PspLockIdShared () [
    KeAcquireLockShared ( &PspIdLock )
]

#MACRO PspUnlockId () [
    KeReleaseLock ( &PspIdLock )
]

#SECTION "PAGEtext"
FN PspCreateId (
    IN object : ^VOID,
    OUT id : UWORD,
) : OsStatus

    // Insert an object into the PID/TID table. Should be fully initialized in
    // all relevant ways or people will be able to get a pointer to a bad
    // object.

    entry : ^PspIdEntry

    PspLockIdExclusive ()

    status := ExuCreateHandle (
        &PspIdTable, // handletable
        &PspIdLock, // lock
        OUT id, // handle
        OUT entry, // entryptr
    )

    IF OsError ( status ) THEN
        GOTO Exit
    END

    IF id == 0 THEN
        // Fix the sequence number to be 1 for the system process so that we
        // never hand out a PID of 0. Why? Just seems nasty to, especially
        // because we use it as the PGID for the system session later.

        entry^.Sequence = 1
    END

    // Bitwise OR the sequence number into the ID.

    id = (id << PSP_ID_INDEXU_SHIFT) | (entry^.Sequence & PSP_ID_SEQUENCE_MASK)

    // Increment the sequence number.

    entry^.Sequence += 1

    // Set the object.

    entry^.Object = object

@Exit

    PspUnlockId ()

    RETURN status
END

#SECTION "PAGEtext"
FN PspDeleteId (
    IN id : UWORD,
)

    // Delete an ID from the table.

    PspLockIdExclusive ()

    ExuDeleteHandle (
        &PspIdTable, // handletable
        id >> PSP_ID_INDEXU_SHIFT, // handle
        NULLPTR, // entry
    )

    PspUnlockId ()
END

#SECTION "PAGEtext"
FN PspExchangeId (
    IN id : UWORD,
    IN object : ^VOID,
)

    // Exchange an ID with a new object pointer.

    PspLockIdExclusive ()

    entry := CAST ExuLookupHandle (
        &PspIdTable, // handletable
        id >> PSP_ID_INDEXU_SHIFT, // handle
    ) TO ^PspIdEntry

    KeAssert ( entry != NULLPTR )

    entry^.Object = object

    PspUnlockId ()
END

#SECTION "PAGEtext"
FN PspReferenceById (
    IN pid : UWORD,
    IN typeid : OsObjectType,
    OUT object : ^VOID,
) : OsStatus

    // Reference an object by its PID or TID.

    status := OS_STATUS_SUCCESS

    PspLockIdShared ()

    entry := CAST ExuLookupHandle (
        &PspIdTable, // handletable
        pid >> PSP_ID_INDEXU_SHIFT, // handle
    ) TO ^PspIdEntry

    IF NOT entry THEN
        // No such ID.

        status = OS_STATUS_INVALID_HANDLE

        GOTO Exit
    END

    object = entry^.Object

    IF pid & PSP_ID_SEQUENCE_MASK !=
        entry^.Sequence & PSP_ID_SEQUENCE_MASK THEN

        // Wrong sequence number.

        status = OS_STATUS_INVALID_HANDLE

        GOTO Exit
    END

    IF ObuFindHeader ( object )^.Type^.TypeIdentifier != typeid THEN
        // Not the correct object type.

        IF ObuFindHeader ( object )^.Type^.TypeIdentifier == OS_PROCESS_TYPE AND
            typeid == OS_GROUP_TYPE THEN

            // We're looking for a process group and this is a process.
            // If it's the group leader then we can find the process group
            // through it.

            paged := (CAST object TO ^PsuProcess)^.Paged

            KeAcquireLockExclusive ( &paged^.GroupLock )

            IF paged^.ProcessGroup AND
                paged^.ProcessGroup^.LeaderPid == pid THEN

                // What we were *really* looking for was the process group.
                // Since we found the leader, we can return the group object.

                object = paged^.ProcessGroup

                ObReferenceObject ( object )

                KeReleaseLock ( &paged^.GroupLock )

                GOTO Exit
            END

            KeReleaseLock ( &paged^.GroupLock )
        END

        status = OS_STATUS_INVALID_OBJECT_TYPE

        GOTO Exit
    END

    IF NOT ObConditionallyReferenceObject ( object ) THEN
        // Object is being deleted.

        status = OS_STATUS_INVALID_HANDLE
    END

@Exit

    PspUnlockId ()

    RETURN status
END

#ENTERSECTION "INITtext"

FN PsuInitializeIdleProcess (
    IN kenode : ^KeuNode,
)

    // Initialize the idle process enough to bootstrap other stuff.

    idleproc : ^PsuProcess = KeuAllocateNodeSpace (
        kenode, // kenode
        SIZEOF PsuProcess, // bytes
    )

    KeAssert ( idleproc != NULLPTR )

    kenode^.IdleProcess = idleproc

    KeuInitializeProcess (
        &idleproc^.Pcb, // process
        "Idle", // name
        kenode, // kenode
    )

    idleproc^.Pcb.PageDirectoryPfn = kenode^.SystemPageDirectoryPfn

    idleproc^.Paged = KeuAllocateNodeSpace (
        kenode, // kenode
        SIZEOF PsuPagedProcess, // bytes
    )

    KeAssert ( idleproc^.Paged != NULLPTR )

    idleproc^.Paged^.Cred.Uid = OS_SYSTEM_UID
    idleproc^.Paged^.Cred.Gid = OS_SYSTEM_GID

    kenode^.SystemCred = &idleproc^.Paged^.Cred
END

FN PsuInitializeStage1 ()

    // Stage 1 initialization for Ps.

    name : RtlString
    status : OsStatus

    // Initialize the process type.

    ObuInitializeType ( &PspProcessType )

    // Initialize the thread type.

    ObuInitializeType ( &PspThreadType )

    // Initialize the job type.

    ObuInitializeType ( &PspJobType )

    // Initialize the group type.

    ObuInitializeType ( &PspGroupType )

    // Initialize the PID/TID table.

    // Note that entrysizelog = 0 means the size of a handle table entry will be
    // two pointers, which fits our PspIdEntry structure, since the size of
    // an entry is calculated by (SIZEOF ^VOID * 2) << entrysizelog.

    ExuInitializeHandleTable (
        &PspIdTable, // handletable
        0, // entrysizelog
        PsuQuotaBlock ( PsCurrentProcess () ), // quotablock
    )

    // Initialize the global process list.

    RtlInitializeList ( &PspProcessListHead )

    // Initialize the reaper custody list. Threads are placed on this list when
    // they terminate, to transfer custody to the reaper thread.

    i := 0
    max := KeQueryNodeCount ()

    WHILE i < max DO
        kenode := KeNumaNodeById ( i )

        psnode : ^PspNode = KeuAllocateNodeSpace (
            kenode, // kenode
            SIZEOF PspNode, // bytes
        )

        KeAssert ( psnode != NULLPTR )

        kenode^.Psp = psnode
        kenode^.ReaperCustodyList = &psnode^.ReaperCustodyList

        KeuInitializeCustodyList (
            &psnode^.ReaperCustodyList, // list
            &PspActivateReaper, // activateroutine
            kenode, // context
        )

        ExInitializeTimedWorkItem (
            &psnode^.ReaperTimedWorkItem, // item
            &PsuReaperWorker, // routine
        )

        // Initialize the turnstile cache.

#LEAVESECTION

        psnode^.TurnstileCache = MmCreatePoolCache (
            kenode^.Mmp, // mmnode
            "Turnstiles", // name
            SIZEOF KepTurnstile, // size
            MM_NONPAGED_POOL, // poolindex
            'Turn', // tag
        )

#ENTERSECTION "INITtext"

        IF NOT psnode^.TurnstileCache THEN
            KeCrash ( "%sfailed to create turnstile cache\n",
                "PsuInitializeStage1: " )
        END

        // Create the system process.

        params : NsOpenParameters

        params.Path.Data = NULLPTR

        params.Captured.Flags = 0
        params.Captured.ObFlags = 0
        params.Captured.Permissions = OS_ACCESS_OWNER_ALL

        sysprocname : UBYTE[32]

        RtlFormat (
            &sysprocname[0], // dest
            32, // bufsize
            "SystemNode%u", // fmt
            i,
        )

        RtlInitializeString ( &name, &sysprocname[0] )

        status = PsuCreateProcessObject (
            &params, // params
            kenode^.Mmp, // mmnode
            &name, // name
            -1, // quotauid
            0, // flags
            OUT kenode^.SystemProcess, // process
        )

        IF OsError ( status ) THEN
            KeCrash ( "%sfailed to create system process (%x)\n",
                "PsuInitializeStage1: ", status )
        END

        // Set the system process's session.

        status = PsuSetGroupProcess (
            kenode^.SystemProcess, // process
            NULLPTR, // group
            TRUE, // newsession
        )

        IF OsError ( status ) THEN
            KeCrash ( "%sfailed to set system session (%x)\n",
                "PsuInitializeStage1: ", status )
        END

        i += 1
    END

    // Create the balance manager thread, which will perform stage 2
    // initialization of the system.

    RtlInitializeString ( &name, "Balance Manager" )

    status = PsCreateExecutiveThread (
        KeNumaNodeById ( 0 ), // kenode
        &name, // name
        &ExuStartSystemProcess, // startfunc
        0, // context1
        0, // context2
        0, // flags
        OUT PsuInitialThread, // thread
    )

    IF OsError ( status ) THEN
        KeCrash ( "%sfailed to create bal mgr (%x)\n", "PsuInitializeStage1: ",
            status )
    END

    ObUnreferenceObject ( PsuInitialThread )
END

FN PsuInitializeStage2 ()

    // Stage 2 initialization for Ps.

    // Parse OSDLL and figure out where some symbols are.

    // ... NYI ...

    // Create the SystemInit.exe process.

    // ... NYI ...

    // Set it to the highest non-realtime priority.

    // ... NYI ...

    // Create its main thread.

    // ... NYI ...

    // Unreference the main thread.

    // ... NYI ...
END

#LEAVESECTION