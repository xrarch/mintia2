//
// Implements waiting for threads for the MINTIA Kernel.
//

#INCLUDE "Kep.hjk"

#INCLUDE "<ll>/System/OsStatus.hjk"
#INCLUDE "<ll>/System/OsSignal.hjk"

#IF BLD_MP

#MACRO KepSetWaitAttempt ( thread, state ) [
    NOTHING (thread)^.WaitAttempt = (state)
]

#ELSE

#MACRO KepSetWaitAttempt ( thread, state ) []

#END

#MACRO KepDequeueWaitBlock ( waitblock ) [
    object := (waitblock)^.Object

    // Acquire the object lock.

    KepAcquireObjectElevated ( object )

    IF (waitblock)^.Flags & KEP_WB_DEQUEUED == 0 THEN
        // Remove the wait block.

        RtlRemoveEntryList ( &(waitblock)^.Entry )

        // Decrement waiter count, since this wait block wasn't
        // satisfied yet.

        KeAssert ( object^.WaiterCount != 0 )

        object^.WaiterCount -= 1
    END

    // Release the object lock.

    KepReleaseObjectElevated ( object )
]

#IF BLD_MP

FN KepIndicateActiveFunc (
    IN thread : ^KeuThread,
)

    // Long path.

    queue := thread^.BalancedQueue

    KepComputeQueueRemovalLockAddress ( lock, queue )

    KepAcquireQueueRemovalElevated ( lock )

    IF thread^.BalancedQueue THEN
        KepAcquireObjectElevated ( &queue^.Header )

        queue^.ActiveThreadCount += 1

        KepReleaseObjectElevated ( &queue^.Header )
    END

    KepReleaseQueueRemovalElevated ( lock )
END

FN KepIndicateDeactivatedFunc (
    IN thread : ^KeuThread,
)

    // Long path.

    queue := thread^.BalancedQueue

    KepComputeQueueRemovalLockAddress ( lock, queue )

    KepAcquireQueueRemovalElevated ( lock )

    IF (thread)^.BalancedQueue THEN
        KepAcquireObjectElevated ( &queue^.Header )

        KepWakeBalancedQueue ( queue )

        KepReleaseObjectElevated ( &queue^.Header )
    END

    KepReleaseQueueRemovalElevated ( lock )
END

#END

#MACRO KepIndicateActive ( thread ) [
    // If we're associated with a balanced queue, we have to indicate that we've
    // awoken.

    IF (thread)^.BalancedQueue THEN
        // Indicate that we're active again.

#IF BLD_MP
        KepIndicateActiveFunc ( thread )
#ELSE
        (thread)^.BalancedQueue^.ActiveThreadCount += 1
#END
    END
]

#MACRO KepIndicateDeactivated ( thread ) [
    // If we're associated with a balanced queue, we have to indicate that we're
    // blocking.

    IF (thread)^.BalancedQueue THEN
        // Indicate that we're deactivated again.

#IF BLD_MP
        KepIndicateDeactivatedFunc ( thread )
#ELSE
        KepWakeBalancedQueue ( (thread)^.BalancedQueue )
#END
    END
]

FN KepWaitThread (
    IN thread : ^KeuThread,
    IN hastimeout : UWORD,
) : OsStatus

    // This function is entered with the thread lock held (IPLDPC).

    prb := KEP_CURRENT_PRB

    KeAssert ( thread != &prb^.IdleThread )

    // Set the thread status to WAITING.

    thread^.Status = KE_THREAD_WAITING

    // Store tick we slept on.

    thread^.StateMs = KepLowTick ()

    // Yield.

    KepYield (
        thread, // current
        prb, // prb
    )

    // We're back! Thread lock is dropped, but we're still at KEP_IPL_DPC.

    // All of our wait blocks have been marked UNWAITED, but may not have been
    // dequeued, so we have to do that now.

    waitblock := thread^.WaitBlockTable
    count := thread^.WaitCount

    WHILE count DO
        KepDequeueWaitBlock ( waitblock )

        count -= 1
        waitblock += SIZEOF KepWaitBlock
    END

    IF hastimeout THEN
        waitblock = &thread^.TimeoutWaitBlock

        // Remove the timer wait block.

        KepDequeueWaitBlock ( waitblock )

        // Cancel the timer.

        KeDequeueTimer ( &thread^.Timeout )
    END

    // If we're associated with a balanced queue, we have to indicate that we're
    // awake now.

    KepIndicateActive ( thread )

    // If we were placed on a list of kernel stack outswap candidates, remove
    // ourselves.

    KepRemoveSwapCandidateList ( thread )

    // Return the status.

    RETURN thread^.WaitStatus
END

FN KepUnwaitThread (
    IN thread : ^KeuThread,
    IN status : OsStatus,
    IN priorityboost : UWORD,
)

    // Unwait the thread with the given status.
    // An object lock may be held. The thread lock is held.
    // If we're here, the thread was definitely waiting - it was either in
    // KE_THREAD_WAITING state, or KE_THREAD_RUNNING and WAIT_TRY. This means
    // that its wait block table is valid and full of initialized wait blocks.

#IF BLD_CHK
    IF thread^.Status != KE_THREAD_WAITING
#IF BLD_MP
        AND (thread^.Status != KE_THREAD_RUNNING OR
        thread^.WaitAttempt != KEP_THREAD_WAIT_TRY)
#END
        THEN

        KeCrash ( "KepUnwaitThread: thread wasn't waiting %x %x\n",
            thread^.Status, thread )        
    END
#END

#IF BLD_MP
    IF thread^.Status == KE_THREAD_RUNNING THEN
        // Must be in WAIT_TRY. Abort the wait.

        thread^.WaitAttempt = KEP_THREAD_WAIT_ABORTED
    END
#END

    // Store the wake status in the thread object.

    thread^.WaitStatus = status

    // Set all the thread's wait blocks to UNWAITED.
    // They'll be dequeued under the lock of each object as they stumble across
    // them, and will be finally removed by the thread when it wakes up.

    waitblock := thread^.WaitBlockTable
    count := thread^.WaitCount

    WHILE count DO
        waitblock^.Flags |= KEP_WB_UNWAITED

        count -= 1
        waitblock += SIZEOF KepWaitBlock
    END

    // Set the timeout wait block unwaited too. If the timer was enqueued, it'll
    // be dequeued by the thread when he wakes up or notices he was aborted.

    thread^.TimeoutWaitBlock.Flags |= KEP_WB_UNWAITED

    IF thread^.Status == KE_THREAD_WAITING THEN
        // Replenish the quantum of the thread.

        thread^.RemainingQuantum = KEP_DEFAULT_QUANTUM

        IF priorityboost AND thread^.Priority < OS_PRIORITY_LOW_REALTIME THEN
            // Apply the priority boost to the thread.

            newpri := thread^.BasePriority + priorityboost

            // Don't cross into the real time priority class.

            IF newpri > OS_PRIORITY_HIGH_USER THEN
                newpri = OS_PRIORITY_HIGH_USER
            END

            // Only apply the boost if it raises the thread's priority.

            IF newpri > thread^.Priority THEN
                thread^.Priority = newpri
            END
        END

        // Update the ticks the thread has spent sleeping.

        waitedms := thread^.StateMs
        currentms := KepLowTick ()

        IF waitedms < currentms THEN
            thread^.SleepMs += (currentms - waitedms) << KEP_TICK_SHIFT

            // Update interactivity score.

            KepUpdateInteractivity (
                thread, // thread
                FALSE, // deferupdate
            )
        END

        // Ready the thread.

        KepReadyThread ( thread )
    END
END

FN KepSatisfyObject (
    IN object : ^KepDispatchHeader,
    IN priorityboost : UWORD,
    IN all : UWORD,
    IN status : OsStatus,
) : ^KeuThread

    // Satisfy a wait on the object. The object lock is held.
    // Return a pointer to a satisfied thread object, NULLPTR if none satisfied.

    listhead := &object^.WaitListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        waitblock := CONTAINEROF listentry TO KepWaitBlock.Entry

        thread := waitblock^.Thread

        // Acquire the thread's lock.

        KepAcquireThreadElevated ( thread )

        // Set the wait block dequeued and remove it from our queue.

        waitblock^.Flags |= KEP_WB_DEQUEUED

        RtlRemoveEntryList ( &waitblock^.Entry )

        // Decrement our waiter count.

        object^.WaiterCount -= 1

        IF waitblock^.Flags & KEP_WB_UNWAITED THEN
            // This wait block was already unwaited and left on our queue by
            // someone else. Get the next one and continue.

            KepReleaseThreadElevated ( thread )

            listentry = listentry^.Next

            CONTINUE
        END

        // Still active. Unwait the thread.

        IF NOT status THEN
            // Unwait with the status stored in the wait block.

            KepUnwaitThread (
                waitblock^.Thread, // thread
                waitblock^.WakeStatus, // status
                priorityboost, // priorityboost
            )

        ELSE
            // Unwait with the specified status.

            KepUnwaitThread (
                waitblock^.Thread, // thread
                status, // status
                priorityboost, // priorityboost
            )
        END

        KepReleaseThreadElevated ( thread )

        IF NOT all THEN
            // We got one, so exit.

            RETURN thread
        END

        listentry = listentry^.Next
    END

    RETURN NULLPTR
END

FN KepWaitCheck (
    IN thread : ^KeuThread,
    IN ipl : UWORD,
    IN alertable : UWORD,
    IN waitmode : UWORD,
) : OsStatus

    // Ensure that everything is in order for the thread to wait, and that no
    // events should interrupt said wait.

    bits := thread^.PendingEventsSet

    // Before we start, check for events that would interrupt the wait.

    IF ipl == KEP_IPL_APC THEN
        // IPL >= KEP_IPL_APC masks out all events, but the caller can request
        // cancellation upon KAPC reception.

        IF alertable == KE_CANCEL_ON_KAPC AND
            bits & KEP_THREAD_PENDING_KAPC THEN

            // This wait is cancelled when kernel APCs are pending.
            // This allows consumers to use custom wait cleanup logic prior to
            // the execution of pending KAPCs (in particular, the turnstile
            // package).

            KepReleaseThread ( thread, KEP_IPL_APC )

            RETURN OS_STATUS_KERNEL_APC
        END

#IF BLD_MP
    ELSEIF bits & KEP_THREAD_PENDING_KAPC THEN
        // A KAPC was enqueued between raising IPL and locking our thread, so
        // dispatch it and retry.

        KepReleaseThread ( thread, KEP_IPL_LOW )

        RETURN OS_STATUS_TRY_AGAIN
#END

    ELSEIF waitmode == KE_USER_MODE AND
        bits & KEP_THREAD_PENDING_LAPC THEN

        // There are pending lazy APCs and this is a usermode wait,
        // so dispatch them and retry.

        KepReleaseThread ( thread, KEP_IPL_LOW )

        KepDispatchLazyApcQueue ( thread )

        RETURN OS_STATUS_TRY_AGAIN

    ELSEIF alertable == KE_UNALERTABLE THEN
        // Wait was unalertable.

        IF waitmode == KE_USER_MODE AND
            thread^.SignalMask[0] & (1 << OS_SIGNAL_KILL) THEN

            // Unalertable usermode waits are only interrupted by
            // termination.

            KepReleaseThread ( thread, KEP_IPL_LOW )

            RETURN OS_STATUS_KILLED
        END

    ELSEIF waitmode == KE_KERNEL_MODE THEN
        IF NOT thread^.IgnoreEventCount AND
            thread^.SignalMask[0] & (1 << OS_SIGNAL_KILL) THEN

            // Alertable kernel mode waits are only interrupted by
            // termination.

            KepReleaseThread ( thread, KEP_IPL_LOW )

            RETURN OS_STATUS_KILLED
        END

    ELSEIF bits & KEP_THREAD_PENDING_UAPC THEN
        // There are pending usermode APCs and this is a usermode
        // wait, so interrupt the wait and cause them to be
        // dispatched upon return to userspace.

        thread^.UserApcTriggered = TRUE
        thread^.UserInterrupt = TRUE

        KepReleaseThread ( thread, KEP_IPL_LOW )

        RETURN OS_STATUS_USER_APC

    ELSEIF bits & KEP_THREAD_PENDING_SIGNAL THEN
        // There are pending signals and this is a usermode wait, so
        // interrupt the wait and cause them to be dispatched upon return
        // to usermode.

        thread^.SignalDeliverOnWaitMask[0] &= ~thread^.SignalMask[0]
        thread^.SignalDeliverOnWaitMask[1] &= ~thread^.SignalMask[1]

        thread^.UserInterrupt = TRUE

        KepReleaseThread ( thread, KEP_IPL_LOW )

        RETURN OS_STATUS_SIGNALED
    END

    RETURN 0
END

FN KepCaptureCurrentTicksFunc (
    IN time : ^RtlUquad,
)

    // Capture current ticks, out-of-line.

    KepCaptureCurrentTicks ( time )
END

#MACRO KepWaitHead (
    thread, ipl, alertable, waitmode, waitblocktable, waitcount, status
) [

    // Clear timeout wait block flags field.

    thread^.TimeoutWaitBlock.Flags = 0

    // Set the wait values in the thread.

    thread^.Alertable = alertable
    thread^.WaitMode = waitmode
    thread^.WaitIpl = ipl

    // Store the wait block table in the thread.

    thread^.WaitBlockTable = waitblocktable
    thread^.WaitCount = waitcount

    // Acquire the thread lock to check for interrupting events.

    KepAcquireThreadElevated ( thread )

    IF thread^.PendingEventsSet THEN
        // There are pending events that need checking.

        status = KepWaitCheck (
            thread, // thread
            ipl, // ipl
            alertable, // alertable
            waitmode, // waitmode
        )

        IF status THEN
            // KepWaitCheck already released the thread and lowered IPL.

            IF status == OS_STATUS_TRY_AGAIN THEN
                GOTO Retry
            END

            RETURN status
        END
    END

    // Set the thread to wait-try.
    //
    // Note that this wait-try tactic was derived from an explanation given
    // by Arun Kishan in an interview about how the Windows kernel team
    // broke up the dispatcher spinlock.

    KepSetWaitAttempt ( thread, KEP_THREAD_WAIT_TRY )

    KepReleaseThreadElevated ( thread )
]

FN KepKernelApcReceived (
    IN timeout : ^RtlUquad,
    IN starttime : ^RtlUquad,
) : UWORD

    // A kernel APC interrupted the wait, so decrement the timeout based on how
    // many milliseconds have transpired since the wait began. Return TRUE if
    // the timeout is already in the past.

    currenttime : RtlUquad

    KepCaptureCurrentTicks ( &currenttime )

    RtlSubUquadFromUquad ( &currenttime, starttime )

    IF NOT RtlUquadLtUquad ( &currenttime, timeout ) THEN
        // Timeout already expired.

        RETURN TRUE
    END

    RtlSubUquadFromUquad ( timeout, &currenttime )

    RETURN FALSE
END

EXPORT FN KeWaitForObjects (
    IN waitmode : UWORD,
    IN alertable : UWORD,
    IN timeout : ^RtlUquad,
    IN objectcount : UWORD,
    IN objecttable : ^^KepDispatchHeader,
    IN waitblocktable : ^KepWaitBlock,
) : OsStatus

    // Wait for any of multiple objects to enter a signaled state. A timeout
    // interval in milliseconds can be supplied. If it is NULLPTR, the timeout
    // is infinite.

    // The following parameters should never be given by executive callers and
    // should have been rejected by the object manager.

    KeAssert ( objectcount != 0 )
    KeAssert ( objectcount <= 0xFF )

    thread := KeCurrentThread ()

    IF NOT waitblocktable THEN
        KeAssert ( objectcount <= KEP_THREAD_WAIT_BLOCKS )

        // Use the integral wait blocks of the thread.
        // This mechanism exists to remove dependency on allocation.

        waitblocktable = &thread^.WaitBlocks[0]
    END

    capturedtimeout : RtlUquad

    IF timeout THEN
        RtlMoveUquad (
            &capturedtimeout, // dest
            timeout, // src
        )
    END

    // Initialize all of the wait blocks now.
    // This isn't just to reduce time at KEP_IPL_DPC - if we initialize them
    // while enqueuing wait blocks to the objects, clearing the Flags field
    // is racey with other processors satisfying object waits.

    i := 0
    waitblock := &waitblocktable[0]

    WHILE i < objectcount DO
        waitblock^.Thread = thread
        waitblock^.Object = objecttable[i]
        waitblock^.WakeStatus = i
        waitblock^.Flags = 0

        i += 1
        waitblock += SIZEOF KepWaitBlock
    END

@Retry

    // Raise IPL to stop APCs from corrupting our wait state if they come in
    // and try to wait in our context.

    ipl := KepRaiseIpl ( KEP_IPL_DPC )

    KeAssert ( ipl < KEP_IPL_DPC )

    // Capture the start time.

    starttime : RtlUquad

    IF timeout THEN
        KepCaptureCurrentTicksFunc ( &starttime )
    END

    // The following function is a macro that can perform an early return.
    // It puts us in a WAIT_TRY state and raises IPL to KEP_IPL_DPC.

    status : OsStatus

    KepWaitHead (
        thread, // thread
        ipl, // ipl
        alertable, // alertable
        waitmode, // waitmode
        waitblocktable, // waitblocktable
        objectcount, // waitcount
        status, // status
    )

    timer : ^KeTimer
    object : ^KepDispatchHeader

    waitblock = &waitblocktable[0]
    i = 0

    WHILE i < objectcount DO
        object = objecttable[i]

        KepAcquireObjectElevated ( object )

        // Capture the current signal count.

        signal := object^.SignalCount

        IF signal THEN
            // Already signaled. Our wait has been satisfied before it began.
            // If this isn't a notification event, consume the count.

            IF object^.Type != KEP_DISPATCH_EVENT_NOTIF THEN
                object^.SignalCount = signal - 1
            END

            KepReleaseObjectElevated ( object )

            status = i

@Abort

            // Back out of the wait by simply removing our wait blocks from all
            // of the objects that we enqueued them to.
            //
            // Note the label above - on MP we GOTO here if another processor
            // rudely aborted our wait.
            //
            // At this point "i" is equivalent to the maximum object index we
            // reached before we aborted, and "status" is equivalent to whatever
            // we should return when we leave.

            j := 0
            waitblock = &waitblocktable[0]

            WHILE j < i DO
                KepDequeueWaitBlock ( waitblock )

                j += 1
                waitblock += SIZEOF KepWaitBlock
            END

            KepSetWaitAttempt ( thread, KEP_THREAD_WAIT_NONE )

            KepLowerIpl ( ipl )

            IF status != OS_STATUS_KERNEL_APC THEN
                RETURN status
            END

            GOTO KernelApcReceived
        END

        // Enqueue our wait block to the object.

        RtlInsertAtTailList (
            &object^.WaitListHead, // head
            &waitblock^.Entry, // entry
        )

        // Increment waiter count.

        KeAssert ( object^.WaiterCount != 0xFFFFFFFF )

        object^.WaiterCount += 1

        // Release the object lock.

        KepReleaseObjectElevated ( object )

        waitblock += SIZEOF KepWaitBlock
        i += 1
    END

    IF timeout THEN
        // Start the timeout.
        // NOTE: The timer object and the timeout wait block have been
        //       initialized by KeuInitializeThread already.

        waitblock = &thread^.TimeoutWaitBlock
        timer = &thread^.Timeout

        // Insert the wait block in the timer's list.
        // This is safe to do without a lock because only we ever mess with
        // this timer in the context of this thread.

        RtlInsertAtTailList (
            &timer^.Header.WaitListHead, // head
            &waitblock^.Entry, // entry
        )

        timer^.Header.WaiterCount = 1

        // Enqueue the timer.

        KeEnqueueTimer (
            timer, // timer
            &capturedtimeout, // interval
            0, // context1
            0, // context2
        )
    END

    // If we're associated with a balanced queue, we have to indicate that we
    // are blocking so that someone else can be awoken. We have to do this
    // before acquiring the thread lock because of lock ordering.

    KepIndicateDeactivated ( thread )

    // If this is a KE_USER_MODE wait, and our kernel stack is swappable,
    // insert ourselves on the current processor's outswap candidate list.

    KepInsertSwapCandidateList ( thread, waitmode )

    // Lock our thread.

    KepAcquireThreadElevated ( thread )

#IF BLD_MP
    // Check if an interrupting event (such as the object being signaled, a user
    // APC, etc) from another processor aborted our wait while we were enqueuing
    // wait blocks.

    IF thread^.WaitAttempt == KEP_THREAD_WAIT_ABORTED THEN
        // It was aborted. We have to dequeue all our wait blocks and return.
        //
        // Release the thread lock so we don't violate the object->thread
        // lock ordering.

        KepReleaseThreadElevated ( thread )

        IF timeout THEN
            // We need to get rid of the timer.

            waitblock = &thread^.TimeoutWaitBlock
            timer = &thread^.Timeout

            // Dequeue it.

            KeDequeueTimer ( timer )

            // Remove the wait block.
            // We don't need the timer's object lock because we've been
            // nonpreemptible and blocking out the expiration DPC for this
            // processor since we enqueued it. Therefore it is still in our
            // custody.

            RtlRemoveEntryList ( &waitblock^.Entry )
        END

        // If we're associated with a balanced queue, we indicated that we were
        // deactivated. We have to undo that now.

        KepIndicateActive ( thread )

        // If we were placed on a list of kernel stack outswap candidates, we
        // have to remove ourselves.

        KepRemoveSwapCandidateList ( thread )

        // The guy who aborted the wait left our status in our thread struct.

        status = thread^.WaitStatus

        GOTO Abort
    END

    thread^.WaitAttempt = KEP_THREAD_WAIT_COMMITTED
#END

    // The wait shall proceed.

    status = KepWaitThread (
        thread, // thread
        timeout, // hastimeout
    )

    KepLowerIpl ( ipl )

    // KepWaitThread returns with the thread lock released.
    // All of our wait blocks have been dequeued, timer dequeued, etc.

    IF status != OS_STATUS_KERNEL_APC THEN
        RETURN status
    END

@KernelApcReceived

    IF alertable == KE_CANCEL_ON_KAPC THEN
        RETURN status
    END

    IF timeout AND KepKernelApcReceived (
        &capturedtimeout, // timeout
        &starttime, // starttime
    ) THEN
        RETURN OS_STATUS_WAIT_TIMEOUT
    END

    GOTO Retry
END

EXPORT FN KeSleep (
    IN interval : ^RtlUquad,
    IN waitmode : UWORD,
    IN alertable : UWORD,
) : OsStatus

    thread := KeCurrentThread ()

    capturedinterval : RtlUquad

    RtlMoveUquad (
        &capturedinterval, // destquad
        interval, // srcquad
    )

@Retry

    // Raise IPL to stop APCs from corrupting our wait state if they come in
    // and try to wait in our context.

    ipl := KepRaiseIpl ( KEP_IPL_DPC )

    KeAssert ( ipl < KEP_IPL_DPC )

    // Capture the start time.

    starttime : RtlUquad

    KepCaptureCurrentTicks ( &starttime )

    // The following function is a macro that can perform an early return.
    // It puts us in a WAIT_TRY state and raises IPL to KEP_IPL_DPC.

    status : OsStatus

    KepWaitHead (
        thread, // thread
        ipl, // ipl
        alertable, // alertable
        waitmode, // waitmode
        NULLPTR, // waitblocktable
        0, // waitcount
        status, // status
    )

    // Start the timeout.
    // NOTE: The timer object and the timeout wait block have been
    //       initialized by KeuInitializeThread already.

    waitblock := &thread^.TimeoutWaitBlock
    timer := &thread^.Timeout

    // Insert the wait block in the timer's list.
    // This is safe to do without a lock because only we ever mess with
    // this timer in the context of this thread.

    RtlInsertAtTailList (
        &timer^.Header.WaitListHead, // head
        &waitblock^.Entry, // entry
    )

    timer^.Header.WaiterCount = 1

    // Enqueue the timer.

    KeEnqueueTimer (
        timer, // timer
        &capturedinterval, // interval
        0, // context1
        0, // context2
    )

    // If we're associated with a balanced queue, we have to indicate that we
    // are blocking so that someone else can be awoken. We have to do this
    // before acquiring the thread lock because of lock ordering.

    KepIndicateDeactivated ( thread )

    // If this is a KE_USER_MODE wait, and our kernel stack is swappable,
    // insert ourselves on the current processor's outswap candidate list.

    KepInsertSwapCandidateList ( thread, waitmode )

    // Lock our thread.

    KepAcquireThreadElevated ( thread )

#IF BLD_MP
    // Check if an interrupting event (such as the object being signaled, a user
    // APC, etc) from another processor aborted our wait while we were enqueuing
    // wait blocks.

    IF thread^.WaitAttempt == KEP_THREAD_WAIT_ABORTED THEN
        // It was aborted. We have to dequeue all our wait blocks and return.
        //
        // Release the thread lock so we don't violate the object->thread
        // lock ordering.

        KepReleaseThreadElevated ( thread )

        // We need to get rid of the timer.

        // Dequeue it.

        KeDequeueTimer ( timer )

        // Remove the wait block.
        // We don't need the timer's object lock because we've been
        // nonpreemptible and blocking out the expiration DPC for this
        // processor since we enqueued it. Therefore it is still in our
        // custody.

        RtlRemoveEntryList ( &waitblock^.Entry )

        // The guy who aborted the wait left our status in our thread struct.

        status = thread^.WaitStatus

        // Set to not waiting.

        KepSetWaitAttempt ( thread, KEP_THREAD_WAIT_NONE )

        // If we're associated with a balanced queue, we indicated that we were
        // deactivated. We have to undo that now.

        KepIndicateActive ( thread )

        // If we were placed on a list of kernel stack outswap candidates, we
        // have to remove ourselves.

        KepRemoveSwapCandidateList ( thread )

        KepLowerIpl ( ipl )

        IF status != OS_STATUS_KERNEL_APC THEN
            RETURN status
        END

        GOTO KernelApcReceived
    END

    thread^.WaitAttempt = KEP_THREAD_WAIT_COMMITTED
#END

    // The wait shall proceed.

    status = KepWaitThread (
        thread, // thread
        TRUE, // hastimeout
    )

    KepLowerIpl ( ipl )

    // KepWaitThread returns with the thread lock released.
    // All of our wait blocks have been dequeued, timer dequeued, etc.

    IF status != OS_STATUS_KERNEL_APC THEN
        RETURN status
    END

@KernelApcReceived

    IF alertable == KE_CANCEL_ON_KAPC THEN
        RETURN status
    END

    IF KepKernelApcReceived (
        &capturedinterval, // timeout
        &starttime, // starttime
    ) THEN
        RETURN OS_STATUS_WAIT_TIMEOUT
    END

    GOTO Retry
END

EXPORT FN KeWaitForSingleObject (
    IN waitmode : UWORD,
    IN alertable : UWORD,
    IN timeout : ^RtlUquad,
    IN object : ^KepDispatchHeader,
) : OsStatus

    // Wait for a single object to enter a signaled state. A timeout
    // interval in milliseconds can be supplied. If it is NULLPTR, the timeout
    // is infinite.

    thread := KeCurrentThread ()

    singlewaitblock := &thread^.WaitBlocks[0]

    capturedtimeout : RtlUquad

    IF timeout THEN
        RtlMoveUquad (
            &capturedtimeout, // dest
            timeout, // src
        )
    END

    // Initialize all of the wait blocks now.
    // This isn't just to reduce time at KEP_IPL_DPC - if we initialize them
    // while enqueuing wait blocks to the objects, clearing the Flags field
    // is racey with other processors satisfying object waits.

    singlewaitblock^.Thread = thread
    singlewaitblock^.Object = object
    singlewaitblock^.WakeStatus = 0
    singlewaitblock^.Flags = 0

@Retry

    // Raise IPL to stop APCs from corrupting our wait state if they come in
    // and try to wait in our context.

    ipl := KepRaiseIpl ( KEP_IPL_DPC )

    KeAssert ( ipl < KEP_IPL_DPC )

    // Capture the start time.

    starttime : RtlUquad

    IF timeout THEN
        KepCaptureCurrentTicksFunc ( &starttime )
    END

    // The following function is a macro that can perform an early return.
    // It puts us in a WAIT_TRY state and raises IPL to KEP_IPL_DPC.

    status : OsStatus

    KepWaitHead (
        thread, // thread
        ipl, // ipl
        alertable, // alertable
        waitmode, // waitmode
        singlewaitblock, // waitblocktable
        1, // waitcount
        status, // status
    )

    timer : ^KeTimer

    KepAcquireObjectElevated ( object )

    IF object^.Type != KEP_DISPATCH_BALANCED_QUEUE THEN
        IF object^.SignalCount THEN
            // Already signaled. Our wait has been satisfied before it began.
            // If this isn't a notification event, consume the count.

            IF object^.Type != KEP_DISPATCH_EVENT_NOTIF THEN
                object^.SignalCount -= 1
            END

            KepReleaseObjectElevated ( object )

            KepSetWaitAttempt ( thread, KEP_THREAD_WAIT_NONE )

            KepLowerIpl ( ipl )

            RETURN 0
        END

        // Enqueue our wait block to the object, at the tail to promote
        // fairness.

        RtlInsertAtTailList (
            &object^.WaitListHead, // head
            &singlewaitblock^.Entry, // entry
        )

    ELSE
        // This is a balanced queue. If there's a pending item, grab it.

        queue := CONTAINEROF object TO KeBalancedQueue.Header

        IF NOT RtlEmptyList ( &queue^.ItemListHead ) AND
            queue^.ActiveThreadCount <= queue^.MaximumThreadCount THEN

            // Grab the item.

            item := queue^.ItemListHead.Next

            // Stash it in the thread object.

            thread^.QueueItem = item

            // Remove it from the list.

            RtlRemoveEntryList ( item )

            // Back out and return.

            KepReleaseObjectElevated ( object )

            KepSetWaitAttempt ( thread, KEP_THREAD_WAIT_NONE )

            KepLowerIpl ( ipl )

            RETURN 0
        END

        // Enqueue our wait block to the object, at the head to promote cache
        // affinity.

        RtlInsertAtHeadList (
            &object^.WaitListHead, // head
            &singlewaitblock^.Entry, // entry
        )
    END

    // Increment waiter count.

    KeAssert ( object^.WaiterCount != 0xFFFFFFFF )

    object^.WaiterCount += 1

    // Release the object lock.

    KepReleaseObjectElevated ( object )

    waitblock : ^KepWaitBlock

    IF timeout THEN
        // Start the timeout.
        // NOTE: The timer object and the timeout wait block have been
        //       initialized by KeuInitializeThread already.

        waitblock = &thread^.TimeoutWaitBlock
        timer = &thread^.Timeout

        // Insert the wait block in the timer's list.
        // This is safe to do without a lock because only we ever mess with
        // this timer in the context of this thread.

        RtlInsertAtTailList (
            &timer^.Header.WaitListHead, // head
            &waitblock^.Entry, // entry
        )

        timer^.Header.WaiterCount = 1

        // Enqueue the timer.

        KeEnqueueTimer (
            timer, // timer
            &capturedtimeout, // interval
            0, // context1
            0, // context2
        )
    END

    // If we're associated with a balanced queue, we have to indicate that we
    // are blocking so that someone else can be awoken. We have to do this
    // before acquiring the thread lock because of lock ordering.

    KepIndicateDeactivated ( thread )

    // If this is a KE_USER_MODE wait, and our kernel stack is swappable,
    // insert ourselves on the current processor's outswap candidate list.

    KepInsertSwapCandidateList ( thread, waitmode )

    // Lock our thread.

    KepAcquireThreadElevated ( thread )

#IF BLD_MP
    // Check if an interrupting event (such as the object being signaled, a user
    // APC, etc) from another processor aborted our wait while we were enqueuing
    // wait blocks.

    IF thread^.WaitAttempt == KEP_THREAD_WAIT_ABORTED THEN
        // It was aborted. We have to dequeue all our wait blocks and return.
        //
        // Release the thread lock so we don't violate the object->thread
        // lock ordering.

        KepReleaseThreadElevated ( thread )

        IF timeout THEN
            // We need to get rid of the timer.

            waitblock = &thread^.TimeoutWaitBlock
            timer = &thread^.Timeout

            // Dequeue it.

            KeDequeueTimer ( timer )

            // Remove the wait block.
            // We don't need the timer's object lock because we've been
            // nonpreemptible and blocking out the expiration DPC for this
            // processor since we enqueued it. Therefore it is still in our
            // custody.

            RtlRemoveEntryList ( &waitblock^.Entry )
        END

        // The guy who aborted the wait left our status in our thread struct.

        status = thread^.WaitStatus

        // Dequeue the single wait block.

        KepDequeueWaitBlock ( singlewaitblock )

        // Set to not waiting.

        KepSetWaitAttempt ( thread, KEP_THREAD_WAIT_NONE )

        // If we're associated with a balanced queue, we indicated that we were
        // deactivated. We have to undo that now.

        KepIndicateActive ( thread )

        // If we were placed on a list of kernel stack outswap candidates, we
        // have to remove ourselves.

        KepRemoveSwapCandidateList ( thread )

        KepLowerIpl ( ipl )

        IF status != OS_STATUS_KERNEL_APC THEN
            RETURN status
        END

        GOTO KernelApcReceived
    END

    thread^.WaitAttempt = KEP_THREAD_WAIT_COMMITTED
#END

    // The wait shall proceed.

    status = KepWaitThread (
        thread, // thread
        timeout, // hastimeout
    )

    KepLowerIpl ( ipl )

    // KepWaitThread returns with the thread lock released.
    // All of our wait blocks have been dequeued, timer dequeued, etc.

    IF status != OS_STATUS_KERNEL_APC THEN
        RETURN status
    END

@KernelApcReceived

    IF alertable == KE_CANCEL_ON_KAPC THEN
        RETURN status
    END

    IF timeout AND KepKernelApcReceived (
        &capturedtimeout, // timeout
        &starttime, // starttime
    ) THEN
        RETURN OS_STATUS_WAIT_TIMEOUT
    END

    GOTO Retry
END