#DEFINE KEP_TEST_THREADS 24
#DEFINE KEP_TEST_EVENTS 8

KepTestThreads : KeuThread[KEP_TEST_THREADS]
KepTestThreadsStacks : ULONG[512 * KEP_TEST_THREADS]
KepTestEvents : KeEvent[KEP_TEST_EVENTS]
KepTestSemaphore : KeSemaphore
KepTestQueue : KeBalancedQueue

PUBLIC KepTestPushlock : KeuPushlock

TestListHead : RtlListEntry
TestListItem1 : RtlListEntry
TestListItem2 : RtlListEntry
Item1Inserted : UBYTE
Item2Inserted : UBYTE

PUBLIC Counter := 0

FN (KeStartThreadF) KepTestThread (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

    objecttable : ^KepDispatchHeader[2]

    timeout : RtlUquad

    timeout.High = 0
    timeout.Low = 50 + context1 * 50

    i := context1 % KEP_TEST_EVENTS
    j := i + 1
    n := 0
    gork := 0

    item : ^RtlListEntry = NULLPTR

    WHILE TRUE DO
        IF j == KEP_TEST_EVENTS THEN
            n += 1
            j = 0
        END

        IF i >= KEP_TEST_EVENTS THEN
            i %= KEP_TEST_EVENTS
        END

        objecttable[0] = &KepTestEvents[i].Header
        objecttable[1] = &KepTestEvents[j].Header

        status : OsStatus

        IF n == 100 THEN
            spin := 0

            ipl := KepAcquireAnnounce ()

            KepReleaseAnnounce ( ipl )

            WHILE spin < 5000000 DO
                spin += 1
            END

            RtlPrint ( "D" )


#IF 0
            status = KeWaitForSingleObject (
                KE_KERNEL_MODE, // waitmode
                FALSE, // alertable
                NULLPTR, // timeout
                &KepTestSemaphore.Header, // object
            )
#END

            n = 0
        END

        IF j & 1 THEN
            status = KeWaitForObjects (
                KE_USER_MODE, // waitmode
                FALSE, // alertable
                &timeout, // timeout
                2, // objectcount
                &objecttable[0], // objecttable
                NULLPTR, // waitblocktable
            )

        ELSE
            status = KeWaitForSingleObject (
                KE_USER_MODE, // waitmode
                FALSE, // alertable
                &timeout, // timeout
                &KepTestEvents[i].Header, // object
            )

        END

        Counter = context1

        KeSignalEvent (
            &KepTestEvents[j], // event
            2, // priorityboost
        )

        ipl2 : UWORD

        IF context1 & 2 THEN
            ipl2 = KeuAcquireApcSafePushlockShared ( &KepTestPushlock )


        ELSE
            ipl2 = KeuAcquireApcSafePushlockExclusive ( &KepTestPushlock )

            IF context1 & 1 THEN
                Item1Inserted $= 1

                IF Item1Inserted THEN
                    RtlInsertAtTailList (
                        &TestListHead, // head
                        &TestListItem1, // entry
                    )

                ELSE
                    RtlRemoveEntryList ( &TestListItem1 )
                    TestListItem1.Next = NULLPTR
                    TestListItem1.Prev = NULLPTR
                END

            ELSE
                Item2Inserted $= 1

                IF Item2Inserted THEN
                    RtlInsertAtTailList (
                        &TestListHead, // head
                        &TestListItem2, // entry
                    )

                ELSE
                    RtlRemoveEntryList ( &TestListItem2 )
                    TestListItem2.Next = NULLPTR
                    TestListItem2.Prev = NULLPTR
                END
            END
        END

        IF KepCurrentIpl () != KEP_IPL_APC THEN
            KeCrash ( "Not APC\n" )
        END

        KeuReleaseApcSafePushlock ( &KepTestPushlock, ipl2 )

        IF KepCurrentIpl () != KEP_IPL_LOW THEN
            KeCrash ( "Not LOW\n" )
        END

        nexti := i + 1

        IF nexti >= KEP_TEST_EVENTS THEN
            nexti %= KEP_TEST_EVENTS
        END

        KeSignalEvent (
            &KepTestEvents[nexti], // event
            3, // priorityboost
        )

        i += 2
        j += 1
    END
END

FN (KeStartThreadF) KepTestThreadPinning (
    IN context1 : UWORD,
    IN context2 : UWORD,
)


    interval : RtlUquad
    interval.High = 0
    interval.Low = 10000

    testquad : RtlUquad
    testquad.High = 0xF
    testquad.Low = 0

    testquad2 : RtlUquad
    testquad2.High = 0x1
    testquad2.Low = 0x1

    RtlPrint ( "Sleep %p  ", KeCurrentThread () )

    KeSleep (
        &interval, // interval
        KE_USER_MODE, // waitmode
        FALSE, // alertable
    )

    RtlPrint ( "Woke " )

    testitem1 : RtlListEntry
    testitem2 : RtlListEntry
    testitem3 : RtlListEntry
    testitem4 : RtlListEntry

    KeInsertIntoBalancedQueue (
        &KepTestQueue, // queue
        &testitem1, // item
        FALSE, // head
        0, // priorityboost
    )

    KeInsertIntoBalancedQueue (
        &KepTestQueue, // queue
        &testitem2, // item
        FALSE, // head
        0, // priorityboost
    )

    KeInsertIntoBalancedQueue (
        &KepTestQueue, // queue
        &testitem3, // item
        FALSE, // head
        0, // priorityboost
    )

    KeInsertIntoBalancedQueue (
        &KepTestQueue, // queue
        &testitem4, // item
        FALSE, // head
        0, // priorityboost
    )

    i := 0

    WHILE TRUE DO
        KeSleep (
            &interval, // interval
            KE_USER_MODE, // waitmode
            FALSE, // alertable
        )

        RtlPrint ( "Woke " )

        IF i THEN
            RtlPrint ( "LOWER" )
            KepLowerIpl ( KEP_IPL_LOW )

        ELSE
            RtlPrint ( "RAISE" )
            KepRaiseIpl ( KEP_IPL_APC )

            q := 0

            WHILE q < 10000000 DO
                q += 1
            END

            RtlPrint ( "Q" )
        END

        i $= 1
    END
END

FN (KeApcF) KepTestApcFunction (
    IN apc : ^KeApc,
    IN context1 : UWORD,
    IN context2 : UWORD,
    IN rundown : UWORD,
)

    thread := KeCurrentThread ()

    RtlPrint ( "P%p ", thread )
END

FN (KeStartThreadF) KepTestThreadApc (
    IN context1 : UWORD,
    IN context2 : UWORD,
)


    interval : RtlUquad
    interval.High = 0
    interval.Low = 4000

    apc : KeApc

     (
        &apc, // apc
        &KepTestApcFunction, // func
        KE_APC_KERNEL, // type
        &KepTestThreads[0], // thread
    )

    WHILE TRUE DO
        KeSleep (
            &interval, // interval
            KE_USER_MODE, // waitmode
            FALSE, // alertable
        )

        stat := KeEnqueueKapc (
            &apc, // apc
            0, // priorityboost
            0, // context1
            0, // context2
        )
        
        RtlPrint ( "Enq%u ", stat )
    END
END

FN KepInitializeTest ()

    prb := KEP_CURRENT_PRB

    IF prb^.Id == 0 THEN
        KeuInitializePushlock ( &KepTestPushlock )

        RtlInitializeList ( &TestListHead )

        KeInitializeSemaphore (
            &KepTestSemaphore, // semaphore
            "TestSemaphore", // name
            0, // initialcount
        )

        KeInitializeBalancedQueue (
            &KepTestQueue, // queue
            "TestQueue", // name
            2, // maxthreads
        )

        ipl := KepRaiseIpl ( KEP_IPL_DPC )

        KeuInitializeThread (
            &KeuIdleProcess, // process
            &KepTestThreads[0], // thread
            "TestThread", // name
            &KepTestThreadsStacks[0], // kstack
            2048, // kstacksize
            &KepTestThreadPinning, // startfunc
            0, // context1
            0, // context2
        )

        KeuInitializeThread (
            &KeuIdleProcess, // process
            &KepTestThreads[1], // thread
            "TestThread", // name
            &KepTestThreadsStacks[512], // kstack
            2048, // kstacksize
            &KepTestThreadApc, // startfunc
            0, // context1
            0, // context2
        )

        i := 0

        WHILE i < KEP_TEST_EVENTS DO
            KeInitializeEvent (
                &KepTestEvents[i], // event
                "TestEvent", // name
                FALSE, // notification
                0, // signalstate
            )

            i += 1
        END

        i = 2

        WHILE i < KEP_TEST_THREADS DO
            KeuInitializeThread (
                &KeuIdleProcess, // process
                &KepTestThreads[i], // thread
                "TestThread", // name
                &KepTestThreadsStacks[512 * i], // kstack
                2048, // kstacksize
                &KepTestThread, // startfunc
                i, // context1
                0, // context2
            )

            i += 1
        END

        i = 0

        WHILE i < KEP_TEST_THREADS DO
            KepReadyThread ( &KepTestThreads[i] )

            i += 1
        END

        KepLowerIpl ( ipl )
    END
END