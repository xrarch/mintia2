//
// Implements support for APC objects.
//

#INCLUDE "Kep.hjk"

// APCs are functions that can be targeted to run in the context of a particular
// arbitrary thread.
//
// There are three kinds of APCs.
//
// Kernel APCs: KAPCs are dispatched whenever IPL is below KEP_IPL_APC for the
//              thread. They can take page faults and can acquire locks that
//              are designed to be KAPC-acquirable (i.e. they're only ever taken
//              with the KeuAcquireApcLock family of routines, which
//              automatically raise and lower IPL appropriately).
//
// Lazy APCs:   LAPCs are dispatched whenever a thread is executing in usermode,
//              upon return to usermode from the kernel, and whenever the thread
//              takes a KE_USER_MODE wait. They can take page faults and can
//              acquire (almost) any lock, since a KE_USER_MODE waiter is
//              guaranteed not to be holding the vast majority of internal locks
//              at wait time.
//
// User APCs:   UAPCs are special as they cause code to be executed in usermode
//              instead of kernel mode. They are dispatched only when the kernel
//              takes a KE_USER_MODE wait, upon which time they cause an early
//              exit from the current system service with an OS_STATUS_USER_APC
//              return value. The thread then executes a callback in usermode
//              before returning to the caller of the system service.

EXPORT FN KeInitializeApc (
    IN apc : ^KeApc,
    IN func : KeApcF,
    IN type : UWORD,
    IN thread : ^KeuThread,
)

    apc^.Function = func
    apc^.Type = type
    apc^.Thread = thread
    apc^.Enqueued = FALSE
END

EXPORT FN KeEnqueueKapc (
    IN apc : ^KeApc,
    IN priorityboost : UWORD,
    IN context1 : UWORD,
    IN context2 : UWORD,
) : UWORD

    // Enqueue the kernel APC to its thread.
    // Return TRUE if enqueued, FALSE otherwise.

    KeAssert ( apc^.Type == KE_APC_KERNEL )

    thread := apc^.Thread

    // Acquire the thread.

    ipl := KepAcquireThread ( thread )

    IF apc^.Enqueued THEN
        // Already enqueued.

        KepReleaseThread ( thread, ipl )

        RETURN FALSE
    END

    // Add the APC to the list.

    RtlInsertAtTailList (
        &thread^.KapcListHead, // head
        &apc^.Entry, // entry
    )

    thread^.PendingEventsSet |= KEP_THREAD_PENDING_KAPC

    apc^.Enqueued = TRUE

    apc^.Context1 = context1
    apc^.Context2 = context2

    IF thread^.Status == KE_THREAD_RUNNING THEN
        // Need to trigger an APC interrupt.

        // Acquire a pointer to the current Prb.

        prb := KEP_CURRENT_PRB

#IF BLD_MP
        IF thread^.WaitAttempt == KEP_THREAD_WAIT_TRY AND
            (thread^.WaitIpl == KEP_IPL_LOW OR
            thread^.Alertable == KE_CANCEL_ON_KAPC) THEN

            // Abort the wait attempt.

            KepUnwaitThread (
                thread, // thread,
                OS_STATUS_KERNEL_APC, // status
                priorityboost, // priorityboost
            )
        END

        IF thread^.CurrentPrb != prb THEN
            // Trigger on the target processor.

            KepSoftInterruptOther (
                thread^.CurrentPrb, // targetprb
                KEP_IPL_APC, // ipl
            )

        ELSE
#END
            // Trigger on the current processor.

            KepSoftInterruptSelf (
                prb, // targetprb
                KEP_IPL_APC, // ipl
            )
#IF BLD_MP
        END
#END

    ELSEIF thread^.Status == KE_THREAD_WAITING AND
        (thread^.WaitIpl == KEP_IPL_LOW OR
        thread^.Alertable == KE_CANCEL_ON_KAPC) THEN

        // Wake the thread.

        KepUnwaitThread (
            thread, // thread,
            OS_STATUS_KERNEL_APC, // status
            priorityboost, // priorityboost
        )
    END

    KepReleaseThread ( thread, ipl )

    RETURN TRUE
END

EXPORT FN KeEnqueueUapc (
    IN apc : ^KeApc,
    IN priorityboost : UWORD,
    IN context1 : UWORD,
    IN context2 : UWORD,
) : UWORD

    // Enqueue the user APC to its thread.
    // Return TRUE if enqueued, FALSE otherwise.

    thread := apc^.Thread

    KeAssert ( apc^.Type == KE_APC_USER )

    // Acquire the thread.

    ipl := KepAcquireThread ( thread )

    IF apc^.Enqueued THEN
        // Already enqueued.

        KepReleaseThread ( thread, ipl )

        RETURN FALSE
    END

    // Add the APC to the list.

    RtlInsertAtTailList (
        &thread^.UapcListHead, // head
        &apc^.Entry, // entry
    )

    thread^.PendingEventsSet |= KEP_THREAD_PENDING_UAPC

    apc^.Enqueued = TRUE

    apc^.Context1 = context1
    apc^.Context2 = context2

    IF (thread^.Status == KE_THREAD_WAITING
#IF BLD_MP
        OR (thread^.Status == KE_THREAD_RUNNING AND
        thread^.WaitAttempt == KEP_THREAD_WAIT_TRY)
#END
        ) AND thread^.WaitIpl == KEP_IPL_LOW AND
        thread^.WaitMode == KE_USER_MODE AND
        thread^.Alertable == KE_ALERTABLE THEN

        // The thread was in a usermode alertable wait, so trigger user APC
        // delivery.

        thread^.UserApcTriggered = TRUE
        thread^.UserInterrupt = TRUE

        // Wake the thread.

        KepUnwaitThread (
            thread, // thread,
            OS_STATUS_USER_APC, // status
            priorityboost, // priorityboost
        )
    END

    KepReleaseThread ( thread, ipl )

    RETURN TRUE
END

EXPORT FN KeEnqueueLapc (
    IN apc : ^KeApc,
    IN priorityboost : UWORD,
    IN context1 : UWORD,
    IN context2 : UWORD,
) : UWORD

    // Enqueue the lazy APC to its thread.
    // Return TRUE if enqueued, FALSE otherwise.

    KeAssert ( apc^.Type == KE_APC_LAZY )

    thread := apc^.Thread

    // Acquire the thread.

    ipl := KepAcquireThread ( thread )

    IF apc^.Enqueued THEN
        // Already enqueued.

        KepReleaseThread ( thread, ipl )

        RETURN FALSE
    END

    // Add the APC to the list.

    RtlInsertAtTailList (
        &thread^.LapcListHead, // head
        &apc^.Entry, // entry
    )

    thread^.PendingEventsSet |= KEP_THREAD_PENDING_LAPC

    apc^.Enqueued = TRUE

    apc^.Context1 = context1
    apc^.Context2 = context2

    // Set user interrupt pending to make sure the thread checks his lazy APC
    // queue on the way back out to usermode.

    thread^.UserInterrupt = TRUE

    IF (thread^.Status == KE_THREAD_WAITING
#IF BLD_MP
        OR (thread^.Status == KE_THREAD_RUNNING AND
        thread^.WaitAttempt == KEP_THREAD_WAIT_TRY)
#END
        ) AND thread^.WaitIpl == KEP_IPL_LOW AND
        thread^.WaitMode == KE_USER_MODE THEN

        // The thread was in a usermode wait, so wake him up with a kernel APC
        // status so that he tries to wait again and dispatches his lazy APC
        // queue at that time.

        KepUnwaitThread (
            thread, // thread,
            OS_STATUS_KERNEL_APC, // status
            priorityboost, // priorityboost
        )

#IF BLD_MP
    ELSEIF thread^.Status == KE_THREAD_RUNNING AND
        thread^.CurrentMode == KE_USER_MODE THEN

        KeMemoryBarrier ()

        // The thread is running in usermode on another processor. Cause an IPI
        // to get him to check his lazy APC queue.

        HaluTriggerIpi (
            thread^.CurrentPrb, // target
            KEP_IPI_ASYNCHRONOUS, // type
        )
#END
    END

    KepReleaseThread ( thread, ipl )

    RETURN TRUE
END

EXPORT FN KeDequeueApc (
    IN apc : ^KeApc,
) : UWORD

    // Dequeue an APC of any type and return whether it was dequeued or not.

    thread := apc^.Thread

    // Acquire the APC queue.

    ipl := KepAcquireThread ( thread )

    enqueued := apc^.Enqueued

    IF enqueued THEN
        // Remove from the appropriate list.

        RtlRemoveEntryList ( &apc^.Entry )

        apc^.Enqueued = FALSE
    END

    // Release APC queue.

    KepReleaseThread ( thread, ipl )

    RETURN enqueued
END

FN KepDispatchKernelModeApcs (
    IN thread : ^KeuThread,
    IN head : ^RtlListEntry,
    IN pendingbit : UWORD,
)

    // Dispatch the kernel mode APCs on the given list.

    // Pop items from the list until it's emptied.

    WHILE TRUE DO
        ipl := KepAcquireThread ( thread )

        listentry := head^.Next

        IF listentry == head THEN
            // Queue's empty.

            thread^.PendingEventsSet &= ~pendingbit

            KepReleaseThread ( thread, ipl )

            BREAK
        END

        apc := CONTAINEROF listentry TO KeApc.Entry

        // Remove from the list.

        RtlRemoveEntryList ( listentry )

        // Capture the context before unlocking the queue, or the APC could get
        // re-enqueued again from an interrupt or another processor, destroying
        // the context.

        context1 := apc^.Context1
        context2 := apc^.Context2

        // Set dequeued.

        apc^.Enqueued = FALSE

        // Unlock the queue.

        KepReleaseThread ( thread, ipl )

        // Call the APC function.

        apc^.Function (
            apc, // apc
            context1, // context1
            context2, // context2
            FALSE, // rundown
        )
    END
END

FN KepDispatchKernelApcQueue (
    IN current : ^KeuThread,
)

    // Here we have to dispatch kernel APCs. We are in the context of the
    // current thread at KEP_IPL_APC.

    KeAssert ( KepCurrentIpl () == KEP_IPL_APC )

    // Dispatch the APCs.

    current^.ExecutingKapc = TRUE

    KepDispatchKernelModeApcs (
        current, // thread
        &current^.KapcListHead, // head
        KEP_THREAD_PENDING_KAPC, // pendingbit
    )

    current^.ExecutingKapc = FALSE
END

FN KepDispatchLazyApcQueue (
    IN current : ^KeuThread,
)

    // Dispatch the lazy APC queue. This is called upon an attempt to perform a
    // KE_USER_MODE wait, and upon a return to userspace with pending lazy APCs.
    // We are in the context of the current thread at KEP_IPL_LOW.

    KeAssert ( KepCurrentIpl () == KEP_IPL_LOW )

    KepDispatchKernelModeApcs (
        current, // thread
        &current^.LapcListHead, // head
        KEP_THREAD_PENDING_LAPC, // pendingbit
    )
END

FN KepDispatchUserApcQueue (
    IN current : ^KeuThread,
)

    // Dispatch the user APC queue. This is called upon return to usermode after
    // an attempt to perform an alertable KE_USER_MODE wait. We are in the
    // context of the current thread at KEP_IPL_LOW.

    ipl := KepAcquireThread ( current )

    IF RtlEmptyList ( &current^.UapcListHead ) THEN
        // None to dispatch.

        current^.PendingEventsSet &= ~KEP_THREAD_PENDING_UAPC

        KepReleaseThread ( current, ipl )

        LEAVE
    END

    listentry := current^.UapcListHead.Next

    // Remove the user APC from the queue.

    RtlRemoveEntryList ( listentry )

    apc := CONTAINEROF listentry TO KeApc.Entry

    // Capture the context before unlocking the queue, or the APC could get
    // re-enqueued again from an interrupt or another processor, destroying
    // the context.

    context1 := apc^.Context1
    context2 := apc^.Context2

    // Set dequeued.

    apc^.Enqueued = FALSE

    // Unlock the queue.

    KepReleaseThread ( current, ipl )

    // Call the kernel function. It will probably free the APC structure, so we
    // can't touch it after this.

    apc^.Function (
        apc, // apc
        context1, // context1
        context2, // context2
        FALSE, // rundown
    )

    // Dispatch the APC in usermode.

    KepInterruptUsermode (
        KeuUexecApcDispatcher, // dispatchfunc
        current^.UserFrame, // trapframe
        context1, // userfunc
        context2, // context
        current, // thread
    )
END

FN KeAreApcsDeliverable () : UWORD

    // Return whether APCs are deliverable.

    RETURN KepCurrentIpl () == KEP_IPL_LOW
END