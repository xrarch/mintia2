//
// Implementation of lithobraking for the MINTIA Executive.
//

#INCLUDE "Kep.hjk"

#IF BLD_MP

KepLinePrintSpinlock : KepSpinlock = KEP_INITIAL_SPINLOCK

#END

EXPORT KeuDebuggerEntry : KeuDebuggerEntryF

KepCrashVerticalListHead : RtlListEntry
KepCrashHorizListHead : RtlListEntry
KepCrashCallbackListHead : RtlListEntry

KepCrashModuleListCallback : KeCrashCallback

KepCrashGate : ULONG = 0

KepRemainingRows : UINT = 0
KepRemainingColumns : UINT = 0
KepColumns : UINT = 0
KepResetX : UINT = 0
KepNextRow : UINT = 0
KepCrashVerticalCount : UINT = 0
KepCrashHorizCount : UINT = 0
KepCrashPrints : UBYTE = FALSE

#DEFINE PLATFORM_FULL_NAME_STR (
    STRCAT ( STRCAT "\"" PLATFORM_FULL_NAME ) "\""
)

FN KepCrashPutCharacter (
    IN byte : UBYTE,
)

    IF NOT KepRemainingRows THEN
        LEAVE
    END

    HaluPutCharacter ( byte )

    next := FALSE

    IF byte == '\n' THEN
        next = TRUE
    ELSE
        KepRemainingColumns -= 1

        IF KepRemainingColumns == 0 THEN
            next = TRUE
        END
    END

    IF next THEN
        KepRemainingRows -= 1
        KepRemainingColumns = KepColumns
        KepNextRow += 1

        HaluSetConsolePosition ( KepResetX, KepNextRow )
    END
END

FN (RtlPrintCallbackF) RtljPrintCallback (
    IN byte : UBYTE,
    IN context : ^VOID,
)

    IF KepCrashPrints THEN
        KepCrashPutCharacter ( byte )
    ELSE
        HaluPutCharacter ( byte )
    END
END

FN RtljLockStream (
    IN handle : ^VOID,
) : UWORD

    // Called by RTL before it prints a line.

    lockcontext := KepDisableInterrupts ()

#IF BLD_MP
    // Only try 50000 times to acquire the spinlock in case it's jammed shut.
    // Note that KepTryAcquireSpinlock is already written to spin for a while
    // before giving up, so this is really 50000 * 128 attempts or however many.

@Retry

    i := 50000

    WHILE i DO
        IF KepTryAcquireSpinlock ( &KepLinePrintSpinlock ) THEN
            BREAK
        END

        i -= 1
    END

    IF NOT i THEN
        // Force it open.
        //
        // The HAL console should have its own, smaller locks that guard the
        // mechanisms of its console implementation. This spinlock is just to
        // guarantee atomicity of line printing. So this (by itself) should be
        // harmless.

        KepForceReleaseSpinlock ( &KepLinePrintSpinlock )

        // Retry.

        GOTO Retry
    END
#END

    RETURN lockcontext
END

FN RtljUnlockStream (
    IN handle : ^VOID,
    IN lockcontext : UWORD,
)

    // Called by RTL after it prints a line.

#IF BLD_MP
    KepReleaseSpinlock ( &KepLinePrintSpinlock )
#END

    KepRestoreInterrupts ( lockcontext )
END

FN (KeCrashCallbackF) KepCrashModuleListFunc (
    IN columns : UWORD,
)

#IF ( == BLD_BITS 64 )
    infocols := columns / 48
#ELSE
    infocols := columns / 40
#END

    i := infocols

    WHILE i DO
#IF ( == BLD_BITS 64 )
        RtlPrint ( "DLL Base         TimeStmp Name                 " )
#ELSE
        RtlPrint ( "DLL Base TimeStmp Name                 " )
#END

        i -= 1
    END

    RtlPrint ( "\n" )

    listhead := &KeuLoaderBlock.DllListHead
    listentry := listhead^.Next
    i = 0

    WHILE listentry != listhead DO
        dll := CONTAINEROF listentry TO BlDll.Entry

        IF i >= infocols THEN
            RtlPrint ( "\n" )
            i = 0
        END

        RtlPrint (
            "%p %08x %-20s ", // fmt
            dll^.Base,
            dll^.Timestamp,
            RtlGetFileName ( &dll^.Name[0] ),
        )

        i += 1

        listentry = listentry^.Next
    END

    RtlPrint ( "\n" )
END

#SECTION "INITtext"
FN KepInitializeCrashing ()

    // Initialize the list heads.

    RtlInitializeList ( &KepCrashVerticalListHead )
    RtlInitializeList ( &KepCrashHorizListHead )
    RtlInitializeList ( &KepCrashCallbackListHead )

    // Now initialize the standard callbacks.

    KeRegisterCrashCallback (
        &KepCrashModuleListCallback, // callback
        &KepCrashModuleListFunc, // function
        TRUE, // doesprint
        TRUE, // horizontal
    )
END

FN KepDoCrashPrints (
    IN width : UWORD,
    IN height : UWORD,
    IN fmt : ^UBYTE,
    IN argv : ^^VOID,
    IN argc : UWORD,
)

    RtlPrint ( "\n" )

    HaluSetConsolePosition ( 0, 0 )

    procname := "?"
    thrdname := "?"
    attprocname := "?"

    prb := KEP_CURRENT_PRB

    IF prb^.CurrentThread THEN
        thrdname = &prb^.CurrentThread^.Name[0]
        procname = &prb^.CurrentThread^.ActualProcess^.Name[0]

        IF prb^.CurrentThread^.ActualProcess != prb^.CurrentThread^.Process THEN
            attprocname = &prb^.CurrentThread^.Process^.Name[0]
        ELSE
            attprocname = "N/A"
        END
    END

    RtlPrint (
        "%s BL=%u IPL=%u CPU=%u [%s, %s, %s]\n",
        PLATFORM_FULL_NAME_STR,
        BLD_BASE_LEVEL,
        prb^.Ipl,
        prb^.Id,
        procname,
        thrdname,
        attprocname,
    )

    RtlPrint ( "*** STOP: " )

    RtlPrintByVarTable (
        NULLPTR, // handle
        fmt, // fmt
        argv, // argv
        argc, // argc
    )

    x : UWORD
    y : UWORD

    HaluQueryConsolePosition (
        OUT x, // x
        OUT y, // y
    )

    // Call all of the horizontally printing callbacks.
    // These each get a horizontal section of the console that they can greedily
    // consume.

    KepCrashPrints = TRUE

    KepColumns = width
    KepRemainingColumns = KepColumns
    KepResetX = 0
    KepRemainingRows = height - y - 4

    callback : ^KeCrashCallback

    listhead := &KepCrashHorizListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        callback = CONTAINEROF listentry TO KeCrashCallback.Entry

        HaluQueryConsolePosition (
            OUT x, // x
            OUT y, // y
        )

        KepRemainingColumns = KepColumns
        KepRemainingRows = height - y - 4
        KepNextRow = y + 1

        HaluSetConsolePosition (
            0, // x
            KepNextRow, // y
        )

        callback^.Function ( KepColumns )

        IF NOT KepRemainingRows THEN
            BREAK
        END

        listentry = listentry^.Next
    END

    IF KepRemainingRows AND KepCrashVerticalCount THEN
        // Call each callback. They each get a column of the console.

        HaluQueryConsolePosition (
            OUT x, // x
            OUT y, // y
        )

        resetrows := height - y - 4

        colwidth := width / KepCrashVerticalCount

        IF KepCrashVerticalCount != 1 THEN
            colwidth -= 1
        END

        KepColumns = colwidth

        listhead = &KepCrashVerticalListHead
        listentry = listhead^.Next

        WHILE listentry != listhead DO
            callback = CONTAINEROF listentry TO KeCrashCallback.Entry

            KepRemainingRows = resetrows
            KepRemainingColumns = colwidth
            KepNextRow = y + 1

            HaluSetConsolePosition (
                KepResetX, // x
                KepNextRow, // y
            )

            callback^.Function ( colwidth )

            KepResetX += colwidth + 1

            listentry = listentry^.Next
        END
    END

    KepCrashPrints = FALSE

    HaluSetConsolePosition ( 0, height - 2 )

    HaluCenterPrint (
        "An error occurred! Please take a screenshot and report the issue.\n",
    )

    HaluCenterPrint (
        "The repository can be found at http://www.github.com/xrarch/mintia2.",
    )

    HaluSetConsolePosition ( 0, 0 )
END

EXPORT FN KeCrash (
    IN fmt : ^UBYTE,
    ... argv argc
)

    // Disable interrupts ASAP.

    KepDisableInterrupts ()

    // Only one processor should get through the crash gate.
    // Implement this with an atomic increment.
    // This is compiled in on UP builds too since it also catches nested entries
    // into KeCrash.

    oldvalue := KeIncrementUlong ( &KepCrashGate, 1 )

    IF oldvalue THEN
        // We weren't the first. Complain and hang forever.

        RtlPrint (
            "KeCrash: Nested on %u: \n", // fmt
            KepCurrentProcessor (),
        )

        RtlPrintByVarTable (
            NULLPTR, // handle
            fmt, // fmt
            argv, // argv
            argc, // argc
        )

        WHILE TRUE DO
            KepWaitForInterrupt ()
        END
    END

    // We are now the official "crash processor". We are responsible for dumping
    // info to the screen.

#IF BLD_MP
    // Bring other processors to a halt. This may time out, such as if another
    // processor crashed simultaneously and didn't make it through the gate.
    // In any case, we just proceed.

    KepFreezeOtherProcessors ()
#END

    // Call all the non-printing callbacks.

    listhead := &KepCrashCallbackListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        callback := CONTAINEROF listentry TO KeCrashCallback.Entry

        callback^.Function ( 0 )

        listentry = listentry^.Next
    END

    // Call the HAL to do stuff with the console to make the crash visible to
    // the user.

    HaluCrashConsole ()

    width : UWORD
    height : UWORD

    HaluQueryConsoleSize (
        OUT width, // width
        OUT height, // height
    )

    IF width >= 80 AND height >= 24 THEN
        KepDoCrashPrints (
            width, // width
            height, // height
            fmt, // fmt
            argv, // argv
            argc, // argc
        )
    END

    // If there's a debugger, call it. Otherwise, do nothing forever.

    IF KeuDebuggerEntry THEN
        KeBreakpoint ()
    END

    WHILE TRUE DO
        KepWaitForInterrupt ()
    END
END

#SECTION "INITtext"
EXPORT FN KeRegisterCrashCallback (
    IN callback : ^KeCrashCallback,
    IN callbackfunc : KeCrashCallbackF,
    IN doesprint : UWORD,
    IN horizontal : UWORD,
)

    // Assumes being called from single-threaded context at boot time. Uses no
    // synchronization.

    callback^.Function = callbackfunc

    IF doesprint THEN
        IF horizontal THEN
            RtlInsertAtTailList (
                &KepCrashHorizListHead, // head
                &callback^.Entry, // entry
            )

            KepCrashHorizCount += 1

        ELSE
            RtlInsertAtTailList (
                &KepCrashVerticalListHead, // head
                &callback^.Entry, // entry
            )

            KepCrashVerticalCount += 1
        END

    ELSE
        RtlInsertAtTailList (
            &KepCrashCallbackListHead, // head
            &callback^.Entry, // entry
        )
    END
END