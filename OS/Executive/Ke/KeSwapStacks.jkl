//
// Implements the mechanisms for opportunistic kernel stack swapping.
//

#INCLUDE "Ki.hjk"

KiStackSwapListHead : ^KeThread = NULLPTR
KiProcessSwapListHead : ^KeProcess = NULLPTR
KiProcessOutSwapListHead : ^KeProcess = NULLPTR

PUBLIC KeStackSwapperEvent : KeEvent

#IF BLD_MP

#MACRO KiAcquireCandidateListElevated ( prb ) [
    KiAcquireSpinlock ( &(prb)^.StackSwapListLock )
]

#MACRO KiReleaseCandidateListElevated ( prb ) [
    KiReleaseSpinlock ( &(prb)^.StackSwapListLock )
]

#MACRO KiAcquireCandidateList ( prb ) [
    KiAcquireSpinlockRaise ( &(prb)^.StackSwapListLock )
]

#MACRO KiReleaseCandidateList ( prb, ipl ) [
    KiReleaseSpinlockLower ( &(prb)^.StackSwapListLock, ipl )
]

#ELSE

#MACRO KiAcquireCandidateListElevated ( prb ) []

#MACRO KiReleaseCandidateListElevated ( prb ) []

#MACRO KiAcquireCandidateList ( prb ) [
    KiRaiseIpl ( KI_IPL_DPC )
]

#MACRO KiReleaseCandidateList ( prb, ipl ) [
    KiLowerIpl ( ipl )
]

#END

FN KeReadyInswappedThread (
    IN thread : ^KeThread,
)

    // Called by the stack swapper thread when it has inswapped a kernel stack
    // and wants to re-ready the thread.

#IF BLD_CHK
    IF NOT thread^.InSwapList THEN
        KeCrash ( "KeReadyInswappedThread: wasn't in swap list\n" )
    END

    IF thread^.Process^.MemoryState != KI_PROCESS_RESIDENT THEN
        KeCrash ( "KeReadyInswappedThread: process not resident\n" )
    END
#END

    ipl := KiAcquireThread ( thread )

    thread^.InSwapList = FALSE
    thread^.KernelStackResident = TRUE

    KiReadyThread ( thread )

    KiReleaseThread ( thread, ipl )
END

FN KeReadyInswappedProcess (
    IN process : ^KeProcess,
)

    // Called by the stack swapper thread when it has inswapped a process and
    // wants to set it RESIDENT and ready any deferred threads.

    ipl := KiAcquireSwapState ( process )

#IF BLD_CHK
    IF process^.MemoryState != KI_PROCESS_TRANSITION THEN
        KeCrash ( "KeReadyInswappedProcess: not in transition\n" )
    END
#END

    process^.MemoryState = KI_PROCESS_RESIDENT

    thread := process^.SwapListHead
    process^.SwapListHead = NULLPTR

    KiReleaseSwapState ( process, ipl )

    // Now ready all the threads. Threads whose kernel stacks were swapped out
    // will get placed back on a queue and we'll see them later.

    WHILE thread DO
        nextthread := thread^.SwapNext

        ipl = KiAcquireThread ( thread )

        KiReadyThread ( thread )

        KiReleaseThread ( thread, ipl )

        thread = nextthread
    END
END

FN KeFlushThreadInSwapQueue () : ^KeThread

    // Atomically detaches the current contents of the thread stack swap list
    // and returns the head item of a singly linked list. If it was empty,
    // NULLPTR is returned.
    // Atomically fetch-and-set the head to NULLPTR.

    RETURN CAST KeFetchAndSetPtr (
        &KiStackSwapListHead, // ptr
        NULLPTR, // newvalue
    ) TO ^KeThread
END

FN KeFlushProcessInSwapQueue () : ^KeProcess

    // Atomically detaches the current contents of the process swap list
    // and returns the head item of a singly linked list. If it was empty,
    // NULLPTR is returned.

    RETURN CAST KeFetchAndSetPtr (
        &KiProcessSwapListHead, // ptr
        NULLPTR, // newvalue
    ) TO ^KeProcess
END

FN KeFlushProcessOutSwapQueue () : ^KeProcess

    // Atomically detaches the current contents of the process outswap list
    // and returns the head item of a singly linked list. If it was empty,
    // NULLPTR is returned.

    head := CAST KeFetchAndSetPtr (
        &KiProcessOutSwapListHead, // ptr
        NULLPTR, // newvalue
    ) TO ^KeProcess

    // These processes are no longer in TRANSITION, so walk them and set them
    // all OUTSWAPPED.

    process := head
    last : ^KeProcess = NULLPTR

    WHILE process DO
        nextprocess := process^.SwapNext

        ipl := KiAcquireSwapState ( process )

        hadthreads := process^.SwapListHead

        IF NOT hadthreads THEN
            process^.MemoryState = KI_PROCESS_OUTSWAPPED
        END

        KiReleaseSwapState ( process, ipl )

        IF hadthreads THEN
            // Threads were enqueued to the process while it was in TRANSITION.
            
            // Remove it from the singly linked list by setting the last's next
            // to our next.

            IF last THEN
                last^.SwapNext = nextprocess

            ELSE
                head = nextprocess
            END

            // Set it RESIDENT and ready the deferred threads.

            KeReadyInswappedProcess ( process )

        ELSE
            last = process
        END

        process = nextprocess
    END

    RETURN head
END

FN KeHarvestSwapCandidates (
    IN procid : UWORD,
) : ^KeThread

    // Scans the kernel stack swap candidate list for the given processor, marks
    // any eligible threads outswapped, and returns the head item of a singly
    // linked list of outswapped threads to process. If none, NULLPTR is
    // returned.

    head : ^KeThread = NULLPTR

    prb := KiPrbFromNumber ( procid )

    listhead := &prb^.StackSwapCandidateListHead

    ipl := KiAcquireCandidateList ( prb )

    tick := KiLowTick ()

    listentry := listhead^.Next

    WHILE listentry != listhead DO
        thread := CONTAINEROF listentry TO KeThread.WaitEntry

        // Capture the next link now since we may be about to corrupt it.

        listentry = listentry^.Next

        // Lock the thread.

        KiAcquireThreadElevated ( thread )

        IF thread^.Status == KI_THREAD_WAITING THEN
            // The thread is WAITING which means we may be able to outswap its
            // stack.

#IF BLD_CHK
            IF thread^.WaitMode != KE_USER_MODE THEN
                KeCrash ( "KeHarvestSwapCandidates: found kernelmode waiter\n" )
            END
#END

            IF tick - thread^.StateMs < KI_STACK_SWAP_INTERVAL_MS THEN
                // This thread has been waiting for less time than the required
                // interval. No more threads after it will be eligible either,
                // so break out of the loop.

                KiReleaseThreadElevated ( thread )

                BREAK
            END

            // Remove the thread from the candidate list.

            RtlRemoveEntryList ( &thread^.WaitEntry )

            thread^.SwapCandidatePrb = NULLPTR

            IF thread^.KernelStackSwappable THEN
                // This thread is eligible.
                // Mark the thread's kernel stack outswapped; attempts to ready
                // this thread after we unlock it will cause it to be enqueued
                // to the stack swapper thread (which should be the thread we
                // are currently executing in right now).

                thread^.KernelStackResident = FALSE

                // Add to the singly linked list, which we thread through the
                // WaitEntry. It should not be possible for the thread to be
                // re-enqueued to a candidate list while it is on this singly
                // linked list (the custody of the swapper thread). We can't
                // reuse the SwapNext list link because it may come into use
                // concurrently if this thread is readied while it is being
                // outswapped.

                thread^.WaitEntry.Next = CAST head TO ^VOID
                head = thread

                // Decrement the resident stack count of the process.

                process := thread^.Process

                KiAcquireSwapStateElevated ( process )

                oldcount := process^.ResidentThreadCount

#IF BLD_CHK
                IF oldcount == 0 THEN
                    KeCrash ( "KeHarvestSwapCandidates: underflow\n" )
                END

                IF process^.MemoryState != KI_PROCESS_RESIDENT THEN
                    KeCrash ( "KeHarvestSwapCandidates: not resident\n" )
                END
#END

                process^.ResidentThreadCount = oldcount - 1

                IF oldcount == 1 THEN
                    // This was the last resident stack in the process, so mark
                    // the process in-transition and place it on the outswap
                    // list.

                    process^.MemoryState = KI_PROCESS_TRANSITION

                    // Use a CAS loop to insert the process in the list.

                    WHILE TRUE DO
                        headv := KiProcessOutSwapListHead
                        process^.SwapNext = headv

                        IF KeCompareSwapPtr (
                            &KiProcessOutSwapListHead, // ptr
                            process, // newvalue
                            headv, // expectedvalue
                        ) == headv THEN

                            // Inserted.

                            BREAK
                        END
                    END
                END

                KiReleaseSwapStateElevated ( process )
            END
        END

        KiReleaseThreadElevated ( thread )
    END

    KiReleaseCandidateList ( prb, ipl )

    RETURN head
END

FN KiWakeSwapper ()

    // Wake the swapper.

#IF BLD_MP
    // Request the swap thread to be awoken. We can't do it here because we're
    // underneath some spinlocks whose order we would violate, so we defer it
    // until the next time IPL drops below DPC level.

    myprb := KI_CURRENT_PRB

    myprb^.WakeStackSwapper = TRUE

    KiSoftInterruptSelf (
        myprb, // prb
        KI_IPL_DPC, // ipl
    )

#ELSE
    // Wake the swap thread.

    KeSignalEvent (
        &KeStackSwapperEvent, // event
        0, // priorityboost
    )
#END

END

FN KiReadyThreadOutswappedProcess (
    IN thread : ^KeThread,
)

    // The thread was readied while its process was outswapped, so we have to
    // enqueue it to the process's deferred ready list.

#IF BLD_CHK
    IF thread^.InSwapList THEN
        KeCrash ( "KiReadyOutswappedThread: already in swap list\n" )
    END
#END

    // Acquire a pointer to the thread's process.

    process := thread^.Process

    // Acquire the process's swap state spinlock.

    KiAcquireSwapStateElevated ( process )

    memorystate := process^.MemoryState

#IF BLD_CHK
    IF memorystate == KI_PROCESS_RESIDENT THEN
        KeCrash ( "KiReadyThreadOutswappedProcess: resident process\n" )
    END
#END

    // The process isn't resident, so we need to enqueue the thread in its
    // swap-in list.

    thread^.SwapNext = process^.SwapListHead
    process^.SwapListHead = thread

    IF memorystate == KI_PROCESS_OUTSWAPPED THEN
        // We saw the process OUTSWAPPED, so it's now our responsibility to
        // enqueue it to the swapper thread.

        process^.MemoryState = KI_PROCESS_TRANSITION

        // Use a CAS loop to insert the process in the list.

        WHILE TRUE DO
            head := KiProcessSwapListHead
            process^.SwapNext = head

            IF KeCompareSwapPtr (
                &KiProcessSwapListHead, // ptr
                process, // newvalue
                head, // expectedvalue
            ) == head THEN

                // Inserted.

                BREAK
            END
        END
    END

    KiReleaseSwapStateElevated ( process )

    // Set READY and in the swap list.

    thread^.Status = KI_THREAD_READY
    thread^.InSwapList = TRUE

    // Wake the swapper to bring in this process's page directory.

    KiWakeSwapper ()
END

FN KiReadyOutswappedThread (
    IN thread : ^KeThread,
) : UWORD

    // The thread was readied while its kernel stack was outswapped, so we have
    // to enqueue it to the swap list and request the swap thread to wake up.
    // Thread lock is held.
    //
    // Returns TRUE if we found the process in a non-resident state while
    // attempting to increment its resident stack count.

#IF BLD_CHK
    IF thread^.InSwapList THEN
        KeCrash ( "KiReadyOutswappedThread: already in swap list\n" )
    END
#END

    // Acquire a pointer to the thread's process.

    process := thread^.Process

    // Acquire the process's swap state spinlock.

    KiAcquireSwapStateElevated ( process )

    IF process^.MemoryState != KI_PROCESS_RESIDENT THEN
        // Not resident, have caller re-check.

        KiReleaseSwapStateElevated ( process )

        RETURN TRUE
    END

    // Increment the resident stack count of the process.

    process^.ResidentThreadCount += 1

    KiReleaseSwapStateElevated ( process )

    // The process was still resident, so we're going to enqueue the thread
    // in the global thread in-swap list.

    // Use a CAS loop to insert the thread in the list.

    WHILE TRUE DO
        head := KiStackSwapListHead
        thread^.SwapNext = head

        IF KeCompareSwapPtr (
            &KiStackSwapListHead, // ptr
            thread, // newvalue
            head, // expectedvalue
        ) == head THEN

            // Inserted.

            BREAK
        END
    END

    // Set READY and in the swap list.

    thread^.Status = KI_THREAD_READY
    thread^.InSwapList = TRUE

    // Wake the swapper to bring in this thread's stack.

    KiWakeSwapper ()

    // Return an indication that we successfully enqueued ourselves.

    RETURN FALSE
END

FN KiInsertSwapCandidateListFunc (
    IN thread : ^KeThread,
)

#IF BLD_CHK
    IF KeCurrentThread () != thread THEN
        KeCrash ( "KiInsertSwapCandidateListFunc: not current\n" )
    END

    IF thread^.SwapCandidatePrb THEN
        KeCrash ( "KiInsertSwapCandidateListFunc: already in list\n" )
    END
#END

    // Insert the thread in the swap candidate list for the current processor.

    prb := KI_CURRENT_PRB

    // Stash the Prb whose candidate list we're going into.

    thread^.SwapCandidatePrb = prb

    // Acquire the Prb's candidate list lock.

    KiAcquireCandidateListElevated ( prb )

    // Insert at the tail of the list, which keeps it sorted by earliest to
    // latest sleep time.

    RtlInsertAtTailList (
        &prb^.StackSwapCandidateListHead, // head
        &thread^.WaitEntry, // entry
    )

    // Release the candidate list lock.

    KiReleaseCandidateListElevated ( prb )
END

FN KiRemoveSwapCandidateListFunc (
    IN thread : ^KeThread,
)

#IF BLD_CHK
    IF KeCurrentThread () != thread THEN
        KeCrash ( "KiRemoveSwapCandidateListFunc: not current\n" )
    END

    IF NOT thread^.SwapCandidatePrb THEN
        KeCrash ( "KiRemoveSwapCandidateListFunc: not in list\n" )
    END
#END

    // Remove the thread from the swap candidate list.
    // We don't have to re-check that the thread wasn't removed from the
    // candidate list, because only WAITING threads are, and we ain't
    // waiting.

    prb := thread^.SwapCandidatePrb

    KiAcquireCandidateListElevated ( prb )

    RtlRemoveEntryList ( &thread^.WaitEntry )

    KiReleaseCandidateListElevated ( prb )

    // Clear the Prb pointer to indicate no longer in a list.

    thread^.SwapCandidatePrb = NULLPTR
END