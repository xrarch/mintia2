//
// Implements the processor dispatcher for the MINTIA Kernel.
//

#INCLUDE "Ki.hjk"

#INCLUDE "<ll>/System/OsStatus.hjk"
#INCLUDE "<ll>/System/OsSignal.hjk"

#IF BLD_MP

#MACRO KiAcquireReadyQueue ( prb ) [
    KiAcquireSpinlockInPrb (
        OFFSETOF KiPrb.ReadyQueueLock, // offset
        OUT prb, // prb
    )
]

#MACRO KiReleaseReadyQueue ( prb, oldipl ) [
    KiReleaseSpinlockLower (
        &(prb)^.ReadyQueueLock, // spinlock
        oldipl, // oldipl
    )
]

#MACRO KiAcquireReadyQueueElevated ( prb ) [
    KiAcquireSpinlock ( &(prb)^.ReadyQueueLock )
]

#MACRO KiReleaseReadyQueueElevated ( prb ) [
    KiReleaseSpinlock ( &(prb)^.ReadyQueueLock )
]

#MACRO KiAcquireThread ( thread ) [
    KiAcquireSpinlockRaise ( &(thread)^.Spinlock )
]

#MACRO KiReleaseThread ( thread, oldipl ) [
    KiReleaseSpinlockLower (
        &(thread)^.Spinlock, // spinlock
        oldipl, // oldipl
    )
]

#MACRO KiAcquireThreadElevated ( thread ) [
    KiAcquireSpinlock ( &(thread)^.Spinlock )
]

#MACRO KiReleaseThreadElevated ( thread ) [
    KiReleaseSpinlock ( &(thread)^.Spinlock )
]

#MACRO KiSetWaitAttempt ( thread, state ) [
    NOTHING (thread)^.WaitAttempt = (state)
]

#ELSE

#MACRO KiAcquireReadyQueue ( prb ) [
    KiRaiseIpl ( KI_IPL_DPC )
    NOTHING (prb) = KI_CURRENT_PRB
]

#MACRO KiReleaseReadyQueue ( prb, oldipl ) [
    KiLowerIpl ( oldipl )
]

#MACRO KiAcquireReadyQueueElevated ( prb ) []

#MACRO KiReleaseReadyQueueElevated ( prb ) []

#MACRO KiAcquireThread ( thread ) [
    KiRaiseIpl ( KI_IPL_DPC )
]

#MACRO KiReleaseThread ( thread, oldipl ) [
    KiLowerIpl ( oldipl )
]

#MACRO KiAcquireThreadElevated ( thread ) []

#MACRO KiReleaseThreadElevated ( thread ) []

#MACRO KiSetWaitAttempt ( thread, state ) []

#END

FN KiPreemptThread (
    IN prb : ^KiPrb,
)

    KeCrash ( "NYI KiPreemptThread\n" )
END

FN KiQuantumEnd (
    IN prb : ^KiPrb,
)

    KeCrash ( "NYI KiQuantumEnd\n" )
END

FN KiSwitchThread (
    IN current : ^KeThread,
    IN thread : ^KeThread,
)

    // The current thread is locked, unless it is NULLPTR (in which case this is
    // the first thread switch in the lifetime of the system).
    //
    // The target thread is not locked as it has been removed from the ready
    // queue and is in our custody.

#IF BLD_CHK
    IF KiCurrentIpl () != KI_IPL_DPC THEN
        KeCrash ( "KiSwitchThread: IPL != KI_IPL_DPC\n" )
    END

    IF current == thread THEN
        KeCrash ( "KiSwitchThread: same thread\n" )
    END

    IF NOT current THEN
        KeCrash ( "KiSwitchThread: current == 0\n" )
    END

    IF NOT thread THEN
        KeCrash ( "KiSwitchThread: thread == 0\n" )
    END
#END

    thread^.Status = KI_THREAD_RUNNING

    nextproc := thread^.Process

    // Disable interrupts *before* switching address space because we have to
    // block out ASID rollover IPIs on some architectures.

    oldstate := KiDisableInterrupts ()

    IF nextproc^.PageDirectoryPfn != current^.Process^.PageDirectoryPfn THEN
        // Switch to the address space of the new process.

        KiSwitchAddressSpace ( nextproc )
    END

    // Note that KiSwitchContext releases the old thread's lock.
    // It is not reacquired before switching back in.

    KiSwitchContext (
        thread, // newthread
        current, // oldthread
    )

    KiRestoreInterrupts ( oldstate )

    // We're back in the context of the "current" thread. This is always where
    // the hole that the gopher pops back out of is, except in the case of a
    // newly created thread being dispatched for the first time.
    //
    // Check for pending Kernel APCs that need to be dispatched. Note that we
    // don't need to acquire our thread lock for that since the act of checking
    // (RtlEmptyList) does not touch any pointers.

    IF NOT RtlEmptyList ( &current^.KapcListHead ) THEN
        KiSoftInterruptSelf ( KI_CURRENT_PRB, KI_IPL_APC )
    END
END

FN KiWaitThread (
    IN thread : ^KeThread,
    IN waitipl : UWORD,
    IN waitmode : UWORD,
    IN alertable : UWORD,
) : OsStatus

    // This function is entered with the thread lock held (IPLDPC).

    thread^.Alertable = alertable
    thread^.WaitMode = waitmode
    thread^.WaitIpl = waitipl

    KeCrash ( "NYI KiThreadWait\n" )
END

#MACRO KiCheckWaitInterruptingEvents ( thread, ipl, alertable, waitmode ) [
    IF ipl == KI_IPL_LOW THEN
        // IPL >= KI_IPL_APC masks out all events.

        IF NOT alertable THEN
            IF waitmode == KE_USER_MODE AND
                thread^.SignalMask & (1 << OS_SIGNAL_KILL) THEN

                // Unalertable usermode waits are only interrupted by
                // termination.

                KiReleaseThread ( thread, ipl )

                RETURN OS_STATUS_KILLED
            END

        ELSEIF waitmode == KE_KERNEL_MODE THEN
            IF NOT thread^.IgnoreEventCount AND
                thread^.SignalMask & (1 << OS_SIGNAL_KILL) THEN

                // Alertable kernel mode waits are only interrupted by
                // termination.

                KiReleaseThread ( thread, ipl )

                RETURN OS_STATUS_KILLED
            END

        ELSEIF NOT RtlEmptyList ( &thread^.UapcListHead ) THEN

            // There are pending usermode APCs and this is a KE_USER_MODE wait.

            thread^.UserApcTriggered = TRUE
            thread^.UserInterrupt = TRUE

            KiReleaseThread ( thread, ipl )

            RETURN OS_STATUS_USER_APC

        ELSEIF thread^.SignalMask &
            thread^.SignalAcceptMask &
            thread^.SignalDeliverOnWaitMask THEN

            // There are pending signals and this is a KE_USER_MODE wait.

            thread^.SignalDeliverOnWaitMask &= ~thread^.SignalMask
            thread^.UserInterrupt = TRUE

            KiReleaseThread ( thread, ipl )

            RETURN OS_STATUS_SIGNALED
        END
    END
]

FN KeWaitForObjects (
    IN waitmode : UWORD,
    IN alertable : UWORD,
    IN timeout : ^RtlUquad,
    IN objectcount : UWORD,
    IN objecttable : ^KiDispatchHeader,
    IN waitblocktable : ^KiWaitBlock,
) : OsStatus

    // Wait for any of multiple objects to enter a signaled state. A timeout
    // interval in milliseconds can be supplied. If it is NULLPTR, the timeout
    // is infinite.

#IF BLD_CHK
    IF KiCurrentIpl () >= KI_IPL_DPC THEN
        KeCrash ( "KeWaitForObjects: IPL >= KI_IPL_DPC\n" )
    END

    // The following parameters should never be given by executive callers and
    // should have been rejected by the object manager.

    IF NOT objectcount THEN
        KeCrash ( "KeWaitForObjects: objectcount == 0\n" )
    END

#IF ( == BLD_BITS 64 )
    IF objectcount > 0xFFFFFFFF THEN
        KeCrash ( "KeWaitForObjects: objectcount > ULONG size\n" )
    END
#END
#END

    thread := KeCurrentThread ()

    IF NOT waitblocktable THEN
#IF BLD_CHK
        IF objectcount > KI_THREAD_WAIT_BLOCKS THEN
            KeCrash ( "objectcount > KI_THREAD_WAIT_BLOCKS\n" )
        END
#END

        // Use the integral wait blocks of the thread.
        // This mechanism exists to remove dependency on allocation.

        waitblocktable = &thread^.WaitBlocks[0]
    END

@Retry

    // Acquire the thread lock.

    ipl := KiAcquireThread ( thread )

    // Before we start, check for events that would interrupt the wait.
    // This is a macro that can return from the function for us (after
    // dropping the thread lock).

    KiCheckWaitInterruptingEvents (
        thread, // thread
        ipl, // ipl
        alertable, // alertable
        waitmode, // waitmode
    )

    // Store the wait block table in the thread.

    thread^.WaitBlockTable = waitblocktable
    thread^.WaitCount = objectcount

    // Set the thread to wait-try.
    //
    // Note that this wait-try tactic was derived from an explanation given
    // by Arun Kishan in an interview about how the Windows kernel team
    // broke up the dispatcher spinlock.

    KiSetWaitAttempt ( thread, KI_THREAD_WAIT_TRY )

    // Release the thread lock but stay at KI_IPL_DPC.

    KiReleaseThreadElevated ( thread )

    waitblock : ^KiWaitBlock
    timer : ^KeTimer
    i := 0
    status : OsStatus
    object : ^KiDispatchHeader

    WHILE i < objectcount DO
        waitblock = &waitblocktable[i]
        object = &objecttable[i]

        // Capture the current signal count.

@RecheckObject

        signal := object^.SignalCount

        IF signal THEN
            // Already signaled. Our wait has been satisfied before it began.

            // If this isn't a notification event, consume the count.

            IF object^.Type != KI_DISPATCH_EVENT_NOTIF THEN
#IF BLD_MP
                IF KeCompareSwapUlong (
                    &object^.SignalCount, // ptr
                    signal - 1, // newvalue
                    signal, // expectedvalue
                ) != signal THEN

                    // Signal count changed. Recheck the object.

                    GOTO RecheckObject
                END
#ELSE
                object^.SignalCount = signal - 1
#END
            END

            status = i

@Abort

            // Note the label above - on MP we GOTO here if another
            // processor aborted our wait.

            // At this point "i" is equivalent to the maximum object index we
            // reached before we aborted, and "status" is equivalent to whatever
            // we should return when we leave.
            
            // Remove our wait blocks from every object we enqueued them to.

            j := 0

            WHILE j < i DO
                waitblock = &waitblocktable[j]

                object = waitblock^.Object

                // Acquire the object lock.

                KiAcquireObjectElevated ( object )

                // Remove the wait block.

                RtlRemoveEntryList ( &waitblock^.Entry )

                // Release the object lock.

                KiReleaseObjectElevated ( object )

                j += 1
            END

            KiSetWaitAttempt ( thread, KI_THREAD_WAIT_NONE )

            KiLowerIpl ( ipl )

            RETURN status
        END

        // Initialize the fields of the wait block outside the object lock.

        waitblock^.Thread = thread
        waitblock^.Object = object
        waitblock^.WakeStatus = i

        // Acquire the object lock.

        KiAcquireObjectElevated ( object )

#IF BLD_MP
        IF object^.SignalCount THEN
            // Got signaled since we checked. Recheck the object.

            KiReleaseObjectElevated ( object )

            GOTO RecheckObject
        END
#END

        // Enqueue our wait block to the object.

        RtlInsertAtTailList (
            &object^.WaitListHead, // head
            &waitblock^.Entry, // entry
        )

        // Release the object lock.

        KiReleaseObjectElevated ( object )

        i += 1
    END

    IF timeout THEN
        // Start the timeout.
        // NOTE: The timer object and the timeout wait block have been
        //       initialized by KeInitializeThread already.

        waitblock = &thread^.TimeoutWaitBlock
        timer = &thread^.Timeout

        // Set the thread field to indicate in use.

        waitblock^.Thread = thread

        // Insert the wait block in the timer's list.
        // This is safe to do without a lock because only we ever mess with
        // this timer in the context of this thread.

        RtlInsertAtTailList (
            &timer^.Header.WaitListHead, // head
            &waitblock^.Entry, // entry
        )

        // Enqueue the timer.

        KeEnqueueTimer (
            timer, // timer
            timeout, // interval
            0, // context1
            0, // context2
        )
    END

    // Lock our thread.

    KiAcquireThreadElevated ( thread )

#IF BLD_MP
    // See if our wait has gone through.

    IF thread^.WaitAttempt == KI_THREAD_WAIT_ABORTED THEN
        // Nope! We have to dequeue all our wait blocks and return.

        // Release the thread lock so we don't violate the object->thread
        // lock ordering.

        KiReleaseThreadElevated ( thread )

        IF timeout THEN
            // We need to get rid of the timer.

            waitblock = &thread^.TimeoutWaitBlock
            timer = &thread^.Timeout

            // Dequeue it.

            KeDequeueTimer ( timer )

            // Remove the wait block.
            // We *still* don't need the lock because we've been nonpreemptible
            // and blocking out the expiration DPC for this processor the whole
            // time.

            RtlRemoveEntryList ( &waitblock^.Entry )
        END

        // The guy who aborted us left our status in our thread struct.

        status = thread^.WaitStatus

        GOTO Abort
    END
#END

    // The wait shall proceed.

    KiSetWaitAttempt ( thread, KI_THREAD_WAIT_COMMITTED )

    status = KiWaitThread (
        thread, // thread
        ipl, // waitipl
        waitmode, // waitmode
        alertable, // alertable
    )

    // KiWaitThread returns at the specified IPL and with the thread lock
    // released. All of our wait blocks have been dequeued, timer dequeued,
    // etc.

    IF status == OS_STATUS_KERNEL_APC THEN
        GOTO Retry
    END

    RETURN status
END