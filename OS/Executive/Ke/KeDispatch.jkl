//
// Implements the processor dispatcher for the MINTIA Kernel.
//

#INCLUDE "Ki.hjk"

#INCLUDE "<ll>/System/OsStatus.hjk"
#INCLUDE "<ll>/System/OsSignal.hjk"

#IF BLD_MP

PUBLIC KiIdleProcessorListHead : RtlListEntry

KiIdleProcessorSpinlock : KiSpinlock = KI_INITIAL_SPINLOCK

KiProcessorScanIndex : ULONG

#MACRO KiAcquireReadyQueueElevated ( prb ) [
    KiAcquireSpinlock ( &(prb)^.ReadyQueueLock )
]

#MACRO KiReleaseReadyQueueElevated ( prb ) [
    KiReleaseSpinlock ( &(prb)^.ReadyQueueLock )
]

#MACRO KiAcquireThread ( thread ) [
    KiAcquireSpinlockRaise ( &(thread)^.Spinlock )
]

#MACRO KiReleaseThread ( thread, oldipl ) [
    KiReleaseSpinlockLower (
        &(thread)^.Spinlock, // spinlock
        oldipl, // oldipl
    )
]

#MACRO KiAcquireThreadElevated ( thread ) [
    KiAcquireSpinlock ( &(thread)^.Spinlock )
]

#MACRO KiReleaseThreadElevated ( thread ) [
    KiReleaseSpinlock ( &(thread)^.Spinlock )
]

#MACRO KiSetWaitAttempt ( thread, state ) [
    NOTHING (thread)^.WaitAttempt = (state)
]

#ELSE

#MACRO KiAcquireReadyQueueElevated ( prb ) []

#MACRO KiReleaseReadyQueueElevated ( prb ) []

#MACRO KiAcquireThread ( thread ) [
    KiRaiseIpl ( KI_IPL_DPC )
]

#MACRO KiReleaseThread ( thread, oldipl ) [
    KiLowerIpl ( oldipl )
]

#MACRO KiAcquireThreadElevated ( thread ) []

#MACRO KiReleaseThreadElevated ( thread ) []

#MACRO KiSetWaitAttempt ( thread, state ) []

#END

FN KiJumpIntoIdleThread (
    IN prb : ^KiPrb,
)

    // Called by a processor when it first enters the system to initially jump
    // into its idle thread.

#IF BLD_MP
    // Add self to idle list.

    ipl := KiAcquireSpinlockRaise ( &KiIdleProcessorSpinlock )

    RtlInsertAtTailList (
        &KiIdleProcessorListHead, // head
        &prb^.IdlePrbListEntry, // entry
    )

    KiReleaseSpinlockLower ( &KiIdleProcessorSpinlock, ipl )
#END

    // Switch into our idle thread.

    KiJumpIntoThread ( &prb^.IdleThread )
END

FN KiSwitchThread (
    IN current : ^KeThread,
    IN thread : ^KeThread,
)

    // The current thread is locked, unless it is NULLPTR (in which case this is
    // the first thread switch in the lifetime of the system).
    //
    // The target thread is not locked as it has been removed from the ready
    // queue and is in our custody.

#IF BLD_CHK
    IF KiCurrentIpl () != KI_IPL_DPC THEN
        KeCrash ( "KiSwitchThread: IPL != KI_IPL_DPC\n" )
    END

    IF current == thread THEN
        KeCrash ( "KiSwitchThread: same thread\n" )
    END

    IF NOT current THEN
        KeCrash ( "KiSwitchThread: current == 0\n" )
    END

    IF NOT thread THEN
        KeCrash ( "KiSwitchThread: thread == 0\n" )
    END
#END

    // Set affinity to this processor.

    prb := KI_CURRENT_PRB

    thread^.AffinityPrb = prb

#IF BLD_MP
    IF thread^.Priority == OS_PRIORITY_IDLE AND
        current^.Priority != OS_PRIORITY_IDLE THEN

        // Add self to idle list.

        KiAcquireSpinlock ( &KiIdleProcessorSpinlock )

        RtlInsertAtTailList (
            &KiIdleProcessorListHead, // head
            &prb^.IdlePrbListEntry, // entry
        )

        KiReleaseSpinlock ( &KiIdleProcessorSpinlock )

    ELSEIF current^.Priority == OS_PRIORITY_IDLE AND
        thread^.Priority != OS_PRIORITY_IDLE THEN

        // Remove self from idle list.

        KiAcquireSpinlock ( &KiIdleProcessorSpinlock )

        RtlRemoveEntryList ( &prb^.IdlePrbListEntry )

        KiReleaseSpinlock ( &KiIdleProcessorSpinlock )
    END
#END

    // See if we have to switch address spaces.

    nextproc := thread^.Process

    IF nextproc^.PageDirectoryPfn != current^.Process^.PageDirectoryPfn THEN
        // Switch to the address space of the new process.

        KiSwitchAddressSpace ( nextproc )
    END

    // Note that KiSwitchContext releases the old thread's lock.
    // It is not reacquired before switching back in.

    KiSwitchContext (
        thread, // newthread
        current, // oldthread
    )

    // We're back in the context of the "current" thread. This is always where
    // the hole that the gopher pops back out of is, except in the case of a
    // newly created thread being dispatched for the first time.
    //
    // Check for pending Kernel APCs that need to be dispatched. Note that we
    // don't need to acquire our thread lock for that since the act of checking
    // (RtlEmptyList) does not touch any pointers.

    IF NOT RtlEmptyList ( &current^.KapcListHead ) THEN
        KiSoftInterruptSelf ( prb, KI_IPL_APC )
    END
END

FN KiInsertThread (
    IN prb : ^KiPrb,
    IN thread : ^KeThread,
    IN other : UWORD,
)

    // Insert a thread into the appropriate ready queue of the given processor.
    // We *don't* try to synchronize against this thread being readied by
    // multiple processors at once, so there should be a well defined and
    // exclusive custody of the thread object by the caller at this point. Also
    // the ready queue of the processor should be locked. Also the thread lock
    // is held.

    IF other THEN
        RtlPrint ( "a" )
    END

    thread^.Status = KI_THREAD_READY
    thread^.CurrentPrb = prb

    current := prb^.CurrentThread
    next := prb^.NextThread

    compare := next

    IF NOT compare THEN
        compare = current
    END

    IF thread^.Priority >= OS_PRIORITY_LOW_REALTIME OR
        thread^.Interactive THEN

        // It's either one of the forced real time priorities or we've deemed it
        // interactive. Either way it goes in the real time queue or preempts
        // the current thread.

        IF (compare^.Priority >= OS_PRIORITY_LOW_REALTIME OR
            compare^.Interactive) AND thread^.Priority <= compare^.Priority THEN

            thread^.CurrentQueue = KI_REAL_TIME_QUEUE

            // Go on the back of the queue.

            RtlInsertAtTailList (
                &prb^.RealTimeListHeads[thread^.Priority], // head
                &thread^.ReadyEntry, // entry
            )

            // Indicate that an item exists in this queue.

            prb^.RealTimeReady |= 1 << thread^.Priority

            LEAVE
        END

    ELSE
        // It's a timeshared or idle thread. There's only one thing these can
        // preempt - the idle thread.

        IF compare != &prb^.IdleThread THEN
            // No preemption. Just place on the appropriate queue.

            IF thread^.Priority == OS_PRIORITY_IDLE THEN
                // Idle queue.

                thread^.CurrentQueue = KI_IDLE_QUEUE

                RtlInsertAtTailList (
                    &prb^.IdleListHead, // head
                    &thread^.ReadyEntry, // entry
                )

                LEAVE
            END

            // Timeshared queue.

            thread^.CurrentQueue = KI_TIMESHARED_QUEUE

            insertat := prb^.CalendarEnqueueIndex

            // Bias the index by the inverse of the priority, so that higher
            // priority timeshared threads are scheduled sooner.

            insertat += KI_TIMESHARED_DISTANCE - thread^.Priority
            insertat %= KI_TIMESHARED_QUEUES

            IF prb^.CalendarRunIndex != prb^.CalendarEnqueueIndex AND
                insertat == prb^.CalendarRunIndex THEN

                insertat -= 1
                insertat %= KI_TIMESHARED_QUEUES
            END

            // Reuse Alertable to stash the timeshared queue index.

            thread^.Alertable = insertat

            // Go on the back of the queue.

            RtlInsertAtTailList (
                &prb^.CalendarListHeads[insertat], // head
                &thread^.ReadyEntry, // entry
            )

            // Indicate that an item exists in this queue.

            prb^.CalendarReady |= 1 << insertat

            LEAVE
        END
    END

    // Cause a preemption.

    thread^.Status = KI_THREAD_STANDBY

    prb^.NextThread = thread

    IF next THEN
        // Recursively re-ready the preempted NextThread. Don't fear - this can
        // only nest one level deep.

        KiInsertThread (
            prb, // prb
            next, // thread
            other, // other
        )

    ELSE
        // Trigger a software interrupt.

#IF BLD_MP
        IF other THEN
            // This was a remote Prb; may have to send an IPI.

            KiSoftInterruptOther (
                prb, // targetprb
                KI_IPL_DPC, // ipl
            )

            LEAVE
        END
#END

        KiSoftInterruptSelf (
            prb, // targetprb
            KI_IPL_DPC, // ipl
        )
    END
END

FN KiWouldPreempt (
    IN thread1 : ^KeThread,
    IN thread2 : ^KeThread,
    IN targetprb : ^KiPrb,
) : UWORD

    // Returns TRUE if thread1 would preempt thread2.

    IF thread1^.Interactive THEN
        IF NOT thread2^.Interactive THEN
            // Interactive threads always preempt non-interactive threads.

            RETURN TRUE
        END

        // Both are interactive. Compare priorities.

        RETURN thread1^.Priority > thread2^.Priority
    END

    IF thread1^.Priority >= OS_PRIORITY_LOW_REALTIME AND
        thread1^.Priority > thread2^.Priority THEN

        // Higher priority real time threads preempt all other threads.

        RETURN TRUE
    END

    IF thread1^.Priority > OS_PRIORITY_IDLE AND
        thread2^.Priority == OS_PRIORITY_IDLE THEN

        // Non-idle threads always preempt idle threads.

        RETURN TRUE
    END

    IF thread2 == &targetprb^.IdleThread THEN
        // Always preempt the idle thread.

        RETURN TRUE
    END

    RETURN FALSE
END

FN KiReadyThread (
    IN thread : ^KeThread,
)

    // Ready the thread by inserting it into an appropriate ready queue.
    // Thread lock is held.

    myprb := KI_CURRENT_PRB

#IF BLD_MP
    // Select a processor to insert the thread into in the following order:
    //
    // 1. Affinity processor if would preempt.
    // 2. Any other idle processor.
    // 3. Any other preemptible processor.
    // 4. Current processor.

    prb := thread^.AffinityPrb

    IF prb THEN
        KiAcquireReadyQueueElevated ( prb )

        IF NOT thread^.Pinned AND NOT KiWouldPreempt (
            thread, // thread1
            prb^.CurrentThread, // thread2
            prb, // targetprb
        ) THEN
            // Not pinned to, and wouldn't preempt. Don't pick this one.

            prb = NULLPTR
        END

        KiReleaseReadyQueueElevated ( prb )
    END

    IF NOT prb THEN
        listentry := &KiIdleProcessorListHead.Next

        IF listentry != &KiIdleProcessorListHead THEN
            // Enqueue to this one. Note that no locks are required for this.

            prb = CONTAINEROF listentry TO KiPrb.IdlePrbListEntry
        END
    END

    IF NOT prb THEN
        // Scan for a preemptible processor.

        index := KeIncrementUlong (
            &KiProcessorScanIndex, // ptr
            1, // ulong
        )

        i := 0
        max := ExLoaderBlock.ProcessorCount

        WHILE i < max DO
            IF index >= max THEN
                index = 0
            END

            prb = KiPrbFromNumber ( index )

            KiAcquireReadyQueueElevated ( prb )

            IF KiWouldPreempt (
                thread, // thread1
                prb^.CurrentThread, // thread2
                prb, // targetprb
            ) THEN
                
                // Select this one.

                KiReleaseReadyQueueElevated ( prb )

                BREAK
            END

            KiReleaseReadyQueueElevated ( prb )

            i += 1
            index += 1
            prb += BL_PRB_SIZE
        END

        IF i == max THEN
            // Didn't find one.

            prb = NULLPTR
        END
    END

    IF NOT prb THEN
        // Just enqueue to me.

        prb = myprb
    END

    KiAcquireReadyQueueElevated ( prb )

    KiInsertThread (
        prb, // prb
        thread, // thread
        myprb != prb, // other
    )

    KiReleaseReadyQueueElevated ( prb )

#ELSE
    KiInsertThread (
        myprb, // prb
        thread, // thread
        FALSE, // other
    )
#END

END

FN KiSelectRealTimeThread (
    IN prb : ^KiPrb,
) : ^KeThread

    // Return a thread to switch into from the given processor's real time ready
    // queues. The processor's ready queue lock is held.

    readybits := prb^.RealTimeReady

    i := OS_PRIORITY_MAX

    WHILE i DO
        i -= 1

        IF (readybits >> i) & 1 THEN
            // There's a thread in this queue. Unlink and return it.

            queue := &prb^.RealTimeListHeads[i]

            thread := CONTAINEROF queue^.Next TO KeThread.ReadyEntry

            RtlRemoveEntryList ( &thread^.ReadyEntry )

            IF RtlEmptyList ( queue ) THEN
                // The queue is empty now. Clear the bit.

                prb^.RealTimeReady = readybits & ~(1 << i)
            END

            RETURN thread
        END
    END

    RETURN NULLPTR
END

FN KiSelectTimesharedThread (
    IN prb : ^KiPrb,
    IN current : ^KeThread,
) : ^KeThread

    // Return a thread to switch into from the given processor's calendar ready
    // queues. The processor's ready queue lock is held.

    // If there's a current thread we want to see where it would be placed if it
    // were to be enqueued here now, so that we can go right back to it if we
    // figure out thats appropriate.

    readybits := prb^.CalendarReady

    count := KI_TIMESHARED_QUEUES
    k := prb^.CalendarRunIndex

    IF (readybits >> k) & 1 THEN
        // There's a thread in this queue. Unlink and return it.

        queue := &prb^.CalendarListHeads[k]

        thread := CONTAINEROF queue^.Next TO KeThread.ReadyEntry

        RtlRemoveEntryList ( &thread^.ReadyEntry )

        IF RtlEmptyList ( queue ) THEN
            // The queue is empty now. Clear the bit.

            prb^.CalendarReady = readybits & ~(1 << k)

            // Advance the run index.

            IF prb^.CalendarRunIndex != prb^.CalendarEnqueueIndex THEN
                prb^.CalendarRunIndex = (k + 1) % KI_TIMESHARED_QUEUES
            END
        END

        RETURN thread
    END

    RETURN NULLPTR
END

FN KiSelectThread (
    IN prb : ^KiPrb,
    IN current : ^KeThread,
    IN exclusive : UWORD,
) : ^KeThread

    // Return a thread to switch into from the given processor's queues.
    // A thread lock is held, or we are otherwise at KI_IPL_DPC. Ready queue
    // lock is held.
    // If a current thread is given, we only return threads that can preempt it.

    next := prb^.NextThread

    IF next THEN
        // There's already a next thread selected, return that.

        prb^.NextThread = NULLPTR
        next^.Status = KI_THREAD_INFLIGHT

        RETURN next
    END

    minimumpriority := 0
    interactive := FALSE

    IF current THEN
        minimumpriority = current^.Priority
        interactive = current^.Interactive

        IF exclusive THEN
            minimumpriority += 1
        END
    END

    // Check the real time bitmap.

    readybits := prb^.RealTimeReady

    IF readybits >> minimumpriority THEN
        // We're taking a thread off the real time queues.

        next = KiSelectRealTimeThread ( prb )

        RETURN next
    END

    IF interactive OR minimumpriority >= OS_PRIORITY_LOW_REALTIME THEN
        // Can't be preempted by anybody timeshared.

        RETURN NULLPTR
    END

    // Check the calendar queue (timeshared) bitmap.

    readybits = prb^.CalendarReady

    IF readybits THEN
        // We're taking a thread off the timeshared queues.

        next = KiSelectTimesharedThread (
            prb, // prb
            current, // current
        )

        RETURN next
    END

    IF minimumpriority > OS_PRIORITY_IDLE THEN
        // Can't be preempted by an idle thread.
    
        RETURN NULLPTR
    END

    // Check the idle thread queue.

    IF NOT RtlEmptyList ( &prb^.IdleListHead ) THEN
        // We're taking a thread off the idle queue.

        next = CONTAINEROF prb^.IdleListHead.Next TO KeThread.ReadyEntry

        RtlRemoveEntryList ( &next^.ReadyEntry )

        RETURN next
    END

    // Nothing to run.

    RETURN NULLPTR
END

FN KiPreemptThread (
    IN prb : ^KiPrb,
)

    // Called at KI_IPL_DPC when theres a thread we've been preempted by and
    // it's time to switch into it.

    // Grab the next thread with the ready queue lock held.

    KiAcquireReadyQueueElevated ( prb )

    next := prb^.NextThread
    prb^.NextThread = NULLPTR
    next^.Status = KI_THREAD_INFLIGHT

    KiReleaseReadyQueueElevated ( prb )

    // If there's somehow no next thread, just return.

    IF NOT next THEN
        LEAVE
    END

    current := prb^.CurrentThread

    IF current != &prb^.IdleThread THEN
        // Ready the current thread.

        KiAcquireThreadElevated ( current )
        KiAcquireReadyQueueElevated ( prb )

        KiInsertThread (
            prb, // prb
            current, // thread
            FALSE, // other
        )

        KiReleaseReadyQueueElevated ( prb )
        KiReleaseThreadElevated ( current )
    END

    // Acquire the thread lock.

    KiAcquireThreadElevated ( current )

    // Switch into the thread.

    KiSwitchThread (
        current, // current
        next, // thread
    )

    // KiSwitchThread returns with the thread lock released.
END

FN KiSetPriorityThread (
    IN thread : ^KeThread,
    IN priority : UWORD,
)

    // Set the new priority for a thread.

#IF BLD_CHK
    IF KiCurrentIpl () != KI_IPL_DPC THEN
        KeCrash ( "KiSetPriorityThread: IPL != KI_IPL_DPC\n" )
    END
#END

#IF BLD_MP
    // Lock the thread and any processor ready queue that it is enqueued to.

    KiAcquireThreadElevated ( thread )

    prb := thread^.CurrentPrb

    IF prb THEN
        KiAcquireReadyQueueElevated ( prb )
    END

    other := (prb != KI_CURRENT_PRB)

#ELSE
    prb := thread^.CurrentPrb
    other := FALSE
#END

    curpri := thread^.Priority

    IF curpri == priority THEN
        // Nothing changed.

        GOTO Exit
    END

    thread^.Priority = priority

    IF thread^.Status == KI_THREAD_READY THEN
        // We changed the priority level, so the thread is now on the wrong
        // ready queue. Manually unlink it from the queue, and then re-ready
        // it to place it on the correct one.

        RtlRemoveEntryList ( &thread^.ReadyEntry )

        IF thread^.ReadyEntry.Prev == thread^.ReadyEntry.Next THEN
            // We just emptied the list. We have to clear a bit.

            IF thread^.CurrentQueue == KI_REAL_TIME_QUEUE THEN
                prb^.RealTimeReady &= ~(1 << curpri)

            ELSEIF thread^.CurrentQueue == KI_TIMESHARED_QUEUE THEN
                // The timeshared queue index was stashed in Alertable.

                prb^.CalendarReady &= ~(1 << thread^.Alertable)
            END
        END

        KiInsertThread (
            prb, // prb
            thread, // thread
            other, // other
        )

        GOTO Exit
    END

    IF priority >= curpri THEN
        // We raised priority, so there's nothing left to do.

        GOTO Exit
    END

    // Priority was dropped. It may need to be preempted.

    next : ^KeThread

    IF thread^.Status == KI_THREAD_STANDBY THEN
        // This is the next thread, so check if we have a higher priority
        // thread we should switch to instead, now that we have dropped its
        // priority.

        next = KiSelectThread (
            prb, // prb
            thread, // current
            TRUE, // exclusive
        )

        IF NOT next THEN
            GOTO Exit
        END

        next^.Status = KI_THREAD_STANDBY
        prb^.NextThread = next

        // Re-ready our thread to place it on the normal ready queue.

        KiInsertThread (
            prb, // prb
            thread, // thread
            other, // other
        )

        GOTO Exit
    END

    IF thread^.Status == KI_THREAD_RUNNING THEN
        // This is the running thread, so we should see if there's now a
        // higher priority thread that should preempt it.

        IF prb^.NextThread THEN
            // A next thread was already selected.

            GOTO Exit
        END

        next = KiSelectThread (
            prb, // prb
            thread, // current
            TRUE, // exclusive
        )

        IF NOT next THEN
            GOTO Exit
        END

        // Cause a preemption.

        next^.Status = KI_THREAD_STANDBY
        prb^.NextThread = next

#IF BLD_MP
        IF other THEN
            // This was a remote Prb; may have to send an IPI.

            KiSoftInterruptOther (
                prb, // targetprb
                KI_IPL_DPC, // ipl
            )

            GOTO Exit
        END
#END

        KiSoftInterruptSelf (
            prb, // targetprb
            KI_IPL_DPC, // ipl
        )
    END

@Exit

#IF BLD_MP
    IF prb THEN
        KiReleaseReadyQueueElevated ( prb )
    END

    KiReleaseThreadElevated ( thread )
#END

END

FN KiQuantumEnd (
    IN prb : ^KiPrb,
)

    // A quantum end has been detected on the current processor.

    current := prb^.CurrentThread

#IF BLD_CHK
    IF current == &prb^.IdleThread THEN
        KeCrash ( "KiQuantumEnd: idle thread\n" )
    END
#END

    // Replenish the quantum of the thread.

    current^.RemainingQuantum = KI_DEFAULT_QUANTUM

    // Decay interactivity score by one since this thread went a full quantum
    // without blocking.

    IF current^.Interactive THEN
        current^.Interactive -= 1
    END

    // Decay priority by one.

    IF current^.Priority > current^.BasePriority THEN
        // If this thread should be preempted, this function will find by whom.

        KiSetPriorityThread (
            current, // thread
            current^.Priority - 1, // priority
        )

    ELSE
        // Lock the ready queue.

        KiAcquireReadyQueueElevated ( prb )

        IF NOT prb^.NextThread THEN
            // Try to find a thread to preempt this one with.

            next := KiSelectThread (
                prb, // prb
                current, // current
                FALSE, // exclusive
            )

            IF next THEN
                // Found one. Set it as the next thread.

                next^.Status = KI_THREAD_STANDBY
                prb^.NextThread = next
            END
        END

        KiReleaseReadyQueueElevated ( prb )
    END
END

FN KiWaitThread (
    IN thread : ^KeThread,
) : OsStatus

    // This function is entered with the thread lock held (IPLDPC).

    // Set the thread status to WAITING.

    thread^.Status = KI_THREAD_WAITING

    // Try to find a thread to switch into.

    prb := KI_CURRENT_PRB

    KiAcquireReadyQueueElevated ( prb )

    next := KiSelectThread (
        prb, // prb
        NULLPTR, // current
        FALSE, // exclusive
    )

    KiReleaseReadyQueueElevated ( prb )

    IF next THEN
        // Switch into it.

        KiSwitchThread (
            thread, // current
            next, // thread
        )

    ELSE
        // Switch to the idle thread.

        KiSwitchThread (
            thread, // current
            &prb^.IdleThread, // thread
        )
    END

    // KiSwitchThread returns with the thread lock released.

    // We're back! Return the status.

    RETURN thread^.WaitStatus
END

#MACRO KiCheckWaitInterruptingEvents ( thread, ipl, alertable, waitmode ) [
    IF ipl == KI_IPL_LOW THEN
        // IPL >= KI_IPL_APC masks out all events.

        IF NOT alertable THEN
            IF waitmode == KE_USER_MODE AND
                thread^.SignalMask & (1 << OS_SIGNAL_KILL) THEN

                // Unalertable usermode waits are only interrupted by
                // termination.

                KiSetWaitAttempt ( thread, KI_THREAD_WAIT_NONE )

                KiLowerIpl ( ipl )

                RETURN OS_STATUS_KILLED
            END

        ELSEIF waitmode == KE_KERNEL_MODE THEN
            IF NOT thread^.IgnoreEventCount AND
                thread^.SignalMask & (1 << OS_SIGNAL_KILL) THEN

                // Alertable kernel mode waits are only interrupted by
                // termination.

                KiSetWaitAttempt ( thread, KI_THREAD_WAIT_NONE )

                KiLowerIpl ( ipl )

                RETURN OS_STATUS_KILLED
            END

        ELSEIF NOT RtlEmptyList ( &thread^.LapcListHead ) THEN
            // There are pending lazy APCs and this is a KE_USER_MODE wait.

            KiSetWaitAttempt ( thread, KI_THREAD_WAIT_NONE )

            thread^.LazyApcTriggered = TRUE

            KiSoftInterruptSelf ( KI_CURRENT_PRB_LOCAL, KI_IPL_APC )

            KiLowerIpl ( ipl )

            GOTO Retry

        ELSEIF NOT RtlEmptyList ( &thread^.UapcListHead ) THEN
            // There are pending usermode APCs and this is a KE_USER_MODE wait.

            KiSetWaitAttempt ( thread, KI_THREAD_WAIT_NONE )

            thread^.UserApcTriggered = TRUE
            thread^.UserInterrupt = TRUE

            KiLowerIpl ( ipl )

            RETURN OS_STATUS_USER_APC

        ELSEIF thread^.SignalMask &
            thread^.SignalAcceptMask &
            thread^.SignalDeliverOnWaitMask THEN

            // There are pending signals and this is a KE_USER_MODE wait.

            KiSetWaitAttempt ( thread, KI_THREAD_WAIT_NONE )

#IF BLD_MP
            // Use an atomic in case someone saw our wait attempt state at TRY
            // and is also currently trying to clear these bits in the deliver-
            // -on-wait mask.

            KeMaskUlong (
                &thread^.SignalDeliverOnWaitMask, // ptr
                ~thread^.SignalMask, // mask
            )
#ELSE
            thread^.SignalDeliverOnWaitMask &= ~thread^.SignalMask
#END

            thread^.UserInterrupt = TRUE

            KiLowerIpl ( ipl )

            RETURN OS_STATUS_SIGNALED
        END
    END
]

FN KeWaitForObjects (
    IN waitmode : UWORD,
    IN alertable : UWORD,
    IN timeout : ^RtlUquad,
    IN objectcount : UWORD,
    IN objecttable : ^^KiDispatchHeader,
    IN waitblocktable : ^KiWaitBlock,
) : OsStatus

    // Wait for any of multiple objects to enter a signaled state. A timeout
    // interval in milliseconds can be supplied. If it is NULLPTR, the timeout
    // is infinite.

#IF BLD_CHK
    IF KiCurrentIpl () >= KI_IPL_DPC THEN
        KeCrash ( "KeWaitForObjects: IPL >= KI_IPL_DPC\n" )
    END

    // The following parameters should never be given by executive callers and
    // should have been rejected by the object manager.

    IF NOT objectcount THEN
        KeCrash ( "KeWaitForObjects: objectcount == 0\n" )
    END

#IF ( == BLD_BITS 64 )
    IF objectcount > 0xFFFFFFFF THEN
        KeCrash ( "KeWaitForObjects: objectcount > ULONG size\n" )
    END
#END
#END

    thread := KeCurrentThread ()

    IF NOT waitblocktable THEN
#IF BLD_CHK
        IF objectcount > KI_THREAD_WAIT_BLOCKS THEN
            KeCrash ( "objectcount > KI_THREAD_WAIT_BLOCKS\n" )
        END
#END

        // Use the integral wait blocks of the thread.
        // This mechanism exists to remove dependency on allocation.

        waitblocktable = &thread^.WaitBlocks[0]
    END

@Retry

    // Raise IPL.

    ipl := KiRaiseIpl ( KI_IPL_DPC )

    // Set the wait values in the thread.

    thread^.Alertable = alertable
    thread^.WaitMode = waitmode
    thread^.WaitIpl = ipl

    // Set the thread to wait-try.
    //
    // Note that this wait-try tactic was derived from an explanation given
    // by Arun Kishan in an interview about how the Windows kernel team
    // broke up the dispatcher spinlock.

    KiSetWaitAttempt ( thread, KI_THREAD_WAIT_TRY )

    // Before we start, check for events that would interrupt the wait.
    // This is a macro that can return from the function for us (after
    // dropping IPL).

    KiCheckWaitInterruptingEvents (
        thread, // thread
        ipl, // ipl
        alertable, // alertable
        waitmode, // waitmode
    )

    // Store the wait block table in the thread.

    thread^.WaitBlockTable = waitblocktable
    thread^.WaitCount = objectcount

    waitblock : ^KiWaitBlock
    timer : ^KeTimer
    i := 0
    status : OsStatus
    object : ^KiDispatchHeader

    WHILE i < objectcount DO
        waitblock = &waitblocktable[i]
        object = objecttable[i]

        // Initialize the fields of the wait block outside the object lock.

        waitblock^.Thread = thread
        waitblock^.Object = object
        waitblock^.WakeStatus = i

        KiAcquireObjectElevated ( object )

        // Capture the current signal count.

        signal := object^.SignalCount

        IF signal THEN
            // Already signaled. Our wait has been satisfied before it began.
            // If this isn't a notification event, consume the count.

            IF object^.Type != KI_DISPATCH_EVENT_NOTIF THEN
                object^.SignalCount = signal - 1
            END

            KiReleaseObjectElevated ( object )

            status = i

@Abort

            // Back out of the wait by simply removing our wait blocks from all
            // of the objects that we enqueued them to.
            //
            // Note the label above - on MP we GOTO here if another processor
            // rudely aborted our wait.
            //
            // At this point "i" is equivalent to the maximum object index we
            // reached before we aborted, and "status" is equivalent to whatever
            // we should return when we leave.
            //
            // Remove our wait blocks from every object we enqueued them to.

            j := 0

            WHILE j < i DO
                waitblock = &waitblocktable[j]

                object = waitblock^.Object

                // Acquire the object lock.

                KiAcquireObjectElevated ( object )

                // Remove the wait block.

                RtlRemoveEntryList ( &waitblock^.Entry )

                // Release the object lock.

                KiReleaseObjectElevated ( object )

                j += 1
            END

            KiSetWaitAttempt ( thread, KI_THREAD_WAIT_NONE )

            KiLowerIpl ( ipl )

            RETURN status
        END

        // Enqueue our wait block to the object.

        RtlInsertAtTailList (
            &object^.WaitListHead, // head
            &waitblock^.Entry, // entry
        )

        // Release the object lock.

        KiReleaseObjectElevated ( object )

        i += 1
    END

    IF timeout THEN
        // Start the timeout.
        // NOTE: The timer object and the timeout wait block have been
        //       initialized by KeInitializeThread already.

        waitblock = &thread^.TimeoutWaitBlock
        timer = &thread^.Timeout

        // Set the thread field to indicate in use.

        waitblock^.Thread = thread

        // Insert the wait block in the timer's list.
        // This is safe to do without a lock because only we ever mess with
        // this timer in the context of this thread.

        RtlInsertAtTailList (
            &timer^.Header.WaitListHead, // head
            &waitblock^.Entry, // entry
        )

        // Enqueue the timer.

        KeEnqueueTimer (
            timer, // timer
            timeout, // interval
            0, // context1
            0, // context2
        )
    END

    // Lock our thread.

    KiAcquireThreadElevated ( thread )

#IF BLD_MP
    // Check if an interrupting event (such as the object being signaled, a user
    // APC, etc) from another processor aborted our wait while we were enqueuing
    // wait blocks.

    IF thread^.WaitAttempt == KI_THREAD_WAIT_ABORTED THEN
        // It was aborted. We have to dequeue all our wait blocks and return.
        //
        // Release the thread lock so we don't violate the object->thread
        // lock ordering.

        KiReleaseThreadElevated ( thread )

        IF timeout THEN
            // We need to get rid of the timer.

            waitblock = &thread^.TimeoutWaitBlock
            timer = &thread^.Timeout

            // Dequeue it.

            KeDequeueTimer ( timer )

            // Remove the wait block.
            // We don't need the timer's object lock because we've been
            // nonpreemptible and blocking out the expiration DPC for this
            // processor since we enqueued it. Therefore it is still in our
            // custody.

            RtlRemoveEntryList ( &waitblock^.Entry )
        END

        // The guy who aborted us left our status in our thread struct.

        status = thread^.WaitStatus

        GOTO Abort
    END

    thread^.WaitAttempt = KI_THREAD_WAIT_COMMITTED
#END

    // The wait shall proceed.

    status = KiWaitThread ( thread )

    // KiWaitThread returns at the specified IPL and with the thread lock
    // released. All of our wait blocks have been dequeued, timer dequeued,
    // etc.

    IF status == OS_STATUS_KERNEL_APC THEN
        GOTO Retry
    END

    RETURN status
END