//
// Implements the processor dispatcher for the MINTIA Kernel.
//

#INCLUDE "Ki.hjk"

#INCLUDE "<ll>/System/OsStatus.hjk"
#INCLUDE "<ll>/System/OsSignal.hjk"

#IF BLD_MP

#MACRO KiAcquireReadyQueueLow ( prb ) [
    KiAcquireSpinlockInPrb (
        OFFSETOF KiPrb.ReadyQueueLock, // offset
        OUT prb, // prb
    )
]

#MACRO KiReleaseReadyQueueLow ( prb, oldipl ) [
    KiReleaseSpinlockLower (
        &(prb)^.ReadyQueueLock, // spinlock
        oldipl, // oldipl
    )
]

#MACRO KiAcquireReadyQueueElevated ( prb ) [
    KiAcquireSpinlock ( &(prb)^.ReadyQueueLock )
]

#MACRO KiReleaseReadyQueueElevated ( prb ) [
    KiReleaseSpinlock ( &(prb)^.ReadyQueueLock )
]

#MACRO KiAcquireThread ( thread ) [
    KiAcquireSpinlockRaise ( &(thread)^.Spinlock )
]

#MACRO KiReleaseThread ( thread, oldipl ) [
    KiReleaseSpinlockLower (
        &(thread)^.Spinlock, // spinlock
        oldipl, // oldipl
    )
]

#MACRO KiAcquireThreadElevated ( thread ) [
    KiAcquireSpinlock ( &(thread)^.Spinlock )
]

#MACRO KiReleaseThreadElevated ( thread ) [
    KiReleaseSpinlock ( &(thread)^.Spinlock )
]

#MACRO KiSetWaitAttempt ( thread, state ) [
    NOTHING (thread)^.WaitAttempt = (state)
]

#ELSE

#MACRO KiAcquireReadyQueue ( prb ) [
    KiRaiseIpl ( KI_IPL_DPC )
    NOTHING (prb) = KI_CURRENT_PRB
]

#MACRO KiReleaseReadyQueue ( prb, oldipl ) [
    KiLowerIpl ( oldipl )
]

#MACRO KiAcquireReadyQueueElevated ( prb ) []

#MACRO KiReleaseReadyQueueElevated ( prb ) []

#MACRO KiAcquireThread ( thread ) [
    KiRaiseIpl ( KI_IPL_DPC )
]

#MACRO KiReleaseThread ( thread, oldipl ) [
    KiLowerIpl ( oldipl )
]

#MACRO KiAcquireThreadElevated ( thread ) []

#MACRO KiReleaseThreadElevated ( thread ) []

#MACRO KiSetWaitAttempt ( thread, state ) []

#END

#MACRO KiCheckWaitInterruptingEvents ( thread, ipl, alertable, waitmode ) [
    IF ipl == KI_IPL_LOW THEN
        // IPL >= KI_IPL_APC masks out all events.

        IF NOT alertable THEN
            IF waitmode == KE_USER_MODE AND
                thread^.SignalMask & (1 << OS_SIGNAL_KILL) THEN

                // Unalertable usermode waits are only interrupted by
                // termination.

                KiReleaseThread ( thread, ipl )

                RETURN OS_STATUS_KILLED
            END

        ELSEIF waitmode == KE_KERNEL_MODE THEN
            IF NOT thread^.IgnoreEventCount AND
                thread^.SignalMask & (1 << OS_SIGNAL_KILL) THEN

                // Alertable kernel mode waits are only interrupted by
                // termination.

                KiReleaseThread ( thread, ipl )

                RETURN OS_STATUS_KILLED
            END

        ELSEIF NOT RtlEmptyList ( &thread^.UapcListHead ) THEN

            // There are pending usermode APCs and this is a KE_USER_MODE wait.

            thread^.UserApcTriggered = TRUE
            thread^.UserInterrupt = TRUE

            KiReleaseThread ( thread, ipl )

            RETURN OS_STATUS_USER_APC

        ELSEIF thread^.SignalMask &
            thread^.SignalAcceptMask &
            thread^.SignalDeliverOnWaitMask THEN

            // There are pending signals and this is a KE_USER_MODE wait.

            thread^.SignalDeliverOnWaitMask &= ~thread^.SignalMask
            thread^.UserInterrupt = TRUE

            KiReleaseThread ( thread, ipl )

            RETURN OS_STATUS_SIGNALED
        END
    END
]

FN KiPreemptThread (
    IN prb : ^KiPrb,
)

    KeCrash ( "NYI KiPreemptThread\n" )
END

FN KiQuantumEnd (
    IN prb : ^KiPrb,
)

    KeCrash ( "NYI KiQuantumEnd\n" )
END

FN KiSwitchThread (
    IN current : ^KeThread,
    IN thread : ^KeThread,
)

    // The current thread is locked, unless it is NULLPTR (in which case this is
    // the first thread switch in the lifetime of the system).
    //
    // The target thread is not locked as it has been removed from the ready
    // queue and is in our custody.

#IF BLD_CHK
    IF KiCurrentIpl () != KI_IPL_DPC THEN
        KeCrash ( "KiSwitchThread: IPL != KI_IPL_DPC\n" )
    END

    IF current == thread THEN
        KeCrash ( "KiSwitchThread: same thread\n" )
    END

    IF NOT current THEN
        KeCrash ( "KiSwitchThread: current == 0\n" )
    END

    IF NOT thread THEN
        KeCrash ( "KiSwitchThread: thread == 0\n" )
    END
#END

    thread^.Status = KI_THREAD_RUNNING

    oldcontext : ^^OsContext

    oldstate : UWORD

    IF NOT current THEN
        // Give a space on the stack to stash it into.

        initialctx : ^OsContext[1]

        oldcontext = &initialctx[0]

        // Make sure interrupts are disabled before we switch.

        oldstate = KiDisableInterrupts ()

    ELSE
        oldcontext = &thread^.Context

        nextproc := thread^.Process

        // Disable interrupts *before* switching address space because we have
        // to block out ASID rollover IPIs on some architectures.

        oldstate = KiDisableInterrupts ()

        IF nextproc^.PageDirectoryPfn != current^.Process^.PageDirectoryPfn THEN
            // Switch to the address space of the new process.

            KiSwitchAddressSpace ( nextproc )
        END
    END

    prb := KI_CURRENT_PRB

    prb^.CurrentThread = thread
    prb^.KernelStackTop = thread^.KernelStackTop

    // Note that KiSwitchContext releases the old thread's lock.
    // It is not reacquired before switching back in.

    KiSwitchContext (
        current, // oldthread
        thread^.Context, // newcontext
    )

    KiRestoreInterrupts ( oldstate )

    // We're back in the context of the "current" thread.
    // Check for pending Kernel APCs that need to be dispatched. Note that we
    // don't need to acquire our thread lock for that since the act of checking
    // (RtlEmptyList) does not touch any pointers.

    IF NOT RtlEmptyList ( &current^.KapcListHead ) THEN
        // Grab a new PRB pointer since we might not be on the same processor
        // as when we grabbed the first one anymore.

#IF ( NOT KI_DIRECT_PRB )
        prb = KI_CURRENT_PRB
#END

        KiSoftInterruptSelf ( prb, KI_IPL_APC )
    END
END

FN KiWaitThread (
    IN thread : ^KeThread,
    IN waitipl : UWORD,
    IN waitmode : UWORD,
    IN alertable : UWORD,
) : OsStatus

    // This function is entered with the thread lock held (IPLDPC).

    thread^.Alertable = alertable
    thread^.WaitMode = waitmode
    thread^.WaitIpl = waitipl

    KeCrash ( "NYI KiThreadWait\n" )
END

FN KeWaitForObjects (
    IN waitmode : UWORD,
    IN alertable : UWORD,
    IN timeout : ^RtlUquad,
    IN objectcount : UWORD,
    IN objecttable : ^KiDispatchHeader,
    IN waitblocktable : ^KiWaitBlock,
) : OsStatus

#IF BLD_CHK
    IF KiCurrentIpl () >= KI_IPL_DPC THEN
        KeCrash ( "KeWaitForObjects: IPL >= KI_IPL_DPC\n" )
    END

    IF NOT objectcount THEN
        KeCrash ( "KeWaitForObjects: objectcount == 0\n" )
    END

#IF ( == BLD_BITS 64 )
    IF objectcount > 0xFFFFFFFF THEN
        KeCrash ( "KeWaitForObjects: objectcount > ULONG size\n" )
    END
#END
#END

    thread := KeCurrentThread ()

    IF NOT waitblocktable THEN
#IF BLD_CHK
        IF objectcount > KI_THREAD_WAIT_BLOCKS THEN
            KeCrash ( "objectcount > KI_THREAD_WAIT_BLOCKS\n" )
        END
#END

        // Use the integral wait blocks of the thread.
        // This mechanism exists to remove dependency on allocation.

        waitblocktable = &thread^.WaitBlocks[0]
    END

@Retry

    // Acquire the thread lock.

    ipl := KiAcquireThread ( thread )

    // Before we start, check for events that would interrupt the wait.
    // This is a macro that can return from the function for us (after
    // dropping the thread lock).

    KiCheckWaitInterruptingEvents (
        thread, // thread
        ipl, // ipl
        alertable, // alertable
        waitmode, // waitmode
    )

    // Store the wait block table in the thread.

    thread^.WaitBlockTable = waitblocktable
    thread^.WaitCount = objectcount

    // Set the thread to wait-try.
    //
    // Note that this wait-try tactic was derived from an explanation given
    // by Arun Kishan in an interview about how the Windows kernel team
    // broke up the dispatcher spinlock.

    KiSetWaitAttempt ( thread, KI_THREAD_WAIT_TRY )

    // Release the thread lock but stay at KI_IPL_DPC.

    KiReleaseThreadElevated ( thread )

    waitblock : ^KiWaitBlock
    timer : ^KeTimer
    i := 0
    status : OsStatus
    object : ^KiDispatchHeader
    hastimeout := FALSE

    WHILE i < objectcount DO
        waitblock = &waitblocktable[i]

        // Initialize fields of the waitblock outside the object lock.

        object = &objecttable[i]

        waitblock^.Thread = thread
        waitblock^.Object = object
        waitblock^.WakeStatus = i

        // Capture the current signal count.

        signal := object^.SignalCount

@RecheckObject

        IF signal THEN
            // Already signaled. Our wait has been satisfied before it began.

            // If this isn't a notification event, consume the count.

            IF object^.Type != KI_DISPATCH_EVENT_NOTIF THEN
#IF BLD_MP
                IF KeCompareSwapUlong (
                    &object^.SignalCount, // ptr
                    signal - 1, // newvalue
                    signal, // expectedvalue
                ) != signal THEN

                    // Signal count changed. Recheck the object.

                    signal = object^.SignalCount

                    GOTO RecheckObject
                END
#ELSE
                object^.SignalCount = signal - 1
#END
            END

            // Acquire the thread lock.

            KiAcquireThreadElevated ( thread )

            status = i

            // Don't release the thread lock. The abort codepath will do it.

            GOTO Abort
        END

        // Acquire the object lock.

        KiAcquireObjectElevated ( object )

#IF BLD_MP
        signal = object^.SignalCount

        IF signal THEN
            // Got signaled since we checked. Recheck the object.

            KiReleaseObjectElevated ( object )

            GOTO RecheckObject
        END
#END

        // Enqueue our wait block to the object.

        RtlInsertAtTailList (
            &object^.WaitListHead, // head
            &waitblock^.Entry, // entry
        )

        // Release the object lock.

        KiReleaseObjectElevated ( object )

        i += 1
    END

    hastimeout = timeout AND RtlUlongNeqUquad ( 0, timeout )

    IF hastimeout THEN
        // Start the timeout.
        // NOTE: The timer object and the timeout wait block have been
        //       initialized by KeInitializeThread already.

        waitblock = &thread^.TimeoutWaitBlock
        timer = &thread^.Timeout

        // Set the thread field to indicate in use.

        waitblock^.Thread = thread

        // Insert the wait block in the timer's list.
        // This is safe to do without a lock because only we ever mess with
        // this timer in the context of this thread.

        RtlInsertAtTailList (
            &timer^.Header.WaitListHead, // head
            &waitblock^.Entry, // entry
        )

        // Enqueue the timer.

        KeEnqueueTimer (
            timer, // timer
            timeout, // interval
            0, // context1
            0, // context2
        )
    END

    // Lock our thread.

    KiAcquireThreadElevated ( thread )

    // See if our wait has gone through.

    zerotimeout := timeout AND RtlUlongEqUquad ( 0, timeout )

#IF BLD_MP
    IF thread^.WaitAttempt == KI_THREAD_WAIT_ABORTED OR zerotimeout THEN
#ELSE
    IF zerotimeout THEN
#END

        status = OS_STATUS_UNSATISFIED

        // Nope! We have to dequeue all our wait blocks and return.

        // Capture the status before lowering IPL.

#IF BLD_MP
        IF thread^.WaitAttempt == KI_THREAD_WAIT_ABORTED THEN
            // We were aborted. The guy who aborted us left our status in
            // our thread struct.

            status = thread^.WaitStatus
        END
#END

@Abort

        // Release the thread lock so we don't violate the object->thread
        // lock ordering.

        KiReleaseThreadElevated ( thread )

        // Remove our wait block from every object we enqueued it to.

        j := 0

        WHILE j < i DO
            waitblock = &waitblocktable[j]

            object = waitblock^.Object

            // Acquire the object lock.

            KiAcquireObjectElevated ( object )

            // Remove the wait block.

            RtlRemoveEntryList ( &waitblock^.Entry )

            // Release the object lock.

            KiReleaseObjectElevated ( object )

            j += 1
        END

        IF hastimeout THEN
            // We need to get rid of the timer.

            waitblock = &thread^.TimeoutWaitBlock
            timer = &thread^.Timeout

            // Dequeue it.

            KeDequeueTimer ( timer )

            // Remove the wait block.
            // We *still* don't need the lock because we've been nonpreemptible
            // and blocking out the expiration DPC for this processor the whole
            // time.

            RtlRemoveEntryList ( &waitblock^.Entry )
        END

        KiSetWaitAttempt ( thread, KI_THREAD_WAIT_NONE )

        KiLowerIpl ( ipl )

        RETURN status
    END

    // The wait shall proceed.

    KiSetWaitAttempt ( thread, KI_THREAD_WAIT_COMMITTED )

    status = KiWaitThread (
        thread, // thread
        ipl, // waitipl
        waitmode, // waitmode
        alertable, // alertable
    )

    // KiWaitThread returns at the specified IPL and with the thread lock
    // released. All of our wait blocks have been dequeued, timer dequeued,
    // etc.

    IF status == OS_STATUS_KERNEL_APC THEN
        GOTO Retry
    END

    RETURN status
END