//
// Contains all of the "restartable sections" for atomics on fox32.
// If an exception occurs during one of these sections, the program counter is
// reset to the beginning. We group them together so that we don't have to check
// for PC being inbetween each of them on every exception, only when we found it
// between KepRestartableSections and KepRestartableSectionsEnd.
//

#INCLUDE "../Kep.hjk"

#ASM [

KepRestartableSections:
.global KepRestartableSections


// a0 - ptr
// a1 - inc
// outputs:
// a3 - old value
KeIncrementUlong:
.export KeIncrementUlong

    mov  a3, [a0]
    add  [a0], a1

KepIncrementUlongEnd:
.global KepIncrementUlongEnd

    ret

// a0 - ptr
// a1 - bitset
// outputs:
// a3 - origvalue
KeOrUlong:
.export KeOrUlong

    mov  a3, [a0]
    or   [a0], a1

KepOrUlongEnd:
.global KepOrUlongEnd

    ret

// a0 - ptr
// a1 - bitmask
// outputs:
// a3 - origvalue
KeMaskUlong:
.export KeMaskUlong

    mov  a3, [a0]
    and  [a0], a1

KepMaskUlongEnd:
.global KepMaskUlongEnd

    ret

// a0 - ptr
// a1 - newvalue
// outputs:
// a3 - origvalue
KeFetchAndSetUlong:
.export KeFetchAndSetUlong

    mov  a3, [a0]
    mov  [a0], a1

KepFetchAndSetUlongEnd:
.global KepFetchAndSetUlongEnd

    ret

// a0 - ptr
// a1 - newvalue
// a2 - expectedvalue
// outputs:
// a3 - origvalue
KeCompareSwapUlong:
.export KeCompareSwapUlong
    
    mov  a3, [a0]
    cmp  a3, a2
    ifnz rjmp KepCompareSwapUlongEnd
    mov  [a0], a1

KepCompareSwapUlongEnd:
.global KepCompareSwapUlongEnd

    ret

// a0 - ptr
// a1 - newvalue
// a2 - expectedvalue
// outputs:
// a3 - origvalue
// a2 - aborted
KeCompareSwapUlongAbortOnFault:
.export KeCompareSwapUlongAbortOnFault
    
    mov  a3, [a0]
    cmp  a3, a2
    ifnz rjmp KepCompareSwapUlongAbortEnd
    mov  [a0], a1

KepCompareSwapUlongAbortEnd:
.global KepCompareSwapUlongAbortEnd

    mov  a2, 0

    ret

KepCompareSwapUlongAbort:
.global KepCompareSwapUlongAbort

    // We took a page fault while attempting the CAS. Return something that
    // is guaranteed not to be equal to the expectedvalue, thereby making the
    // CAS look like a failure.

    mov  a3, a2
    add  a3, 1

    mov  a2, 1

    ret

#MACRO KepAcquireLockSharedLoop ( slow ) [
    mov  t0, [a0]
    and  t0, KEP_LOCK_C_BITS
    ifnz rjmp slow
    add  [a0], KEP_LOCK_SHARE_INC
]

// a0 - lock
// outputs:
// a3 - oldipl
KeAcquireApcLockShared:
.export KeAcquireApcLockShared

    movz.8 a3, [(KEP_CURRENT_PRB_ADDR + KepPrb_Ipl)]
    mov.8 [(KEP_CURRENT_PRB_ADDR + KepPrb_Ipl)], KEP_IPL_APC

KepAcquireApcLockSharedStart:
.global KepAcquireApcLockSharedStart

    KepAcquireLockSharedLoop ( KepAcquireApcLockSharedSlow )

KepAcquireApcLockSharedEnd:
.global KepAcquireApcLockSharedEnd

    ret

KepAcquireApcLockSharedSlow:
    mov  a1, a3
    jmp  KepAcquireLockShared

// a0 - lock
KeAcquireLockShared:
.export KeAcquireLockShared

    KepAcquireLockSharedLoop ( KepAcquireLockSharedSlow )

KepAcquireLockSharedEnd:
.global KepAcquireLockSharedEnd

    ret

KepAcquireLockSharedSlow:
    movz.8 a1, [(KEP_CURRENT_PRB_ADDR + KepPrb_Ipl)]
    jmp  KepAcquireLockShared

#MACRO KepAcquireLockExclusiveLoop ( slow ) [
    cmp  [a0], 0
    ifnz rjmp slow
    mov  [a0], t1
]

// a0 - lock
// outputs:
// a3 - oldipl
KeAcquireApcLockExclusive:
.export KeAcquireApcLockExclusive

    movz.8 a3, [(KEP_CURRENT_PRB_ADDR + KepPrb_Ipl)]
    mov.8 [(KEP_CURRENT_PRB_ADDR + KepPrb_Ipl)], KEP_IPL_APC

    mov  t1, [(KEP_CURRENT_PRB_ADDR + KepPrb_CurrentThread)]
    or   t1, KEP_LOCK_WRITE_LOCKED

KepAcquireApcLockExclusiveStart:
.global KepAcquireApcLockExclusiveStart

    KepAcquireLockExclusiveLoop ( KepAcquireApcLockExclusiveSlow )

KepAcquireApcLockExclusiveEnd:
.global KepAcquireApcLockExclusiveEnd

    ret

KepAcquireApcLockExclusiveSlow:

    mov  a1, a3
    jmp  KepAcquireLockExclusive

// a0 - lock
// outputs:
// a3 - success
KeTryAcquireLockExclusive:
.export KeTryAcquireLockExclusive

    mov  t1, [(KEP_CURRENT_PRB_ADDR + KepPrb_CurrentThread)]
    or   t1, KEP_LOCK_WRITE_LOCKED

KepTryAcquireLockExclusiveStart:
.global KepTryAcquireLockExclusiveStart

    KepAcquireLockExclusiveLoop ( KepTryAcquireLockFailure )

KepTryAcquireLockExclusiveEnd:
.global KepTryAcquireLockExclusiveEnd

    movz.8 a3, 1
    ret

KepTryAcquireLockFailure:

    movz.8 a3, 0
    ret

// a0 - lock
KeAcquireLockExclusive:
.export KeAcquireLockExclusive

    mov  t1, [(KEP_CURRENT_PRB_ADDR + KepPrb_CurrentThread)]
    or   t1, KEP_LOCK_WRITE_LOCKED

KepAcquireLockExclusiveStart:
.global KepAcquireLockExclusiveStart

    KepAcquireLockExclusiveLoop ( KepAcquireLockExclusiveSlow )

KepAcquireLockExclusiveEnd:
.global KepAcquireLockExclusiveEnd

    ret

KepAcquireLockExclusiveSlow:
    movz.8 a1, [(KEP_CURRENT_PRB_ADDR + KepPrb_Ipl)]
    jmp  KepAcquireLockExclusive

// Release

#MACRO ReleaseLock ( startlabel, endlabel, slow ) [

#IF BLD_CHK
    cmp  [a0], 0
    ifz  rjmp KepNotLocked
#END

startlabel:
.global startlabel

    // Load the lock word.

    mov  t0, [a0]

    // Isolate the waiters bit.

    mov  t1, t0
    and  t1, KEP_LOCK_WAITERS
    ifnz jmp slow

    movz.8 t2, 0

    mov  t1, t0
    and  t1, KEP_LOCK_WRITE_LOCKED
    ifnz rjmp .notshared

    // We're a shared holder, so decrement the share count.

    mov  t2, t0
    sub  t2, KEP_LOCK_SHARE_INC

.notshared:

    // Store the new lock word.

    mov  [a0], t2

endlabel:
.global endlabel

]

// a0 - lock
KeReleaseLock:
.export KeReleaseLock

    ReleaseLock ( KepReleaseLockStart, KepReleaseLockEnd, KepReleaseLock )

    ret

// a0 - lock
// a1 - oldipl
KeReleaseApcLock:
.export KeReleaseApcLock

    ReleaseLock (
        KepReleaseApcLockStart, KepReleaseApcLockEnd, KepReleaseApcLockSlow
    )

    // The lock is APC-safe, so lower IPL.

    mov.8 [(KEP_CURRENT_PRB_ADDR + KepPrb_Ipl)], a1

    mov  t0, [(KEP_CURRENT_PRB_ADDR + KepPrb_PendingSoftwareInterrupts)]
    srl  t0, a1
    ifnz rjmp KeReleaseApcLockDispatch

    ret

KeReleaseApcLockDispatch:

    mov  a0, a1
    jmp  KepDispatchSoftwareInterrupts

KepReleaseApcLockSlow:

    push fp
    mov  fp, sp
    push a1
    
    call KepReleaseLock

    pop  a1
    pop  fp

    // The lock is APC-safe, so lower IPL.

    mov.8 [(KEP_CURRENT_PRB_ADDR + KepPrb_Ipl)], a1

    mov  t0, [(KEP_CURRENT_PRB_ADDR + KepPrb_PendingSoftwareInterrupts)]
    srl  t0, a1
    ifnz rjmp KeReleaseApcLockDispatch

    ret

#IF BLD_CHK

KepNotLocked:

    push fp
    mov  fp, sp

    mov  a0, KepNotLockedMessage
    mov  a1, 0
    mov  a2, 0
    call KeCrash

KepNotLockedMessage:
    .ds "KeReleaseLock: not locked\n"
    .db 0

.align 4

#END


KepRestartableSectionsEnd:
.global KepRestartableSectionsEnd

]