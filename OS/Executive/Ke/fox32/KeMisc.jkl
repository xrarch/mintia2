//
// Various architecture-specific functions.
//

#INCLUDE "../Kep.hjk"
#INCLUDE "../../Mm/fox32/Mmp.hjk"

PUBLIC KepInterruptsDisabled := TRUE

#ASM [

// a0 - abortblock
// a1 - func
// a2 - context
// a3 - flags
// outputs:
// a3 - status
KeExceptionJacket:
.export KeExceptionJacket

    // Set up an abort state for the current thread.

    push fp
    mov  fp, sp

    push s0
    push s1

    mov  s0, a0

    // Initialize the abort block.

    mov  [s0 + (KeAbortBlock_Context + OsContext_Sp)], sp
    mov  [s0 + (KeAbortBlock_Context + OsContext_Fp)], fp
    mov  [s0 + KeAbortBlock_Flags], a3

    // Save all the non-volatile (callee-saved) registers that we didn't already
    // save on our stack frame.

    mov  [s0 + (KeAbortBlock_Context + OsContext_S2)], s2
    mov  [s0 + (KeAbortBlock_Context + OsContext_S3)], s3
    mov  [s0 + (KeAbortBlock_Context + OsContext_S4)], s4
    mov  [s0 + (KeAbortBlock_Context + OsContext_S5)], s5
    mov  [s0 + (KeAbortBlock_Context + OsContext_S6)], s6
    mov  [s0 + (KeAbortBlock_Context + OsContext_S7)], s7
    mov  [s0 + (KeAbortBlock_Context + OsContext_S8)], s8
    mov  [s0 + (KeAbortBlock_Context + OsContext_S9)], s9
    mov  [s0 + (KeAbortBlock_Context + OsContext_S10)], s10
    mov  [s0 + (KeAbortBlock_Context + OsContext_S11)], s11
    mov  [s0 + (KeAbortBlock_Context + OsContext_S12)], s12
    mov  [s0 + (KeAbortBlock_Context + OsContext_S13)], s13
    mov  [s0 + (KeAbortBlock_Context + OsContext_S14)], s14
    mov  [s0 + (KeAbortBlock_Context + OsContext_S15)], s15
    mov  [s0 + (KeAbortBlock_Context + OsContext_S16)], s16
    mov  [s0 + (KeAbortBlock_Context + OsContext_S17)], s17

    // Link it into the thread. No sync needed because we only access the abort
    // list from the context of this thread.

    // Acquire a pointer to the current thread.

    mov  s1, [(KEP_CURRENT_PRB_ADDR + KepPrb_CurrentThread)]

    // The AbortListHead field is out of range of the fox32 offsets.

    add  s1, KeuThread_AbortListHead
    movz.8 t0, [s1 + KeuThread_ExecutingKapc]
    sla  t0, 2
    add  s1, t0

    mov  [s0 + KeAbortBlock_Next], [s1]
    mov  [s1], s0

    // Call the function.

    mov  a0, a2
    call a1

.return:

    // Unlink the abort block.

    mov  [s1], [s0 + KeAbortBlock_Next]

    // Return normally.

    pop  s1
    pop  s0

    pop  fp
    ret

// s0 - abortblock
// s1 - &thread^.AbortListHead
KepAbortVector:
.global KepAbortVector

    // We get vectored here when an abort occurred. We have to restore state
    // from the abort block.

    mov  sp, [s0 + (KeAbortBlock_Context + OsContext_Sp)]
    mov  fp, [s0 + (KeAbortBlock_Context + OsContext_Fp)]

    // Load the status the caller should receive.

    mov  a3, [s0 + KeAbortBlock_Status]

    // Restore non-volatile state that wasn't saved on the stack frame.

    mov  s2, [s0 + (KeAbortBlock_Context + OsContext_S2)]
    mov  s3, [s0 + (KeAbortBlock_Context + OsContext_S3)]
    mov  s4, [s0 + (KeAbortBlock_Context + OsContext_S4)]
    mov  s5, [s0 + (KeAbortBlock_Context + OsContext_S5)]
    mov  s6, [s0 + (KeAbortBlock_Context + OsContext_S6)]
    mov  s7, [s0 + (KeAbortBlock_Context + OsContext_S7)]
    mov  s8, [s0 + (KeAbortBlock_Context + OsContext_S8)]
    mov  s9, [s0 + (KeAbortBlock_Context + OsContext_S9)]
    mov  s10, [s0 + (KeAbortBlock_Context + OsContext_S10)]
    mov  s11, [s0 + (KeAbortBlock_Context + OsContext_S11)]
    mov  s12, [s0 + (KeAbortBlock_Context + OsContext_S12)]
    mov  s13, [s0 + (KeAbortBlock_Context + OsContext_S13)]
    mov  s14, [s0 + (KeAbortBlock_Context + OsContext_S14)]
    mov  s15, [s0 + (KeAbortBlock_Context + OsContext_S15)]
    mov  s16, [s0 + (KeAbortBlock_Context + OsContext_S16)]
    mov  s17, [s0 + (KeAbortBlock_Context + OsContext_S17)]

    rjmp KeExceptionJacket.return

// outputs:
// a3 - old interrupt state
KepDisableInterrupts:
.global KepDisableInterrupts

    icl

    mov  a3, [KepInterruptsDisabled]
    mov  [KepInterruptsDisabled], 1

    ret

// a0 - old interrupt state
KepRestoreInterrupts:
.global KepRestoreInterrupts

    icl

    mov  [KepInterruptsDisabled], a0

    cmp  a0, 1
    ifz  jmp .dontenable

    cmp.8 [(KEP_CURRENT_PRB_ADDR + KepPrb_Ipl)], KEP_IPL_DPC
    ifgt jmp .dontenable

    ise

.dontenable:
    
    ret

KepEnableInterrupts:
.global KepEnableInterrupts

    icl

    mov  [KepInterruptsDisabled], 0

    cmp.8 [(KEP_CURRENT_PRB_ADDR + KepPrb_Ipl)], KEP_IPL_DPC
    ifgt jmp .dontenable

    ise

.dontenable:

    ret

// outputs:
// a3 - thread
KeCurrentThread:
.export KeCurrentThread

    mov  a3, [(KEP_CURRENT_PRB_ADDR + KepPrb_CurrentThread)]

    ret

// outputs:
// a3 - process
KeCurrentProcess:
.export KeCurrentProcess

    mov  t0, [(KEP_CURRENT_PRB_ADDR + KepPrb_CurrentThread)]
    mov  a3, [t0 + KeuThread_Process]

    ret

// outputs:
// a3 - current processor ID
KepCurrentProcessor:
.global KepCurrentProcessor

    mov  a3, 0

    ret

KepWaitForInterrupt:
.global KepWaitForInterrupt

    halt

    ret

// outputs:
// a3 - current IPL
KepCurrentIpl:
.global KepCurrentIpl

    movz.8 a3, [(KEP_CURRENT_PRB_ADDR + KepPrb_Ipl)]

    ret

KeBreakpoint:
.export KeBreakpoint

    push fp
    mov  fp, sp

    brk

    pop fp

    ret

// a0 - keepglobal
KeuSweepMyTb:
.global KeuSweepMyTb

    // Set the page directory back to that of the current process.
    // This will not switch address spaces but it does cause a TB flush on
    // fox32.

    mov  t0, [(KEP_CURRENT_PRB_ADDR + KepPrb_CurrentThread)]
    mov  t0, [t0 + KeuThread_Process]
    mov  t0, [t0 + KeuProcess_PageDirectoryPfn]
    sla  t0, 12
    tlb  t0

    ret

// a0 - virtual address
KeuFlushMyTbAddress:
.global KeuFlushMyTbAddress

    flp  a0

    ret

]

FN KeuSweepTb (
    IN keepglobal : UWORD,
)

    // Flush the entire TB on all processors.

    KeuSweepMyTb ( keepglobal )
END

FN KeuFlushSingleTb (
    IN vaddr : ^VOID,
)

    // Flush a single TB entry on all processors.

    KeuFlushMyTbAddress ( vaddr )
END

FN KeuFlushMultipleTb (
    IN vaddrtable : ^^VOID,
    IN pagecount : UWORD,
)

    // Flush multiple TB entries on all processors.

    WHILE pagecount DO
        KeuFlushMyTbAddress ( vaddrtable^ )

        vaddrtable += SIZEOF ^VOID
        pagecount -= 1
    END
END