//
// Implements low-level exception handling for fox32.
//

#INCLUDE "../Kep.hjk"

#INCLUDE "<ll>/System/OsSignal.hjk"

#INCLUDE "<inc>/Mmu.hjk"

// The exact interface to the HAL for interrupts is private to the architecture.

EXTERN FN HaluInterrupt (
    IN context : ^OsContext,
    IN vector : UWORD,
)

KepCurrentExceptionCode := 0

#ASM [

#MACRO KepFox32Exception ( code ) [
    mov [KepCurrentExceptionCode], code
    rjmp KepExceptionVector
]

StartOfFirst:

KepFox32Exception ( 0 )

EndOfFirst:

KepFox32Exception ( 1 )
KepFox32Exception ( 2 )
KepFox32Exception ( 3 )
KepFox32Exception ( 4 )
KepFox32Exception ( 5 )
KepFox32Exception ( 6 )
KepFox32Exception ( 7 )
KepFox32Exception ( 8 )
KepFox32Exception ( 9 )
KepFox32Exception ( 10 )
KepFox32Exception ( 11 )
KepFox32Exception ( 12 )
KepFox32Exception ( 13 )
KepFox32Exception ( 14 )
KepFox32Exception ( 15 )
KepFox32Exception ( 16 )
KepFox32Exception ( 17 )
KepFox32Exception ( 18 )
KepFox32Exception ( 19 )
KepFox32Exception ( 20 )
KepFox32Exception ( 21 )
KepFox32Exception ( 22 )
KepFox32Exception ( 23 )
KepFox32Exception ( 24 )
KepFox32Exception ( 25 )
KepFox32Exception ( 26 )
KepFox32Exception ( 27 )
KepFox32Exception ( 28 )
KepFox32Exception ( 29 )
KepFox32Exception ( 30 )
KepFox32Exception ( 31 )
KepFox32Exception ( 32 )
KepFox32Exception ( 33 )
KepFox32Exception ( 34 )
KepFox32Exception ( 35 )
KepFox32Exception ( 36 )
KepFox32Exception ( 37 )
KepFox32Exception ( 38 )
KepFox32Exception ( 39 )
KepFox32Exception ( 40 )
KepFox32Exception ( 41 )
KepFox32Exception ( 42 )
KepFox32Exception ( 43 )
KepFox32Exception ( 44 )
KepFox32Exception ( 45 )
KepFox32Exception ( 46 )
KepFox32Exception ( 47 )
KepFox32Exception ( 48 )
KepFox32Exception ( 49 )
KepFox32Exception ( 50 )
KepFox32Exception ( 51 )
KepFox32Exception ( 52 )
KepFox32Exception ( 53 )
KepFox32Exception ( 54 )
KepFox32Exception ( 55 )
KepFox32Exception ( 56 )
KepFox32Exception ( 57 )
KepFox32Exception ( 58 )
KepFox32Exception ( 59 )
KepFox32Exception ( 60 )
KepFox32Exception ( 61 )
KepFox32Exception ( 62 )
KepFox32Exception ( 63 )
KepFox32Exception ( 64 )
KepFox32Exception ( 65 )
KepFox32Exception ( 66 )
KepFox32Exception ( 67 )
KepFox32Exception ( 68 )
KepFox32Exception ( 69 )
KepFox32Exception ( 70 )
KepFox32Exception ( 71 )
KepFox32Exception ( 72 )
KepFox32Exception ( 73 )
KepFox32Exception ( 74 )
KepFox32Exception ( 75 )
KepFox32Exception ( 76 )
KepFox32Exception ( 77 )
KepFox32Exception ( 78 )
KepFox32Exception ( 79 )
KepFox32Exception ( 80 )
KepFox32Exception ( 81 )
KepFox32Exception ( 82 )
KepFox32Exception ( 83 )
KepFox32Exception ( 84 )
KepFox32Exception ( 85 )
KepFox32Exception ( 86 )
KepFox32Exception ( 87 )
KepFox32Exception ( 88 )
KepFox32Exception ( 89 )
KepFox32Exception ( 90 )
KepFox32Exception ( 91 )
KepFox32Exception ( 92 )
KepFox32Exception ( 93 )
KepFox32Exception ( 94 )
KepFox32Exception ( 95 )
KepFox32Exception ( 96 )
KepFox32Exception ( 97 )
KepFox32Exception ( 98 )
KepFox32Exception ( 99 )
KepFox32Exception ( 100 )
KepFox32Exception ( 101 )
KepFox32Exception ( 102 )
KepFox32Exception ( 103 )
KepFox32Exception ( 104 )
KepFox32Exception ( 105 )
KepFox32Exception ( 106 )
KepFox32Exception ( 107 )
KepFox32Exception ( 108 )
KepFox32Exception ( 109 )
KepFox32Exception ( 110 )
KepFox32Exception ( 111 )
KepFox32Exception ( 112 )
KepFox32Exception ( 113 )
KepFox32Exception ( 114 )
KepFox32Exception ( 115 )
KepFox32Exception ( 116 )
KepFox32Exception ( 117 )
KepFox32Exception ( 118 )
KepFox32Exception ( 119 )
KepFox32Exception ( 120 )
KepFox32Exception ( 121 )
KepFox32Exception ( 122 )
KepFox32Exception ( 123 )
KepFox32Exception ( 124 )
KepFox32Exception ( 125 )
KepFox32Exception ( 126 )
KepFox32Exception ( 127 )
KepFox32Exception ( 128 )
KepFox32Exception ( 129 )
KepFox32Exception ( 130 )
KepFox32Exception ( 131 )
KepFox32Exception ( 132 )
KepFox32Exception ( 133 )
KepFox32Exception ( 134 )
KepFox32Exception ( 135 )
KepFox32Exception ( 136 )
KepFox32Exception ( 137 )
KepFox32Exception ( 138 )
KepFox32Exception ( 139 )
KepFox32Exception ( 140 )
KepFox32Exception ( 141 )
KepFox32Exception ( 142 )
KepFox32Exception ( 143 )
KepFox32Exception ( 144 )
KepFox32Exception ( 145 )
KepFox32Exception ( 146 )
KepFox32Exception ( 147 )
KepFox32Exception ( 148 )
KepFox32Exception ( 149 )
KepFox32Exception ( 150 )
KepFox32Exception ( 151 )
KepFox32Exception ( 152 )
KepFox32Exception ( 153 )
KepFox32Exception ( 154 )
KepFox32Exception ( 155 )
KepFox32Exception ( 156 )
KepFox32Exception ( 157 )
KepFox32Exception ( 158 )
KepFox32Exception ( 159 )
KepFox32Exception ( 160 )
KepFox32Exception ( 161 )
KepFox32Exception ( 162 )
KepFox32Exception ( 163 )
KepFox32Exception ( 164 )
KepFox32Exception ( 165 )
KepFox32Exception ( 166 )
KepFox32Exception ( 167 )
KepFox32Exception ( 168 )
KepFox32Exception ( 169 )
KepFox32Exception ( 170 )
KepFox32Exception ( 171 )
KepFox32Exception ( 172 )
KepFox32Exception ( 173 )
KepFox32Exception ( 174 )
KepFox32Exception ( 175 )
KepFox32Exception ( 176 )
KepFox32Exception ( 177 )
KepFox32Exception ( 178 )
KepFox32Exception ( 179 )
KepFox32Exception ( 180 )
KepFox32Exception ( 181 )
KepFox32Exception ( 182 )
KepFox32Exception ( 183 )
KepFox32Exception ( 184 )
KepFox32Exception ( 185 )
KepFox32Exception ( 186 )
KepFox32Exception ( 187 )
KepFox32Exception ( 188 )
KepFox32Exception ( 189 )
KepFox32Exception ( 190 )
KepFox32Exception ( 191 )
KepFox32Exception ( 192 )
KepFox32Exception ( 193 )
KepFox32Exception ( 194 )
KepFox32Exception ( 195 )
KepFox32Exception ( 196 )
KepFox32Exception ( 197 )
KepFox32Exception ( 198 )
KepFox32Exception ( 199 )
KepFox32Exception ( 200 )
KepFox32Exception ( 201 )
KepFox32Exception ( 202 )
KepFox32Exception ( 203 )
KepFox32Exception ( 204 )
KepFox32Exception ( 205 )
KepFox32Exception ( 206 )
KepFox32Exception ( 207 )
KepFox32Exception ( 208 )
KepFox32Exception ( 209 )
KepFox32Exception ( 210 )
KepFox32Exception ( 211 )
KepFox32Exception ( 212 )
KepFox32Exception ( 213 )
KepFox32Exception ( 214 )
KepFox32Exception ( 215 )
KepFox32Exception ( 216 )
KepFox32Exception ( 217 )
KepFox32Exception ( 218 )
KepFox32Exception ( 219 )
KepFox32Exception ( 220 )
KepFox32Exception ( 221 )
KepFox32Exception ( 222 )
KepFox32Exception ( 223 )
KepFox32Exception ( 224 )
KepFox32Exception ( 225 )
KepFox32Exception ( 226 )
KepFox32Exception ( 227 )
KepFox32Exception ( 228 )
KepFox32Exception ( 229 )
KepFox32Exception ( 230 )
KepFox32Exception ( 231 )
KepFox32Exception ( 232 )
KepFox32Exception ( 233 )
KepFox32Exception ( 234 )
KepFox32Exception ( 235 )
KepFox32Exception ( 236 )
KepFox32Exception ( 237 )
KepFox32Exception ( 238 )
KepFox32Exception ( 239 )
KepFox32Exception ( 240 )
KepFox32Exception ( 241 )
KepFox32Exception ( 242 )
KepFox32Exception ( 243 )
KepFox32Exception ( 244 )
KepFox32Exception ( 245 )
KepFox32Exception ( 246 )
KepFox32Exception ( 247 )
KepFox32Exception ( 248 )
KepFox32Exception ( 249 )
KepFox32Exception ( 250 )
KepFox32Exception ( 251 )
KepFox32Exception ( 252 )
KepFox32Exception ( 253 )
KepFox32Exception ( 254 )
KepFox32Exception ( 255 )
KepFox32Exception ( 256 )
KepFox32Exception ( 257 )
KepFox32Exception ( 258 )
KepFox32Exception ( 259 )
KepFox32Exception ( 260 )
KepFox32Exception ( 261 )
KepFox32Exception ( 262 )
KepFox32Exception ( 263 )
KepFox32Exception ( 264 )
KepFox32Exception ( 265 )
KepFox32Exception ( 266 )
KepFox32Exception ( 267 )
KepFox32Exception ( 268 )
KepFox32Exception ( 269 )
KepFox32Exception ( 270 )
KepFox32Exception ( 271 )

KepExceptionVector:
.export KepExceptionVector

    push fp
    push r31
    push tp
    push at
    push s17
    push s16
    push s15
    push s14
    push s13
    push s12
    push s11
    push s10
    push s9
    push s8
    push s7
    push s6
    push s5
    push s4
    push s3
    push s2
    push s1
    push s0
    push a3
    push a2
    push a1
    push a0
    push t6
    push t5
    push t4
    push t3
    push t2
    push t1
    push t0
    sub  sp, 4 // Skip OldIpl
    mov  a0, sp
    mov  fp, sp

    sub  sp, 3 // Alignment

    mov  a1, [KepCurrentExceptionCode]
    call KepExceptionHandler

    add  sp, 7 // Alignment + OldIpl
    pop  t0
    pop  t1
    pop  t2
    pop  t3
    pop  t4
    pop  t5
    pop  t6
    pop  a0
    pop  a1
    pop  a2
    pop  a3
    pop  s0
    pop  s1
    pop  s2
    pop  s3
    pop  s4
    pop  s5
    pop  s6
    pop  s7
    pop  s8
    pop  s9
    pop  s10
    pop  s11
    pop  s12
    pop  s13
    pop  s14
    pop  s15
    pop  s16
    pop  s17
    pop  at
    pop  tp
    pop  r31
    pop  fp
    add  sp, 4
    reti


DbgExcEnd:
.export DbgExcEnd

// outputs:
// a3 - oldipl
KeMaskApcs:
.export KeMaskApcs

    movz.8 a0, KEP_IPL_APC           // Set argument to KepRaiseIpl.

    // Fall through.

// a0 - newipl
// outputs:
// a3 - oldipl
KepRaiseIpl:
.global KepRaiseIpl

    // Load the old IPL.

    movz.8 a3, [(KEP_CURRENT_PRB_ADDR + KepPrb_Ipl)]

    // Store the new IPL.

    mov.8 [(KEP_CURRENT_PRB_ADDR + KepPrb_Ipl)], a0

#IF BLD_CHK

    cmp  a0, a3
    iflt rjmp .badraise

#END

    ret

#IF BLD_CHK

.badraise:

    push fp
    mov  fp, sp

    mov  a0, KepBadRaiseMessage
    mov  a1, 0
    mov  a2, 0
    call KeCrash

#END

// a0 - newipl
KeUnmaskApcs:
.export KeUnmaskApcs

    // Fall through.

// a0 - newipl
KepLowerIpl:
.global KepLowerIpl

#IF BLD_CHK

    movz.8 t0, [(KEP_CURRENT_PRB_ADDR + KepPrb_Ipl)]
    cmp  t0, a0
    iflt rjmp .badlower

#END

    // Store the new IPL.

    mov.8 [(KEP_CURRENT_PRB_ADDR + KepPrb_Ipl)], a0

    mov  t0, [(KEP_CURRENT_PRB_ADDR + KepPrb_PendingSoftwareInterrupts)]
    srl  t0, a0
    ifnz jmp KepDispatchSoftwareInterrupts

    ret

#IF BLD_CHK

.badlower:

    push fp
    mov  fp, sp

    mov  a0, KepBadLowerMessage
    mov  a1, 0
    mov  a2, 0
    call KeCrash

#END

KepBadRaiseMessage:
    .ds "KepRaiseIpl: oldipl > newipl\n"
    .db 0

KepBadLowerMessage:
    .ds "KepLowerIpl: newipl > oldipl\n"
    .db 0

.align 4

// a0 - process
KepSwitchAddressSpace:
.global KepSwitchAddressSpace

    mov  t0, [a0 + KeuProcess_PageDirectoryPfn]
    sla  t0, 12
    tlb  t0

    ret

KepThreadTrampoline:

    // This is where a new thread begins execution.
    // s0 contains the start function, s1 and s2 contain context pointers.

    // We're at KEP_IPL_DPC, so lower that now.

    mov  a0, KEP_IPL_LOW
    call KepLowerIpl

    // Set FP to 0 so that stack traces terminate here.

    mov  fp, 0

    // Push a couple zeroes too for good measure.

    push 0
    push 0

    // Jump to the start function.

    mov  a0, s1
    mov  a1, s2
    jmp  s0


// a0 - newthread
// a1 - oldthread
KepSwitchContext:
.global KepSwitchContext

    // Save the current context and restore the new.
    // We only need to save the callee-saved registers as this has the same
    // considerations as a function call that trashes them all.
    // We must also release the old thread's thread lock on our way out, after
    // we have fully left its context.

    push fp

    sub  sp, 13 // Skip Eflags, BadAddr, Epc, Sp
    push fp
    push r31
    push tp
    push at
    push s17
    push s16
    push s15
    push s14
    push s13
    push s12
    push s11
    push s10
    push s9
    push s8
    push s7
    push s6
    push s5
    push s4
    push s3
    push s2
    push s1
    push s0
    sub  sp, 48 // Skip volatile fields

    mov  [a1 + KeuThread_Context], sp

    // Fall-through

// a0 - thread
KepJumpIntoThread:
.global KepJumpIntoThread

    mov  esp, [a0 + KeuThread_KernelStackTop]
    mov  sp, [a0 + KeuThread_Context]

    // Set thread to RUNNING.

    mov.8 [a0 + KeuThread_Status], KE_THREAD_RUNNING

    // If there are any KAPCs pending in the new thread, set int at KEP_IPL_APC
    // pending.

    mov  t0, a0
    add  t0, KeuThread_KapcListHead
    mov  t1, [a0 + (KeuThread_KapcListHead + RtlListEntry_Next)]
    sub  t0, t1
    ifz  rjmp .none

    or   [(KEP_CURRENT_PRB_ADDR + KepPrb_PendingSoftwareInterrupts)], (
        1 << ((KEP_IPL_APC) - 1)
    )

.none:

    add  sp, 48 // Skip volatile fields
    pop  s0
    pop  s1
    pop  s2
    pop  s3
    pop  s4
    pop  s5
    pop  s6
    pop  s7
    pop  s8
    pop  s9
    pop  s10
    pop  s11
    pop  s12
    pop  s13
    pop  s14
    pop  s15
    pop  s16
    pop  s17
    pop  at
    pop  tp
    pop  r31
    pop  fp
    add  sp, 17 // Skip Eflags, BadAddr, Epc, Sp, Fp

    ret

]

KepCauseNames : ^UBYTE[16] = {
    [OS_FOX32_EXC_DIV_ZERO] = "DIVBYZERO",
    [OS_FOX32_EXC_ILLEGAL] = "ILLEGAL",
    [OS_FOX32_EXC_READ_FAULT] = "READFAULT",
    [OS_FOX32_EXC_WRITE_FAULT] = "WRITEFAULT",
    [OS_FOX32_EXC_DEBUGGER] = "DEBUGGER",
    [OS_FOX32_EXC_BUS_ERROR] = "BUSERR",
}

KepExceptionToStatus : OsStatus[16] = {
    [OS_FOX32_EXC_DIV_ZERO] = OS_STATUS_DIVIDE_BY_ZERO,
    [OS_FOX32_EXC_ILLEGAL] = OS_STATUS_ILLEGAL_INSTRUCTION,
    [OS_FOX32_EXC_READ_FAULT] = OS_STATUS_READ_FAULT,
    [OS_FOX32_EXC_WRITE_FAULT] = OS_STATUS_WRITE_FAULT,
    [OS_FOX32_EXC_BUS_ERROR] = OS_STATUS_BUS_ERROR,
}

KepExceptionToSignal : UBYTE[16] = {
    [OS_FOX32_EXC_DIV_ZERO] = OS_SIGNAL_FPE,
    [OS_FOX32_EXC_ILLEGAL] = OS_SIGNAL_ILL,
    [OS_FOX32_EXC_READ_FAULT] = OS_SIGNAL_ACV,
    [OS_FOX32_EXC_WRITE_FAULT] = OS_SIGNAL_ACV,
    [OS_FOX32_EXC_BUS_ERROR] = OS_SIGNAL_BUS,
}

FN KepFaultCrash (
    IN context : ^OsContext,
    IN ecause : UWORD,
)

    prb := KEP_CURRENT_PRB_LOCAL

    IF prb^.FrozenContext THEN
        RtlPrint ( "CPU%d OLD CONTEXT: 0x%p\n", prb^.FrozenContext )
    END

    prb^.FrozenContext = context

    KeCrash (
        "EFLAGS=%02x BADADDR=%08x EPC=%08x ECAUSE=%s\n", // fmt
        context^.Eflags,
        context^.BadAddr,
        context^.Epc,
        KepCauseNames[ecause],
    )
END

EXTERN KepAbortVector : UBYTE

FN KepAbort (
    IN thread : ^KeuThread,
    IN context : ^OsContext,
    IN status : OsStatus,
    IN ecause : UWORD,
)

    // Abort the current operation of the thread.

    IF NOT OsStatusIsAddressError ( status ) THEN
        // Not an address error status, so aborting is nonsense.

        KepFaultCrash ( context, ecause )
    END

    abortblock := thread^.AbortListHead[thread^.ExecutingKapc]

    IF NOT abortblock OR MmuShouldAccessCrash (
        abortblock, // abortblock
        CAST context^.BadAddr TO ^VOID, // badaddr
        status, // status
    ) THEN
        // No abortable operation was in progress, or this abort block isn't
        // catching this type of error. This is just a kernel bug.

        KepFaultCrash ( context, ecause )
    END

    // Save the status corresponding to the error.

    abortblock^.Status = status

    // Redirect the trap frame to return to the abort vector.

    context^.S0 = abortblock
    context^.S1 = &thread^.AbortListHead[thread^.ExecutingKapc]
    context^.Epc = &KepAbortVector
END

EXTERN FN KepThreadTrampoline ()

EXTERN KepRestartableSections : UBYTE
EXTERN KepRestartableSectionsEnd : UBYTE

EXTERN KepIncrementUlongEnd : UBYTE
EXTERN KepOrUlongEnd : UBYTE
EXTERN KepMaskUlongEnd : UBYTE
EXTERN KepFetchAndSetUlongEnd : UBYTE
EXTERN KepCompareSwapUlongEnd : UBYTE
EXTERN KepCompareSwapUlongAbortEnd : UBYTE
EXTERN KepCompareSwapUlongAbort : UBYTE

EXTERN KepAcquireLockSharedEnd : UBYTE
EXTERN KepAcquireLockExclusiveStart : UBYTE
EXTERN KepAcquireLockExclusiveEnd : UBYTE

EXTERN KepTryAcquireLockExclusiveStart : UBYTE
EXTERN KepTryAcquireLockExclusiveEnd : UBYTE

EXTERN KepAcquireApcLockSharedStart : UBYTE
EXTERN KepAcquireApcLockSharedEnd : UBYTE
EXTERN KepAcquireApcLockExclusiveStart : UBYTE
EXTERN KepAcquireApcLockExclusiveEnd : UBYTE

EXTERN KepReleaseLockStart : UBYTE
EXTERN KepReleaseLockEnd : UBYTE

EXTERN KepReleaseApcLockStart : UBYTE
EXTERN KepReleaseApcLockEnd : UBYTE

FN KepResetPc (
    IN context : ^OsContext,
)

    // An exception occurred while the program counter was inside a restartable
    // section. Figure out which one and reset the PC back to the start of it.

    epc := context^.Epc

    IF epc >= &KeIncrementUlong AND
        epc < &KepIncrementUlongEnd THEN

        context^.Epc = &KeIncrementUlong

        LEAVE
    END

    IF epc >= &KeOrUlong AND
        epc < &KepOrUlongEnd THEN

        context^.Epc = &KeOrUlong

        LEAVE
    END

    IF epc >= &KeMaskUlong AND
        epc < &KepMaskUlongEnd THEN

        context^.Epc = &KeMaskUlong

        LEAVE
    END

    IF epc >= &KeFetchAndSetUlong AND
        epc < &KepFetchAndSetUlongEnd THEN

        context^.Epc = &KeFetchAndSetUlong

        LEAVE
    END

    IF epc >= &KeCompareSwapUlong AND
        epc < &KepCompareSwapUlongEnd THEN

        context^.Epc = &KeCompareSwapUlong

        LEAVE
    END

    IF epc >= &KeCompareSwapUlongAbortOnFault AND
        epc < &KepCompareSwapUlongAbortEnd THEN

        context^.Epc = &KeCompareSwapUlongAbortOnFault

        LEAVE
    END

    IF epc >= &KepAcquireApcLockSharedStart AND
        epc < &KepAcquireApcLockSharedEnd THEN

        context^.Epc = &KepAcquireApcLockSharedStart

        LEAVE
    END

    IF epc >= &KepAcquireApcLockExclusiveStart AND
        epc < &KepAcquireApcLockExclusiveEnd THEN

        context^.Epc = &KepAcquireApcLockExclusiveStart

        LEAVE
    END

    IF epc >= &KeAcquireLockShared AND
        epc < &KepAcquireLockSharedEnd THEN

        context^.Epc = &KeAcquireLockShared

        LEAVE
    END

    IF epc >= &KepAcquireLockExclusiveStart AND
        epc < &KepAcquireLockExclusiveEnd THEN

        context^.Epc = &KepAcquireLockExclusiveStart

        LEAVE
    END

    IF epc >= &KepTryAcquireLockExclusiveStart AND
        epc < &KepTryAcquireLockExclusiveEnd THEN

        context^.Epc = &KepTryAcquireLockExclusiveStart

        LEAVE
    END

    IF epc >= &KepReleaseLockStart AND
        epc < &KepReleaseLockEnd THEN

        context^.Epc = &KepReleaseLockStart

        LEAVE
    END

    IF epc >= &KepReleaseApcLockStart AND
        epc < &KepReleaseApcLockEnd THEN

        context^.Epc = &KepReleaseApcLockStart

        LEAVE
    END
END

FNPTR KepExceptionHandlerF (
    IN context : ^OsContext,
    IN ecause : UWORD,
)

FN (KepExceptionHandlerF) KepErrorFault (
    IN context : ^OsContext,
    IN ecause : UWORD,
)

    // An "error" fault occurred. If this happened in kernel mode, figure out
    // if its handled by a SafeCopy function. If not, crash.
    //
    // If it happened in usermode, generate a signal to the thread.

    KepEnableInterrupts ()

    thread := KeCurrentThread ()

    IF context^.Eflags & OS_FOX32_EFLAGS_SWAPSP THEN
        // Happened in usermode, send a signal.

        thread^.LastFaultStatus = KepExceptionToStatus[ecause]

        KeSignalThread (
            thread, // thread
            KepExceptionToSignal[ecause], // signal
        )

    ELSE
        // Happened in kernel mode, abort the operation.

        KepAbort (
            thread, // thread
            context, // context
            KepExceptionToStatus[ecause], // status
            ecause, // ecause
        )
    END

    KepDisableInterrupts ()
END

FN (KepExceptionHandlerF) KepPageFault (
    IN context : ^OsContext,
    IN ecause : UWORD,
)

    // Enable interrupts and dispatch the page fault to Mm.

    IF context^.Epc >= &KeCompareSwapUlongAbortOnFault AND
        context^.Epc < &KepCompareSwapUlongAbortEnd THEN

        // We cannot handle this page fault because the current thread's
        // turnstile is in use; it can't usefully take locks. Abort the CAS
        // operation.

        context^.Epc = &KepCompareSwapUlongAbort

        LEAVE
    END

    KepEnableInterrupts ()

    status := MmuPageFault (
        CAST context^.BadAddr TO ^VOID, // address
        ecause == OS_FOX32_EXC_WRITE_FAULT, // writing
        context^.Eflags & OS_FOX32_EFLAGS_SWAPSP, // usermode
    )

    IF OsError ( status ) THEN
        // Failed to handle the fault.

        thread := KeCurrentThread ()

        IF context^.Eflags & OS_FOX32_EFLAGS_SWAPSP THEN
            // Happened in usermode. Send a signal.

            thread^.LastFaultStatus = status

            KeSignalThread (
                thread, // thread
                OS_SIGNAL_ACV, // signal
            )

        ELSE
            // Happened in kernel mode. Abort the current operation.

            KepAbort (
                thread, // thread
                context, // context
                status, // status
                ecause, // ecause
            )
        END
    END

    KepDisableInterrupts ()
END

FN (KepExceptionHandlerF) KepDebugger (
    IN context : ^OsContext,
    IN ecause : UWORD,
)

    IF context^.Eflags & OS_FOX32_EFLAGS_SWAPSP THEN
        KeCrash ( "NYI usermode breakpoints\n" )

    ELSEIF KeuDebuggerEntry THEN
        KeuDebuggerEntry ( context )

    ELSE
        KeCrash ( "Unhandled kernel mode breakpoint\n" )
    END
END

KepExceptionHandlers : KepExceptionHandlerF[16] = {
    [OS_FOX32_EXC_DIV_ZERO] = &KepErrorFault,
    [OS_FOX32_EXC_ILLEGAL] = &KepErrorFault,
    [OS_FOX32_EXC_READ_FAULT] = &KepPageFault,
    [OS_FOX32_EXC_WRITE_FAULT] = &KepPageFault,
    [OS_FOX32_EXC_DEBUGGER] = &KepDebugger,
    [OS_FOX32_EXC_BUS_ERROR] = &KepErrorFault,
}

EXTERN KepInterruptsDisabled : UWORD

FN KepExceptionHandler (
    IN context : ^OsContext,
    IN exc : UWORD,
)

    dis := KepInterruptsDisabled
    KepInterruptsDisabled = TRUE

    current := KEP_CURRENT_PRB^.CurrentThread

    IF context^.Eflags & OS_FOX32_EFLAGS_SWAPSP THEN
        // We interrupted usermode. Set the user trapframe pointer.

        current^.UserFrame = context
    END

    IF context^.Epc >= &KepRestartableSections AND
        context^.Epc < &KepRestartableSectionsEnd THEN

        // We interrupted an atomic restartable section, so reset PC to the
        // beginning.

        KepResetPc ( context )
    END

    IF exc >= 256 THEN
        KepExceptionHandlers[exc - 256] (
            context, // context
            exc - 256, // ecause
        )

    ELSE
        HaluInterrupt (
            context, // context
            exc, // vector
        )

        prb := KEP_CURRENT_PRB

        ipl := prb^.Ipl

        IF prb^.PendingSoftwareInterrupts >> ipl THEN
            KepDispatchSoftwareInterrupts ( ipl )
        END
    END

    IF context^.Eflags & OS_FOX32_EFLAGS_SWAPSP AND
        current^.UserInterrupt THEN

        // We interrupted usermode. See if any usermode interrupts are pending.

        KepDispatchUserInterrupts ()
    END

    KepInterruptsDisabled = dis
END

EXTERN StartOfFirst : UBYTE
EXTERN EndOfFirst : UBYTE

#SECTION "INITtext"
FN KepInitializeArchitecture (
    IN prb : ^KepPrb,
)

    // Here we must initialize the fox32 IVT in low memory. We still have an
    // identity mapping of the low 4MB from Loader, so we can easily access it
    // through that.

    // Here lay the only intentional use of a null pointer in the whole of the
    // land of MINTIA.

    vec : ^^VOID = 0

    size : UWORD = &EndOfFirst - &StartOfFirst
    ptr := &StartOfFirst

    i := 0

    WHILE i < 272 DO
        vec[i] = ptr

        ptr += size

        i += 1
    END
END

#SECTION "PAGEtext"
FN KepInitializeContext (
    IN thread : ^KeuThread,
    IN kstack : ^VOID,
    IN startfunc : KeStartThreadF,
    IN context1 : UWORD,
    IN context2 : UWORD,
) : ^OsContext

    // Initialize the context for a thread that is about to begin execution.

    retaddr := CAST kstack - 8 TO ^ULONG

    retaddr[1] = &KepThreadTrampoline
    retaddr[0] = 0

    context := CAST (retaddr - SIZEOF OsContext) TO ^OsContext

    context^.S0 = CAST startfunc TO ULONG
    context^.S1 = CAST context1 TO ULONG
    context^.S2 = CAST context2 TO ULONG

    RETURN context
END

#SECTION "PAGEtext"
FN KepInterruptUsermode (
    IN dispatchfunc : ^VOID,
    IN trapframe : ^OsContext,
    IN userfunc : UWORD,
    IN context : UWORD,
    IN thread : ^KeuThread,
)

    // Cause a usermode interrupt of the current thread by saving the context
    // on the user stack and redirecting the trapframe to the usermode
    // interrupt handler. This is used to implement signal and APC dispatch.

    usp := trapframe^.Sp

    usp -= SIZEOF OsContext

    // Save the trapframe to the user stack.
    // If that fails, and the thread has a panic stack, switch to it and copy
    // out to that instead. If THAT fails, terminate the entire process.

    status := MmSafeCopyOut (
        CAST usp TO ^VOID, // dest
        trapframe, // src
        SIZEOF OsContext, // sz
    )

    IF OsError ( status ) THEN
        // Failed to copy out the context frame.
        // This is fatal to the entire process.

        KeSignalProcess (
            thread^.Process, // process
            OS_SIGNAL_KILL, // signal
        )

        LEAVE
    END

    // Redirect the trapframe to the usermode interrupt handler.

    trapframe^.Sp = usp
    trapframe^.Epc = dispatchfunc
    trapframe^.A0 = context
    trapframe^.A1 = usp
    trapframe^.A2 = userfunc
END