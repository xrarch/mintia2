//
// Initialization of the Kernel (Ke) subcomponent of the MINTIA Executive.
//

#INCLUDE "Kep.hjk"
#INCLUDE "<inc>/Psu.hjk"

EXPORT KeuLoaderBlock : BlInfoRecord

EXPORT KeBootNode : ^KeuNode

EXPORT KeMostProcessorsInAnyNode : ULONG

FNPTR DbgMainF ()

#IF BLD_CHK

EXPORT KepAssertionMessage : UBYTE[40]

#END

#IF BLD_MP

KepInitializeCount : ULONG

KepAnnounceSpinlock : KepSpinlock = KEP_INITIAL_SPINLOCK

#MACRO KepAcquireAnnounce () [
    KepAcquireSpinlockRaise ( &KepAnnounceSpinlock )
]

#MACRO KepReleaseAnnounce ( oldipl ) [
    KepReleaseSpinlockLower ( &KepAnnounceSpinlock, oldipl )
]

#ELSE

#MACRO KepAcquireAnnounce () [
    KepRaiseIpl ( KEP_IPL_DPC )
]

#MACRO KepReleaseAnnounce ( oldipl ) [
    KepLowerIpl ( oldipl )
]

#END

// FORWARD
EXTERN FN (KeStartThreadF) KepThreadedMain (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

FN (KeStartThreadF) KepIdleLoop (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

    prb := KEP_CURRENT_PRB_LOCAL

    ipl := KepAcquireAnnounce ()

    RtlPrint ( "KepIdleLoop: Processor %u idling\n", prb^.ConsecutiveId )

    KepReleaseAnnounce ( ipl )

#IF BLD_MP
    // Atomically decrement the initialization count to indicate to the boot
    // processor that we made it into our idle thread.

    KeIncrementUlong (
        &KepInitializeCount, // ptr
        0xFFFFFFFF, // ulong
    )
#END

    WHILE TRUE DO
        KepWaitForInterrupt ()

#IF BLD_MP
        IF prb^.StealWork THEN
            // Time to try stealing work.

            prb^.StealWork = FALSE

            KepStealWork ()
        END
#END
    END
END

#SECTION "INITtext"
FN KepInitializePrb (
    IN prb : ^KepPrb,
    IN kenode : ^KeuNode,
    IN bootprocessor : UWORD,
)

    // Initialize this Prb.

    // Loader stashed words in the Prb at the following indices:
    // 0 - Processor ID
    // 1 - Software IDT pointer
    // 2 - Idle stack pointer
    // 3 - Consecutive ID

    idword := CAST prb TO ^UWORD

    id := idword[0]
    irqdt := idword[1]
    stackbase := idword[2]
    consecid := idword[3]

    // Clear the Prb.

    RtlFillMemoryWithUlong (
        prb, // ptr
        BL_PRB_SIZE, // sz
        0, // ulong
    )

    // Place the stashed words at their proper place.

    prb^.Id = id
    prb^.IrqDispatchTable = CAST irqdt TO ^VOID
    prb^.IdleStackBase = CAST stackbase TO ^VOID
    prb^.ConsecutiveId = consecid

    // On some architectures, the thing we get from KEP_CURRENT_PRB_LOCAL is not
    // a globally visible address for this Prb.

#IF KEP_VIRTUAL_PRB
    prb^.RealVirtual = prb
#END

    RtlInitializeList ( &prb^.DpcListHead )

    RtlInitializeList ( &prb^.StackSwapCandidateListHead )

#IF BLD_MP
    KepInitializeSpinlock ( &prb^.DpcQueueLock )
    KepInitializeSpinlock ( &prb^.ReadyQueueLock )
    KepInitializeSpinlock ( &prb^.TimerTreeLock )
    KepInitializeSpinlock ( &prb^.StackSwapListLock )

    prb^.StashedCurrentThreadInfo = KepSetIdleInStash ( 0, TRUE )
    prb^.IdleDeferredIpiEvents = 0
    prb^.InIdleLoop = TRUE
#END

    KeInitializeDpc (
        &prb^.TimerExpirationDpc, // dpc
        &KepTimerExpiration, // function
    )

#IF ( == BLD_BITS 64 )
    prb^.EarliestTimerMs.Quad = 0xFFFFFFFFFFFFFFFF

#ELSE
    prb^.EarliestTimerMs.Low = 0xFFFFFFFF
    prb^.EarliestTimerMs.High = 0xFFFFFFFF
#END

    prb^.Ipl = KEP_IPL_LOW

    // Initialize the IRQ dispatch table.

    i := 0

    WHILE i < HALU_VECTOR_MAX DO
        prb^.IrqDispatchTable[i] = &KepUnexpectedInterruptObject

        i += 1
    END

    // Initialize the real time scheduler queues.

    i = 0

    WHILE i < OS_PRIORITY_MAX DO
        RtlInitializeList ( &prb^.RealTimeListHeads[i] )

        i += 1
    END

    // Initialize the timeshared scheduler queues.

    i = 0

    WHILE i < KEP_TIMESHARED_QUEUES DO
        RtlInitializeList ( &prb^.CalendarListHeads[i] )

        i += 1
    END

    // Initialize the idle scheduler queue.

    RtlInitializeList ( &prb^.IdleListHead )

    // Initialize the idle thread.

    startfunc : KeStartThreadF

    IF bootprocessor THEN
        startfunc = &KepThreadedMain

    ELSE
        startfunc = &KepIdleLoop
    END

    KeuInitializeThread (
        &kenode^.IdleProcess^.Pcb, // process
        &prb^.IdleThread, // thread
        "IdleThread", // name
        prb^.IdleStackBase, // kstack
        BL_IDLE_STACK_SIZE, // kstacksize
        KeuAllocateInitialTurnstile ( kenode ), // turnstile
        startfunc, // startfunc
        0, // context1
        0, // context2
    )

    prb^.IdleThread.Priority = OS_PRIORITY_IDLE
    prb^.IdleThread.BasePriority = OS_PRIORITY_IDLE

#IF BLD_MP
    prb^.IdleThread.CurrentPrb = prb
#END

    prb^.Node = kenode

    // Initialize frozen context to zero so that the debugger doesn't try to
    // read it if we failed to freeze.

    prb^.FrozenContext = NULLPTR

    // Stash the Prb ID.

    KepStashPrbId ( prb, id )

    // Stash the node pointer.

    KepStashNodePtr ( prb, kenode )
END

#SECTION "INITtext"
FN KeuAllocateNodeSpace (
    IN kenode : ^KeuNode,
    IN bytes : UWORD,
) : ^VOID

    // Allocate some space from the specified node.

    bytes = (bytes + RTL_ALIGN_BYTES - 1) & ~(RTL_ALIGN_BYTES - 1)

    IF kenode^.BumpOffset + bytes > BL_NODE_SIZE THEN
        RETURN NULLPTR
    END

    ptr := kenode + kenode^.BumpOffset
    kenode^.BumpOffset += bytes

    RETURN ptr
END

#SECTION "INITtext"
FN KeuInitializeNode (
    IN kenode : ^KeuNode,
    IN node : ^BlNodeInfo,
)

    // Initialize the given NUMA node.

    // Initialize the bump allocator used for component-private per-node
    // structures.

    kenode^.BumpOffset = SIZEOF KeuNode

    // Initialize various node stuff.

    nodeid := node^.Id

    kenode^.SystemPageDirectoryPfn = node^.SystemPageDirectoryPfn
    kenode^.ProcessorCount = node^.ProcessorCount
    kenode^.Id = nodeid

    kenode^.PoolSpaceSize = node^.PoolSpaceSize
    kenode^.CacheSpaceSize = node^.CacheSpaceSize
    kenode^.DynamicSpaceSize = node^.DynamicSpaceSize

    kenode^.DynamicSpaceBitmap = node^.DynamicSpaceBitmap

    // Allocate a Ke-private part of the node.

    kenode^.Kep = KeuAllocateNodeSpace (
        kenode, // kenode
        SIZEOF KepNode, // bytes
    )

    KeAssert ( kenode^.Kep != NULLPTR )

    kepnode := kenode^.Kep

    // Initialize a per-node idle process.

    PsuInitializeIdleProcess ( kenode )

    // Initialize turnstiles.

    KepInitializeTurnstiles ( kepnode )

    // Initialize the Prbs.

    prb := KepPrbFromNodeAndNumber ( kenode, 0 )

    initprb := prb
    i := 0

    WHILE i < kenode^.ProcessorCount DO
        KepInitializePrb (
            initprb, // prb
            kenode, // kenode
            (i == 0) AND (nodeid == 0), // bootprocessor
        )

        i += 1
        initprb += BL_PRB_SIZE
    END

    // Perform early initialization of the HAL. This will perform baseline
    // initialization of integral platform components such as the interval
    // timer. Also, we get a boot console which is guaranteed to stay sane
    // throughout the lifetime of the system and at any IPL.

    HaluEarlyInitialize ( kenode )

    // Initialize the shared user page.

    kenode^.SharedUserPage = node^.VirtualSharedUserPage

    KepUpdateTime ( kenode, prb )

    // Move the loader's descriptor list head into our node.

    kenode^.DescriptorListHead.Next = node^.DescriptorListHead.Next
    kenode^.DescriptorListHead.Prev = node^.DescriptorListHead.Prev

    // Fix up the circular list head.

    kenode^.DescriptorListHead.Next^.Prev = &kenode^.DescriptorListHead
    kenode^.DescriptorListHead.Prev^.Next = &kenode^.DescriptorListHead

    // Initialize the stack swapper event. This is waited upon by a component
    // of Mm which outswaps kernel stacks and processes.

    KeInitializeEvent (
        &kenode^.StackSwapperEvent, // event
        "StackSwap", // name
        FALSE, // notification
        FALSE, // signalstate
    )

#IF BLD_MP
    // Initialize the work balancing DPC.

    KeInitializeDpc (
        &kepnode^.WorkBalanceDpc, // dpc
        &KepBalanceWork, // func
    )

    // Compute the maximum number of balance iterations as the number of
    // possible pairs between processors plus one. This is the same as the
    // number of possible imbalances plus one for good measure.
    //
    // This is calculated as n choose 2 which simplifies to n(n-1)/2 + 1.

    kepnode^.MaximumBalanceIterations = (kenode^.ProcessorCount *
        (kenode^.ProcessorCount - 1)) / 2 + 1

    IF kepnode^.MaximumBalanceIterations > 64 THEN
        kepnode^.MaximumBalanceIterations = 64
    END

    kepnode^.NextWorkBalanceMs = KEP_WORK_BALANCE_INTERVAL
#END

END

#SECTION "INITtext"
FN KeuInitializeNodes () : ^KepPrb

    // Initialize all the NUMA nodes indicated by the loader.
    // Return a pointer to the boot PRB.

    KeMostProcessorsInAnyNode = 1

    bootprb : ^KepPrb

    listhead := &KeuLoaderBlock.NodeListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        node := CONTAINEROF listentry TO BlNodeInfo.Entry

        id := node^.Id

        kenode := KeNumaNodeById ( id )

        IF id == 0 THEN
            KeBootNode = kenode
            bootprb = KepPrbFromNodeAndNumber ( kenode, 0 )
        END

        KeuInitializeNode (
            kenode, // kenode
            node, // node
        )

        IF kenode^.ProcessorCount > KeMostProcessorsInAnyNode THEN
            KeMostProcessorsInAnyNode = kenode^.ProcessorCount
        END

        listentry = listentry^.Next
    END

    RETURN bootprb
END

#IF BLD_MP

#SECTION "INITtext"
FN (HaluStartProcessorF) KepStartOtherProcessor ()

    // This is the first code that runs in the context of a non-boot processor.
    // We assume any context required to access the Prb has been set up by the
    // Loader. We have to initialize ourselves and then jump into our idle
    // thread to wait for work.

    prb := KEP_CURRENT_PRB

    // Initialize architectural support.

    KepInitializeArchitecture ( prb )

    // Initialize HAL.

    HaluProcessorInitialize ( prb )

    // Become a subject of the dispatcher.

    KepJumpIntoIdleThread ( prb )
END

#END

EXTERN FN ExuStartExecutive ()

#SECTION "INITtext"
FN (KeStartThreadF) KepThreadedMain (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

    // This is the first code that runs in thread context during the lifetime of
    // the system. We need to perform phase 0 initialization of the Executive.

    ExuStartExecutive ()

    // Go into the idle loop.

    KepIdleLoop (
        context1, // context1
        context2, // context2
    )
END

#SECTION "INITtext"
EXPORT FN KeMain (
    IN loaderblock : ^BlInfoRecord,
)

    // At this point:
    //
    // o  We have been transferred to from the Loader.
    // o  We are on a page-sized initial stack.
    // o  We have no thread context - we need to hand-craft one.
    // o  Interrupts are disabled. Paging is enabled.
    // o  The PFN database has been constructed by the Loader for us. Not much
    //    else has been.
    // o  The firmware - no matter what system we are on - is inaccessible, as a
    //    rule, even if we could theoretically use it on some platform. Only
    //    exception are firmware services that *must* be called at certain
    //    points in HAL initialization, and only then.
    // o  The boot processor and boot node (the NUMA node within which the boot
    //    processor resides) have been initialized with software ID zero. The
    //    boot node is the first one on the list.
    //
    // Any pointers from the Loader may or may not be in a spot where they are
    // permanently accessible, since this may or may not be a platform where the
    // Loader is entered with paging enabled. If it wasn't, the Loader ran out
    // of an identity mapping in what is going to become userspace. Therefore
    // anything from loader-space that we need to access during runtime must be
    // be transferred into the Executive between now and the execution of the
    // first usermode process in order to guarantee its safe to touch. Plus, we
    // are going to reclaim all of the Loader's physical memory during Mm init.

#IF BLD_CHK
    // Set this up so that we don't waste space on repeated strings.

    RtlCopyString (
        &KepAssertionMessage[0], // dest
        "ASSERTION FAILED IN %s() AT %s:%d\n%s\n", // src
        40, // bufsize
    )
#END

    // Initialize the KeCrash module.

    KepInitializeCrashing ()

    // Start by copying the loader block into the Executive.

    RtlCopyBytes (
        &KeuLoaderBlock, // dest
        loaderblock, // src
        SIZEOF BlInfoRecord, // sz
    )

    // Fix up the circular lists in the loader block so that they still point to
    // the newly relocated list heads.

    listhead := &KeuLoaderBlock.ResourceListHead

    listhead^.Next^.Prev = listhead
    listhead^.Prev^.Next = listhead

    listhead = &KeuLoaderBlock.DllListHead

    listhead^.Next^.Prev = listhead
    listhead^.Prev^.Next = listhead

    listhead = &KeuLoaderBlock.NodeListHead

    listhead^.Next^.Prev = listhead
    listhead^.Prev^.Next = listhead

    // Initialize the NUMA nodes.

    prb := KeuInitializeNodes ()

    // Initialize architectural support.

    KepInitializeArchitecture ( prb )

    // Now that we have a console, announce ourselves.

    HaluCenterPrint ( "== MINTIA2 BOOT CONSOLE ==\n" )

    // Perform platform-specific initialization for the boot processor.

    KeAssert ( SIZEOF KepPrb <= BL_PRB_SIZE )
    KeAssert ( SIZEOF KeuNode <= BL_NODE_SIZE )

    HaluProcessorInitialize ( prb )

    // Perform early initialization of the debugger.

    IF KeuLoaderBlock.DbgMain THEN
        dbgmain := CAST KeuLoaderBlock.DbgMain TO DbgMainF

        dbgmain ()
    END

#IF BLD_MP
    // We're ready to pull the other processors into the system.

    KepInitializeCount = KeuLoaderBlock.ProcessorCount - 1

    // Bring em in.

    HaluStartProcessors ( &KepStartOtherProcessor )

    // Wait for them to signal that they've been initialized.

    WHILE KepInitializeCount DO
        // Language BARRIER to stop this loop from being optimized out.

        BARRIER
    END
#END

    // Become a subject of the dispatcher.

    KepJumpIntoIdleThread ( prb )

    KeCrash ( "KepJumpIntoThread returned\n" )
END

#IF BLD_MP

EXPORT FN KeQueryProcessorCount () : UWORD

    // Query the number of processors in the system.

    RETURN KeuLoaderBlock.ProcessorCount
END

#END

EXPORT FN KeQueryNodeCount () : UWORD

    // Query the number of NUMA nodes in the system.

    RETURN KeuLoaderBlock.NodeCount
END