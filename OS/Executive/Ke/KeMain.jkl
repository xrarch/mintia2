//
// Initialization of the Kernel (Ke) subcomponent of the MINTIA Executive.
//

#INCLUDE "Ki.hjk"

PUBLIC KeIdleProcess : PsProcess
KiIdleProcessPaged : PsPagedProcess

EXPORT KeLoaderBlock : BlInfoRecord

FNPTR DbgMainF ()

PUBLIC KeSharedUserPage : ^OsSharedUserPage

#IF BLD_MP

KiInitializeCount : ULONG

KiAnnounceSpinlock : KiSpinlock = KI_INITIAL_SPINLOCK

PUBLIC KiWorkBalanceDpc : KeDpc

#MACRO KiAcquireAnnounce () [
    KiAcquireSpinlockRaise ( &KiAnnounceSpinlock )
]

#MACRO KiReleaseAnnounce ( oldipl ) [
    KiReleaseSpinlockLower ( &KiAnnounceSpinlock, oldipl )
]

#ELSE

#MACRO KiAcquireAnnounce () [
    KiRaiseIpl ( KI_IPL_DPC )
]

#MACRO KiReleaseAnnounce ( oldipl ) [
    KiLowerIpl ( oldipl )
]

#END






#DEFINE KI_TEST_THREADS 64
#DEFINE KI_TEST_EVENTS 8

KiTestApcs : KeApc[KI_TEST_THREADS]
KiTestThreads : KeThread[KI_TEST_THREADS]
KiTestThreadsStacks : ULONG[512 * KI_TEST_THREADS]
KiTestEvents : KeEvent[KI_TEST_EVENTS]
KiTestSemaphore : KeSemaphore
KiTestQueue : KeBalancedQueue

PUBLIC KiTestLock : KeLock = KE_INITIAL_LOCK
PUBLIC KiTestLock2 : KeLock = KE_INITIAL_LOCK

#DEFINE KI_TEST_LOCKS 2

PUBLIC KiTestLocks : KeLock[KI_TEST_LOCKS]
PUBLIC KiTestApcLock : KeLock
PUBLIC KiTestApcLock2 : KeLock

TestListHead : RtlListEntry
TestListItem1 : RtlListEntry
TestListItem2 : RtlListEntry
Item1Inserted : UBYTE
Item2Inserted : UBYTE

PUBLIC Counter := 0

HeapBlockSize : UINT[16] = {
    32, 17, 1023, 63, 500, 300, 72, 900,
    1000, 900, 800, 700, 600, 1900, 400, 1500,
}

BigBlockSize : UINT[16] = {
    4096, 8192, 16384, 3072, 5000, 9000, 8000, 7000,
    6000, 4000, 3000, 10000, 11000, 12000, 13000, 14000,
}

#INCLUDE "<inc>/Mm.hjk"

ShareDepth := 0

FN TestLoop ( IN i : UWORD )

    j := 0

        WHILE j < KI_TEST_LOCKS DO
            KeAcquireLockExclusive ( &KiTestLocks[j] )

            j += 1
        END

    j = 0

    WHILE j < KI_TEST_LOCKS DO
        KeReleaseLock ( &KiTestLocks[j] )

        j += 1
    END


END

FN (KeApcF) KiTestApcFunction2 (
    IN apc : ^KeApc,
    IN context1 : UWORD,
    IN context2 : UWORD,
    IN rundown : UWORD,
)

    i := 3
    j := 2

    IF context1 % 11 < 6 THEN
        RtlPrint ( "X " )

        KeAcquireLockExclusive ( &KiTestApcLock )
    ELSE
        RtlPrint ( "S " )

        KeAcquireLockShared ( &KiTestApcLock )

        IF KeTryConvertLockToExclusive ( &KiTestApcLock ) THEN
            RtlPrint ( "D " )

            KeConvertLockToShared ( &KiTestApcLock )
        ELSE
            RtlPrint ( "ZZ " )
        END
    END

    KeAcquireLockExclusive ( &KiTestApcLock2 )

    KeReleaseLock ( &KiTestApcLock )

    KeReleaseLock ( &KiTestApcLock2 )


        IF KiCurrentIpl () != KI_IPL_APC THEN
            KeCrash ( "FRICK!\n" )
        END
END

FN (KeStartThreadF) KiTestThread (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

    i := 0
    j := 0

    apcthread := context1 + 1

    IF apcthread >= KI_TEST_THREADS THEN
        apcthread = 2
    END

    interval : RtlUquad
    interval.High = 0
    interval.Low = 1000

    RtlPrint ( "start " )

    me := KeCurrentThread ()

    WHILE TRUE DO
        TestLoop ( i )

        floor := me^.PriorityFloor
        int := me^.InteractivityFloor

        IF floor != 0 OR int != 0 THEN

            KeCrash ( "%x %x\n", floor, int )
        END

        IF KiCurrentIpl () != KI_IPL_LOW THEN
            KeCrash ( "FRICK!\n" )
        END

        IF i & 0xFF == 0 THEN
            KeEnqueueKapc (
                &KiTestApcs[apcthread], // apc
                0, // priorityboost
                i, // context1
                0, // context2
            )

            IF i & 0xFFF == 0 THEN
                RtlPrint ( "%u ", context1 )
            END
        END

        i += 1
        j -= 1
    END
END

FN (KeStartThreadF) KiTestThreadPinning (
    IN context1 : UWORD,
    IN context2 : UWORD,
)


    interval : RtlUquad
    interval.High = 0
    interval.Low = 10000

    testquad : RtlUquad
    testquad.High = 0xF
    testquad.Low = 0

    testquad2 : RtlUquad
    testquad2.High = 0x1
    testquad2.Low = 0x1

    RtlPrint ( "Sleep %p  ", KeCurrentThread () )

    KeSleep (
        &interval, // interval
        KE_USER_MODE, // waitmode
        KE_UNALERTABLE, // alertable
    )

    RtlPrint ( "Woke " )

    testitem1 : RtlListEntry
    testitem2 : RtlListEntry
    testitem3 : RtlListEntry
    testitem4 : RtlListEntry

    KeInsertIntoBalancedQueue (
        &KiTestQueue, // queue
        &testitem1, // item
        FALSE, // head
        0, // priorityboost
    )

    KeInsertIntoBalancedQueue (
        &KiTestQueue, // queue
        &testitem2, // item
        FALSE, // head
        0, // priorityboost
    )

    KeInsertIntoBalancedQueue (
        &KiTestQueue, // queue
        &testitem3, // item
        FALSE, // head
        0, // priorityboost
    )

    KeInsertIntoBalancedQueue (
        &KiTestQueue, // queue
        &testitem4, // item
        FALSE, // head
        0, // priorityboost
    )

    i := 0

    WHILE TRUE DO
        KeSleep (
            &interval, // interval
            KE_USER_MODE, // waitmode
            KE_UNALERTABLE, // alertable
        )

        RtlPrint ( "Woke " )

        IF i THEN
            RtlPrint ( "LOWER" )
            KiLowerIpl ( KI_IPL_LOW )

        ELSE
            RtlPrint ( "RAISE" )
            KiRaiseIpl ( KI_IPL_APC )

            q := 0

            WHILE q < 10000000 DO
                q += 1
            END

            RtlPrint ( "Q" )
        END

        i $= 1
    END
END

FN (KeApcF) KiTestApcFunction (
    IN apc : ^KeApc,
    IN context1 : UWORD,
    IN context2 : UWORD,
    IN rundown : UWORD,
)

    thread := KeCurrentThread ()

    RtlPrint ( "P%p ", thread )
END

FN (KeStartThreadF) KiTestThreadApc (
    IN context1 : UWORD,
    IN context2 : UWORD,
)


    interval : RtlUquad
    interval.High = 0
    interval.Low = 4000

    apc : KeApc

    KeInitializeApc (
        &apc, // apc
        &KiTestApcFunction, // func
        KE_APC_KERNEL, // type
        &KiTestThreads[0], // thread
    )

    WHILE TRUE DO
        KeSleep (
            &interval, // interval
            KE_USER_MODE, // waitmode
            KE_UNALERTABLE, // alertable
        )

        stat := KeEnqueueKapc (
            &apc, // apc
            0, // priorityboost
            0, // context1
            0, // context2
        )
        
        RtlPrint ( "Enq%u ", stat )
    END
END

FN KiInitializeTest ()

    prb := KI_CURRENT_PRB

    IF prb^.Id == 0 THEN
        RtlInitializeList ( &TestListHead )

        KeInitializeSemaphore (
            &KiTestSemaphore, // semaphore
            "TestSemaphore", // name
            0, // initialcount
        )

        KeInitializeBalancedQueue (
            &KiTestQueue, // queue
            "TestQueue", // name
            2, // maxthreads
        )

        ipl := KiRaiseIpl ( KI_IPL_DPC )

        KeInitializeThread (
            &KeIdleProcess.Pcb, // process
            &KiTestThreads[0], // thread
            "TestThread", // name
            &KiTestThreadsStacks[0], // kstack
            2048, // kstacksize
            &KiTestThreadPinning, // startfunc
            0, // context1
            0, // context2
        )

        KeInitializeThread (
            &KeIdleProcess.Pcb, // process
            &KiTestThreads[1], // thread
            "TestThread", // name
            &KiTestThreadsStacks[512], // kstack
            2048, // kstacksize
            &KiTestThreadApc, // startfunc
            0, // context1
            0, // context2
        )

        i := 0

        WHILE i < KI_TEST_EVENTS DO
            KeInitializeEvent (
                &KiTestEvents[i], // event
                "TestEvent", // name
                FALSE, // notification
                0, // signalstate
            )

            i += 1
        END

        i = 2

        WHILE i < KI_TEST_THREADS DO
            KeInitializeThread (
                &KeIdleProcess.Pcb, // process
                &KiTestThreads[i], // thread
                "TestThread", // name
                &KiTestThreadsStacks[512 * i], // kstack
                2048, // kstacksize
                &KiTestThread, // startfunc
                i, // context1
                0, // context2
            )

            KeSetBasePriorityThread (
                &KiTestThreads[i], // thread
                8 + (i & 3), // priority
                TRUE, // setcurrentpriority
            )

            KeInitializeApc (
                &KiTestApcs[i], // apc
                &KiTestApcFunction2, // func
                KE_APC_KERNEL, // type
                &KiTestThreads[i], // thread
            )

            i += 1
        END

        i = 0

        WHILE i < KI_TEST_THREADS DO
            KiReadyThread ( &KiTestThreads[i] )

            i += 1
        END

        KiLowerIpl ( ipl )
    END
END







// FORWARD
EXTERN FN (KeStartThreadF) KiThreadedMain (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

FN (KeStartThreadF) KiIdleLoop (
    IN context1 : UWORD,
    IN context2 : UWORD,
)


    ipl := KiAcquireAnnounce ()

    RtlPrint ( "KiIdleLoop: Processor %u idling\n", KiCurrentProcessor () )

    KiReleaseAnnounce ( ipl )

#IF BLD_MP
    prb := KI_CURRENT_PRB_LOCAL

    // Atomically decrement the initialization count to indicate to the boot
    // processor that we made it into our idle thread.

    KeIncrementUlong (
        &KiInitializeCount, // ptr
        0xFFFFFFFF, // ulong
    )
#END

    KiInitializeTest ()

    WHILE TRUE DO
        KiWaitForInterrupt ()

#IF BLD_MP
        IF prb^.StealWork THEN
            // Time to try stealing work.

            prb^.StealWork = FALSE

            KiStealWork ()
        END
#END
    END
END

#SECTION "INITtext"
FN KiInitializePrb (
    IN prb : ^KiPrb,
    IN bootprocessor : UWORD,
)

    // Initialize this Prb.

    // Loader stashed words in the Prb at the following indices:
    // 0 - Processor ID
    // 1 - Software IDT pointer
    // 2 - Idle stack pointer

    idword := CAST prb TO ^UWORD

    id := idword[0]
    irqdt := idword[1]
    stackbase := idword[2]

    // Clear the Prb.

    RtlFillMemoryWithUlong (
        prb, // ptr
        BL_PRB_SIZE, // sz
        0, // ulong
    )

    // Place the stashed words at their proper place.

    prb^.Id = id
    prb^.IrqDispatchTable = CAST irqdt TO ^VOID
    prb^.IdleStackBase = CAST stackbase TO ^VOID

    // On some architectures, the thing we get from KI_CURRENT_PRB_LOCAL is not
    // a globally visible address for this Prb.

#IF KI_VIRTUAL_PRB
    prb^.RealVirtual = prb
#END

    RtlInitializeList ( &prb^.DpcListHead )

    RtlInitializeList ( &prb^.StackSwapCandidateListHead )

#IF BLD_MP
    KiInitializeSpinlock ( &prb^.DpcQueueLock )
    KiInitializeSpinlock ( &prb^.ReadyQueueLock )
    KiInitializeSpinlock ( &prb^.TimerTreeLock )
    KiInitializeSpinlock ( &prb^.StackSwapListLock )
#END

    KeInitializeDpc (
        &prb^.TimerExpirationDpc, // dpc
        &KiTimerExpiration, // function
    )

#IF ( == BLD_BITS 64 )
    prb^.EarliestTimerMs.Quad = 0xFFFFFFFFFFFFFFFF

#ELSE
    prb^.EarliestTimerMs.Low = 0xFFFFFFFF
    prb^.EarliestTimerMs.High = 0xFFFFFFFF
#END

    prb^.Ipl = KI_IPL_LOW

    // Initialize the IRQ dispatch table.

    i := 0

    WHILE i < HAL_VECTOR_MAX DO
        prb^.IrqDispatchTable[i] = &KiUnexpectedInterruptObject

        i += 1
    END

    // Initialize the real time scheduler queues.

    i = 0

    WHILE i < OS_PRIORITY_MAX DO
        RtlInitializeList ( &prb^.RealTimeListHeads[i] )

        i += 1
    END

    // Initialize the timeshared scheduler queues.

    i = 0

    WHILE i < KI_TIMESHARED_QUEUES DO
        RtlInitializeList ( &prb^.CalendarListHeads[i] )

        i += 1
    END

    // Initialize the idle scheduler queue.

    RtlInitializeList ( &prb^.IdleListHead )

    // Initialize the idle thread.

    startfunc : KeStartThreadF

    IF bootprocessor THEN
        startfunc = &KiThreadedMain

    ELSE
        startfunc = &KiIdleLoop
    END

    KeInitializeThread (
        &KeIdleProcess.Pcb, // process
        &prb^.IdleThread, // thread
        "IdleThread", // name
        prb^.IdleStackBase, // kstack
        BL_IDLE_STACK_SIZE, // kstacksize
        startfunc, // startfunc
        0, // context1
        0, // context2
    )

    prb^.IdleThread.Priority = OS_PRIORITY_IDLE
    prb^.IdleThread.BasePriority = OS_PRIORITY_IDLE

#IF BLD_MP
    prb^.IdleThread.CurrentPrb = prb
#END

    // Initialize frozen context to zero so that the debugger doesn't try to
    // read it if we failed to freeze.

    prb^.FrozenContext = NULLPTR
END

#IF BLD_MP

#SECTION "INITtext"
FN (HalStartProcessorF) KiStartOtherProcessor ()

    // This is the first code that runs in the context of a non-boot processor.
    // We assume any context required to access the Prb has been set up by the
    // Loader. We have to initialize ourselves and then jump into our idle
    // thread to wait for work.

    prb := KI_CURRENT_PRB

    // Initialize architectural support.

    KiInitializeArchitecture ( prb )

    // Initialize HAL.

    HalProcessorInitialize ( prb )

    // Become a subject of the dispatcher.

    KiJumpIntoIdleThread ( prb )
END

#END

EXTERN FN ExStartExecutive ()

#SECTION "INITtext"
FN (KeStartThreadF) KiThreadedMain (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

    // This is the first code that runs in thread context during the lifetime of
    // the system. We need to perform phase 0 initialization of the Executive.

    ExStartExecutive ()

    // Go into the idle loop.

    KiIdleLoop (
        context1, // context1
        context2, // context2
    )
END

#SECTION "INITtext"
FN KiFixupLoaderBlockLists ()

    // Fix up the circular lists in the loader block so that they still point to
    // the newly relocated list heads.

    listhead := &KeLoaderBlock.ResourceListHead

    listhead^.Next^.Prev = listhead
    listhead^.Prev^.Next = listhead

    listhead = &KeLoaderBlock.DllListHead

    listhead^.Next^.Prev = listhead
    listhead^.Prev^.Next = listhead

    listhead = &KeLoaderBlock.DescriptorListHead

    listhead^.Next^.Prev = listhead
    listhead^.Prev^.Next = listhead
END

#SECTION "INITtext"
EXPORT FN KeMain (
    IN loaderblock : ^BlInfoRecord,
)

    // At this point:
    //
    // o  We have been transferred to from the Loader.
    // o  We are on a page-sized initial stack.
    // o  We have no thread context - we need to hand-craft one.
    // o  Interrupts are disabled. Paging is enabled.
    // o  The PFN database has been constructed by the Loader for us. Not much
    //    else has been.
    // o  The firmware - no matter what system we are on - is inaccessible, as a
    //    rule, even if we could theoretically use it on some platform. Only
    //    exception are firmware services that *must* be called at certain
    //    points in HAL initialization, and only then.
    //
    // Any pointers from the Loader may or may not be in a spot where they are
    // permanently accessible, since this may or may not be a platform where the
    // Loader is entered with paging enabled. If it wasn't, the Loader ran out
    // of an identity mapping in what is going to become userspace. Therefore
    // anything from loader-space that we need to access during runtime must be
    // be transferred into the Executive between now and the execution of the
    // first usermode process in order to guarantee its safe to touch. Plus, we
    // are going to reclaim all of the Loader's physical memory during Mm init.

    // Initialize the KeCrash module.

    KiInitializeCrashing ()

    // Start by copying the loader block into the Executive.

    RtlCopyBytes (
        &KeLoaderBlock, // dest
        loaderblock, // src
        SIZEOF BlInfoRecord, // sz
    )

    // Fix up loader block lists.

    KiFixupLoaderBlockLists ()

    // Initialize the idle process.

    KeInitializeProcess (
        &KeIdleProcess.Pcb, // process
        "Idle", // name
    )

    KeIdleProcess.Pcb.PageDirectoryPfn = KeLoaderBlock.SystemPageDirectoryPfn
    KeIdleProcess.Paged = &KiIdleProcessPaged

    // Initialize turnstiles.

    KiInitializeTurnstiles ()

    // Initialize the Prbs.

    prb := KiPrbFromNumber ( 0 )

    initprb := prb
    i := 0

    WHILE i < KeLoaderBlock.ProcessorCount DO
        KiInitializePrb (
            initprb, // prb
            i == 0, // bootprocessor
        )

        i += 1
        initprb += BL_PRB_SIZE
    END

    // Initialize architectural support.

    KiInitializeArchitecture ( prb )

    // Perform early initialization of the HAL. This will perform baseline
    // initialization of integral platform components such as the interval
    // timer. Also, we get a boot console which is guaranteed to stay sane
    // throughout the lifetime of the system and at any IPL.

    HalEarlyInitialize ()

#IF BLD_CHK
    IF SIZEOF KiPrb > BL_PRB_SIZE THEN
        KeCrash ( "KiPrb > BL_PRB_SIZE\n" )
    END
#END

    // Perform platform-specific initialization for the boot processor.

    HalProcessorInitialize ( prb )

    // Initialize the shared user page.

    KeSharedUserPage = KeLoaderBlock.VirtualSharedUserPage

    KiUpdateTime ( prb )

    // Perform early initialization of the debugger.

    IF KeLoaderBlock.DbgMain THEN
        dbgmain := CAST KeLoaderBlock.DbgMain TO DbgMainF

        dbgmain ()
    END

    // Initialize the stack swapper event. This is waited upon by a component
    // of Mm which outswaps kernel stacks and processes.

    KeInitializeEvent (
        &KeStackSwapperEvent, // event
        "StackSwap", // name
        FALSE, // notification
        FALSE, // signalstate
    )

    // Initialize the reaper event. This is waited upon by a component of Ps
    // which removes the last reference count from thread objects and deletes
    // their stack (which cannot be done in the context of the thread itself).

    KeInitializeEvent (
        &KeReaperEvent, // event
        "Reaper", // name
        FALSE, // notification
        FALSE, // signalstate
    )

#IF BLD_MP
    // Initialize the work balancing DPC.

    KeInitializeDpc (
        &KiWorkBalanceDpc, // dpc
        &KiBalanceWork, // func
    )

    // We're ready to pull the other processors into the system.

    KiInitializeCount = KeLoaderBlock.ProcessorCount - 1

    // Bring em in.

    HalStartProcessors ( &KiStartOtherProcessor )

    // Wait for them to signal that they've been initialized.

    WHILE KiInitializeCount DO
        // Language BARRIER to stop this loop from being optimized out.

        BARRIER
    END
#END

    // KeCrash ( "%x %x %x %x %x\n", OFFSETOF KeThread.Dbg, OFFSETOF KeThread.RestoredPri, OFFSETOF KeThread.RestoredInt, OFFSETOF KeThread.PriorityFloor, OFFSETOF KeThread.Priority )

    // Become a subject of the dispatcher.

    KiJumpIntoIdleThread ( prb )

    KeCrash ( "KiJumpIntoThread returned\n" )
END

#SECTION "INITtext"
FN KeSetQuickPtes (
    IN basepte : ^VOID,
    IN ptesize : UWORD,
)

    // Set the quick PTE address for each CPU.

    i := 0
    prb := KiPrbFromNumber ( 0 )
    count := KeLoaderBlock.ProcessorCount

    WHILE i < count DO
        prb^.QuickPte = basepte

        basepte += ptesize
        i += 1
        prb += BL_PRB_SIZE
    END
END