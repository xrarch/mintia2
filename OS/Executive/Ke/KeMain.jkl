//
// Initialization of the Kernel (Ke) subcomponent of the MINTIA Executive.
//

#INCLUDE "Ki.hjk"

PUBLIC KiIdleProcess : KeProcess

EXPORT ExLoaderBlock : BlInfoRecord

FNPTR DbgMainF ()

#IF BLD_MP

KiInitializeCount : ULONG

KiAnnounceSpinlock : KiSpinlock = KI_INITIAL_SPINLOCK

PUBLIC KiWorkBalanceDpc : KeDpc

#MACRO KiAcquireAnnounce () [
    KiAcquireSpinlockRaise ( &KiAnnounceSpinlock )
]

#MACRO KiReleaseAnnounce ( oldipl ) [
    KiReleaseSpinlockLower ( &KiAnnounceSpinlock, oldipl )
]

#ELSE

#MACRO KiAcquireAnnounce () [
    KiRaiseIpl ( KI_IPL_DPC )
]

#MACRO KiReleaseAnnounce ( oldipl ) [
    KiLowerIpl ( oldipl )
]

#END

// FORWARD
EXTERN FN (KeStartThreadF) KiThreadedMain (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

FN (KeStartThreadF) KiIdleLoop (
    IN context1 : UWORD,
    IN context2 : UWORD,
)


    ipl := KiAcquireAnnounce ()

    RtlPrint ( "KiIdleLoop(): Processor %u idling\n", KiCurrentProcessor () )

    KiReleaseAnnounce ( ipl )

#IF BLD_MP
    prb := KI_CURRENT_PRB_LOCAL

    // Atomically decrement the initialization count to indicate to the boot
    // processor that we made it into our idle thread.

    KeIncrementUlong (
        &KiInitializeCount, // ptr
        0xFFFFFFFF, // ulong
    )
#END

    WHILE TRUE DO
        KiWaitForInterrupt ()

#IF BLD_MP
        IF prb^.StealWork THEN
            // Time to try stealing work.

            prb^.StealWork = FALSE

            KiStealWork ()
        END
#END
    END
END

#SECTION "INIT$text"
FN KiInitializePrb (
    IN prb : ^KiPrb,
    IN bootprocessor : UWORD,
) : ^KiPrb

    // Initialize this PRB. It has already been filled with zeroes by the Loader
    // so avoid doing that again for those fields where zeroes (and NULLPTR) are
    // the initial state.

    // First thing to do is to put the ID stashed by Loader in its proper field.

    idword := (CAST prb TO ^UWORD)[0]

    prb^.Id = idword

    // On some architectures, the thing we get from KI_CURRENT_PRB is not a
    // globally visible address for this Prb.

#IF KI_VIRTUAL_PRB
    prb^.RealVirtual = KiPrbFromNumber ( KiCurrentProcessor () )
#END

    // Make sure from now on we're dealing with a global Prb pointer.

    KI_TO_GLOBAL_PRB ( prb )

    RtlInitializeList ( &prb^.DpcListHead )

#IF BLD_MP
    KiInitializeSpinlock ( &prb^.DpcQueueLock )
    KiInitializeSpinlock ( &prb^.ReadyQueueLock )
    KiInitializeSpinlock ( &prb^.TimerTreeLock )
#END

    KeInitializeDpc (
        &prb^.TimerExpirationDpc, // dpc
        &KiTimerExpiration, // function
    )

#IF ( == BLD_BITS 64 )
    prb^.EarliestTimerMs.Quad = 0xFFFFFFFFFFFFFFFF

#ELSE
    prb^.EarliestTimerMs.Low = 0xFFFFFFFF
    prb^.EarliestTimerMs.High = 0xFFFFFFFF
#END

    prb^.Ipl = KI_IPL_LOW

    // Initialize the IRQ dispatch table.

    i := 0

    WHILE i < HAL_VECTOR_MAX DO
        prb^.IrqDispatchTable[i] = &KiUnexpectedInterruptObject

        i += 1
    END

    // Initialize the real time scheduler queues.

    i = 0

    WHILE i < OS_PRIORITY_MAX DO
        RtlInitializeList ( &prb^.RealTimeListHeads[i] )

        i += 1
    END

    // Initialize the timeshared scheduler queues.

    i = 0

    WHILE i < KI_TIMESHARED_QUEUES DO
        RtlInitializeList ( &prb^.CalendarListHeads[i] )

        i += 1
    END

    // Initialize the idle scheduler queue.

    RtlInitializeList ( &prb^.IdleListHead )

    // Initialize the idle thread.

    startfunc : KeStartThreadF

    IF bootprocessor THEN
        startfunc = &KiThreadedMain

    ELSE
        startfunc = &KiIdleLoop
    END

    KeInitializeThread (
        &KiIdleProcess, // process
        &prb^.IdleThread, // thread
        "IdleThread", // name
        &prb^.IdleStack[0], // kstack
        KI_IDLE_STACK_SIZE, // kstacksize
        startfunc, // startfunc
        0, // context1
        0, // context2
    )

    prb^.IdleThread.Priority = OS_PRIORITY_IDLE
    prb^.IdleThread.BasePriority = OS_PRIORITY_IDLE

#IF BLD_MP
    prb^.IdleThread.CurrentPrb = prb
#END

    // Initialize frozen context to zero so that the debugger doesn't try to
    // read it if we failed to freeze.

    prb^.FrozenContext = NULLPTR

    RETURN prb
END

#IF BLD_MP

#SECTION "INIT$text"
FN (BlStartProcessorF) KiStartOtherProcessor ()

    // This is the first code that runs in the context of a non-boot processor.
    // We assume any context required to access the Prb has been set up by the
    // Loader. We have to initialize ourselves and then jump into our idle
    // thread to wait for work.

    // Initialize the current processor's Prb.

    prb := KI_CURRENT_PRB_LOCAL

    prb = KiInitializePrb (
        prb, // prb
        FALSE, // bootprocessor
    )

    // Initialize architectural support.

    KiInitializeArchitecture ( prb )

    // Initialize HAL.

    HalProcessorInitialize ( prb )

    // Become a subject of the dispatcher.

    KiJumpIntoIdleThread ( prb )
END

#END

#SECTION "INIT$text"
FN (KeStartThreadF) KiThreadedMain (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

    // This is the first code that runs in thread context during the lifetime of
    // the system. We need to perform phase 0 initialization of the Executive.

    // Go into the idle loop.

    KiIdleLoop (
        context1, // context1
        context2, // context2
    )
END

#SECTION "INIT$text"
FN KiFixupLoaderBlockLists ()

    // Fix up the circular lists in the loader block so that they still point to
    // the newly relocated list heads.

    listhead := &ExLoaderBlock.ResourceListHead

    listhead^.Next^.Prev = listhead
    listhead^.Prev^.Next = listhead

    listhead = &ExLoaderBlock.DllListHead

    listhead^.Next^.Prev = listhead
    listhead^.Prev^.Next = listhead

    listhead = &ExLoaderBlock.DescriptorListHead

    listhead^.Next^.Prev = listhead
    listhead^.Prev^.Next = listhead
END

#SECTION "INIT$text"
EXPORT FN KeMain (
    IN loaderblock : ^BlInfoRecord,
)

    // At this point:
    //
    // o  We have been transferred to from the Loader.
    // o  We are on a page-sized initial stack.
    // o  We have no thread context - we need to hand-craft one.
    // o  Interrupts are disabled. Paging is enabled.
    // o  The PFN database has been constructed by the Loader for us. Not much
    //    else has been.
    // o  The firmware - no matter what system we are on - is inaccessible, as a
    //    rule, even if we could theoretically use it on some platform. Only
    //    exception are firmware services that *must* be called at certain
    //    points in HAL initialization, and only then.
    //
    // Any pointers from the Loader may or may not be in a spot where they are
    // permanently accessible, since this may or may not be a platform where the
    // Loader is entered with paging enabled. If it wasn't, the Loader ran out
    // of an identity mapping in what is going to become userspace. Therefore
    // anything from loader-space that we need to access during runtime must be
    // be transferred into the Executive between now and the execution of the
    // first usermode process in order to guarantee its safe to touch. Plus, we
    // are going to reclaim all of the Loader's physical memory during Mm init.

    // Initialize the KeCrash module.

    KiInitializeCrashing ()

    // Start by copying the loader block into the Executive.

    RtlCopyBytes (
        &ExLoaderBlock, // dest
        loaderblock, // src
        SIZEOF BlInfoRecord, // sz
    )

    // Fix up loader block lists.

    KiFixupLoaderBlockLists ()

    // Initialize the idle process.

    KeInitializeProcess (
        &KiIdleProcess, // process
        "Idle", // name
    )

    // Initialize the boot processor's PRB.

    prb := KI_CURRENT_PRB_LOCAL

    prb = KiInitializePrb (
        prb, // prb
        TRUE, // bootprocessor
    )

    // Initialize architectural support.

    KiInitializeArchitecture ( prb )

    // Perform early initialization of the HAL. This will perform baseline
    // initialization of integral platform components such as the interval
    // timer. Also, we get a boot console which is guaranteed to stay sane
    // throughout the lifetime of the system and at any IPL.

    HalEarlyInitialize ()

#IF BLD_CHK
    IF SIZEOF KiPrb > BL_PRB_SIZE THEN
        KeCrash ( "KiPrb > BL_PRB_SIZE\n" )
    END
#END

    HalProcessorInitialize ( prb )

    // Perform early initialization of the debugger.

    IF ExLoaderBlock.DbgMain THEN
        dbgmain := CAST ExLoaderBlock.DbgMain TO DbgMainF

        dbgmain ()
    END

#IF BLD_MP
    // Initialize the work balancing DPC.

    KeInitializeDpc (
        &KiWorkBalanceDpc, // dpc
        &KiBalanceWork, // func
    )

    // We're ready to pull the other processors into the system.

    KiInitializeCount = ExLoaderBlock.ProcessorCount - 1

    // Call the Loader to do platform-specific stuff to start the processors.
    // Some platforms require calling the firmware with paging disabled. We
    // can't do that from here, but on those platforms Loader lives in an
    // identity mapping of low memory, so he can do that just fine.

    ExLoaderBlock.StartProcessors (
        &KiStartOtherProcessor, // startfunc
    )

    // Wait for them to signal that they've been initialized.

    WHILE KiInitializeCount DO
        // Language BARRIER to stop this loop from being optimized out.

        BARRIER
    END
#END

    // Become a subject of the dispatcher.

    KiJumpIntoIdleThread ( prb )

    KeCrash ( "KiJumpIntoThread returned\n" )
END