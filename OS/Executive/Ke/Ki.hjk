//
// Private header file for the Kernel component of the MINTIA Executive.
//

#INCLUDE "<ll>/Rtl.hjk"
#INCLUDE "<ll>/System/OsProcess.hjk"

#INCLUDE "<inc>/Hal.hjk"
#INCLUDE "<inc>/Ke.hjk"
#INCLUDE "../../Loader/Headers/Loader.hjk"

EXTERN KiIdleProcess : KeProcess

#DEFINE KI_IPL_LOW 0
#DEFINE KI_IPL_APC 1
#DEFINE KI_IPL_DPC 2
#DEFINE KI_IPL_CLOCK 29
#DEFINE KI_IPL_IPI 30
#DEFINE KI_IPL_HIGH 31
#DEFINE KI_IPL_MAX 32

#IF ( STRCMP ARCHITECTURE "xr17032" )

// The Prb is mapped in the same location on all processors on XR/17032 via
// a wired entry in each DTB. This location is -4096 in order to allow the
// address to be loaded with a single SUBI instruction.

#DEFINE KI_CURRENT_PRB_LOCAL [(CAST 0xFFFFF000 TO ^KiPrb)]

#DEFINE KI_CACHE_ALIGN 16

#DEFINE KI_INITIAL_SPINLOCK 0

#MACRO KiInitializeSpinlock ( spinlock ) [
    NOTHING (spinlock)^ = 0
]

#IF BLD_MP

#DEFINE KI_CURRENT_PRB [((CAST 0xFFFFF000 TO ^KiPrb)^.RealVirtual)]
#DEFINE KI_VIRTUAL_PRB 1

#ELSE

#DEFINE KI_CURRENT_PRB [(CAST 0xFFFFF000 TO ^KiPrb)]
#DEFINE KI_VIRTUAL_PRB 0

#END

// This is the per-processor entry in the ASID table attached to each KeProcess
// object.

STRUCT KiAsidInfoEntry
    AsidSequenceNumber : RtlUquad,
    Asid : UWORD,
END

// The only thing this restricts is the size of some bitmaps, so it can be
// freely set to the maximum number of processors supported by any platform with
// this processor.

#DEFINE KI_MAXIMUM_PROCESSORS 8

#ELSEIF ( STRCMP ARCHITECTURE "fox32" )

// Fox32 is always uniprocessor, so the Prb is mapped in a convenient and
// constant spot with a real page table entry.

#DEFINE KI_CURRENT_PRB_LOCAL [(CAST 0xFFFFF000 TO ^KiPrb)]
#DEFINE KI_CURRENT_PRB [(CAST 0xFFFFF000 TO ^KiPrb)]
#DEFINE KI_VIRTUAL_PRB 0

#ELSE
    #ERROR ( STRCAT "Unknown architecture " ARCHITECTURE )
#END

#DEFINE KI_VOLATILE_LOCAL_PRB ( AND ( NOT KI_VIRTUAL_PRB ) BLD_MP )

#IF KI_VIRTUAL_PRB

#MACRO KI_TO_GLOBAL_PRB ( prb ) [
    NOTHING (prb) = (prb)^.RealVirtual
]

#ELSE

#MACRO KI_TO_GLOBAL_PRB ( prb ) []

#END

// Default quantum is 30ms.

#DEFINE KI_DEFAULT_QUANTUM 30

// Number of timeshared ready queues.

#DEFINE KI_TIMESHARED_QUEUES 32

// Distance from the enqueue pointer to place a thread at priority zero into the
// circular timeshared ready queues.

#DEFINE KI_TIMESHARED_DISTANCE [(OS_PRIORITY_HIGH_USER + 1)]

// Interval in milliseconds at which to perform global load balancing.

#DEFINE KI_WORK_BALANCE_INTERVAL 1000

// Interval in milliseconds for which a thread must be asleep before we outswap
// its stack.

#DEFINE KI_STACK_SWAP_INTERVAL_MS 10000

// Minimum load to steal threads from a processor.
// This is a count of threads on its ready queue.

#DEFINE KI_STEAL_LOAD 1

#DEFINE KI_TICK_SHIFT 10

#MACRO KiPendingIpl ( ipl ) [
     (1 << ((ipl) - 1))
]

#IF BLD_MP

FNPTR KiIpiF (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

#END

// The per-processor block (Prb) is an architectural page size, but is at
// minimum 4KB. It contains all per-processor information.

#DEFINE KI_IDLE_STACK_SIZE 2048

STRUCT KiPrb
    IdleStack : UBYTE[KI_IDLE_STACK_SIZE],

#IF BLD_MP
    // Give the spinlocks their own cache lines.

    DpcQueueLock : KiSpinlock,
    CacheAlign1 : UBYTE[KI_CACHE_ALIGN - SIZEOF KiSpinlock],

    ReadyQueueLock : KiSpinlock,
    CacheAlign2 : UBYTE[KI_CACHE_ALIGN - SIZEOF KiSpinlock],

    TimerTreeLock : KiSpinlock,
    CacheAlign3 : UBYTE[KI_CACHE_ALIGN - SIZEOF KiSpinlock],

    StackSwapListLock : KiSpinlock,
    CacheAlign4 : UBYTE[KI_CACHE_ALIGN - SIZEOF KiSpinlock],

    IpiInterrupt : KeInterrupt,

    IpiFunction : KiIpiF,

    IdlePrbListEntry : RtlListEntry,

    IpiContext1 : UWORD,
    IpiContext2 : UWORD,

    IpiSpin : ULONG,

    IpiPendingSet : ULONG,
#END

#IF ( STRCMP PLATFORM "XRstation" )
    LsicBase : ^VOID,
#END

    TimerTreeRoot : ^RtlHeapEntry,

    IrqDispatchTable : ^KeInterrupt[HAL_VECTOR_MAX],

    IdleThread : KeThread,

#IF KI_VIRTUAL_PRB
    RealVirtual : ^KiPrb,
#END

    FrozenContext : ^OsContext,

    // Inspired by ULE of FreeBSD:
    //
    // The real time list heads are indexed by thread priority, with all ready
    // threads of the same priority being chained together off of that list
    // head. The scheduler will *always* select the highest priority available
    // thread from the real time ready queues if one exists.
    //
    // The threads in this queue come from those with "real time priority", and
    // also those with lower priority that have been temporarily designated as
    // as "interactive" in order to increase responsiveness.

    RealTimeListHeads : RtlListEntry[OS_PRIORITY_MAX],

    // The calendar list heads form a "clock" whose hand ticks once every 20ms,
    // or the length of the system tick, whichever is greater. When the real
    // time queues are empty, the next thread to run is taken from the queue
    // pointed to by the CalendarRunIndex. After all threads are emptied from
    // this queue (i.e. they have all gotten a chance to run), the
    // CalendarRunIndex is incremented to the next queue which contains threads,
    // in order to make sure the processor doesn't waste time idling.
    //
    // The CalendarEnqueueIndex is the ticking hand. Newly enqueued threads are
    // inserted into the queue pointed to by:
    //
    //   CalendarEnqueueIndex + KI_TIMESHARED_DISTANCE - thread^.Priority
    //
    // That is, threads are placed into a "further" queue when they have lower
    // priority. This accomplishes a relative ratio of CPU time granted to each
    // thread based on their priorities.
    //
    // If CalendarRunIndex is incremented and equals CalendarEnqueueIndex, the
    // latter is incremented in order to make sure the queue being run is
    // flushed before more stuff is put on it.
    //
    // Threads on these lists are called "timeshared threads".

    CalendarListHeads : RtlListEntry[KI_TIMESHARED_QUEUES],

    // Idle threads (priority 0) go on this list.

    IdleListHead : RtlListEntry,

    TimerInterrupt : KeInterrupt,

    ClockTicks : RtlUquad,
    DpcTimeMs : RtlUquad,
    UserTimeMs : RtlUquad,
    SystemTimeMs : RtlUquad,
    EarliestTimerMs : RtlUquad,

    IplTimes : RtlUquad[KI_IPL_MAX],

#IF ( STRCMP ARCHITECTURE "xr17032" )
    AsidSequenceNumber : RtlUquad,
    NextAsid : UINT,
#END

    KernelStackTop : ^VOID,
    CurrentThread : ^KeThread,
    NextThread : ^KeThread,

    DpcListHead : RtlListEntry,

    StackSwapCandidateListHead : RtlListEntry,

    TimerExpirationDpc : KeDpc,

    PendingSoftwareInterrupts : ULONG,

    // 32-bit mask where a set bit indicates a real time queue that has at least
    // one thread.

    RealTimeReady : ULONG,

    // 32-bit mask where a set bit indicates a timeshared queue that has at
    // least one thread.

    CalendarReady : ULONG,

#IF BLD_MP
    // 32-bit count of threads enqueued ready on this processor.

    Load : ULONG,
#END

    Id : UINT,

    Ipl : UBYTE, // ASM routines assume this is a byte size.
    QuantumEnd : UBYTE,
    DpcActive : UBYTE,
    CalendarRunIndex : UBYTE,
    CalendarEnqueueIndex : UBYTE,
    CheckInteractivity : UBYTE,

#IF BLD_MP
    WakeStackSwapper : UBYTE,
    StealWork : UBYTE,
#END

END

// KiRaiseIpl and KiLowerIpl may only be used to move between the software IPLs:
//
//  o  KI_IPL_DPC
//  o  KI_IPL_APC
//  o  KI_IPL_LOW
//
// With this in mind, they can be implemented quite efficiently as macros,
// provided direct access to the Prb is sane across thread migration on this
// architecture.
//
// If it is not, these routines are written as short assembly routines elsewhere
// so that they can disable interrupts briefly while holding a pointer to the
// current Prb.
//
// Direct access to the Prb is always sane if this is a uniprocessor build.
// Otherwise, it's sane if the architecture provides a way to wire the Prb into
// the same address across all cores. If neither of the above hold, it's insane!

EXTERN FN KiRaiseIpl (
    IN newipl : UWORD,
) : UWORD

EXTERN FN KiLowerIpl (
    IN newipl : UWORD,
)

EXTERN FN KiCurrentIpl () : UWORD

EXTERN FN KiDisableInterrupts () : UWORD

EXTERN FN KiRestoreInterrupts (
    IN oldstate : UWORD,
)

EXTERN FN KiEnableInterrupts ()

EXTERN FN KiWaitForInterrupt ()

EXTERN FN KiCurrentProcessor () : UWORD

EXTERN FN KiInitializeCrashing ()

EXTERN FN KiInitializeArchitecture (
    IN prb : ^KiPrb,
)

EXTERN FN KiFlushMyIcache ()

EXTERN FN KiFlushMyDcache ()

EXTERN FN KiFlushMyTb ()

EXTERN FN KiFlushMyTbAddress (
    IN address : ^VOID,
)

EXTERN FN KiFlushMyIcacheByPhys (
    IN pfn : UWORD,
)

EXTERN FN KiFlushMyDcacheByPhys (
    IN pfn : UWORD,
)

EXTERN FN KiDispatchSoftwareInterrupts (
    IN newipl : UWORD,
)

EXTERN FN KiInterruptUsermode (
    IN dispatchfunc : ^VOID,
    IN trapframe : ^OsContext,
    IN userfunc : UWORD,
    IN context : UWORD,
)

#DEFINE KI_PUSHLOCK_LOCKED 0x1
#DEFINE KI_PUSHLOCK_WAITING 0x2
#DEFINE KI_PUSHLOCK_WAKING 0x4
#DEFINE KI_PUSHLOCK_MULTIPLE_SHARED 0x8
#DEFINE KI_PUSHLOCK_SHARE_INC 0x10
#DEFINE KI_PUSHLOCK_PTR_BITS 0xF
#DEFINE KI_PUSHLOCK_SHARE_SHIFT 4

EXTERN FN KiAcquirePushlockShared (
    IN pushlock : ^KePushlock,
)

EXTERN FN KiAcquirePushlockExclusive (
    IN pushlock : ^KePushlock,
)

EXTERN FN KiReleasePushlock (
    IN pushlock : ^KePushlock,
)

EXTERN FN KiDispatchKernelApcQueue (
    IN current : ^KeThread,
)

EXTERN FN KiDispatchLazyApcQueue (
    IN current : ^KeThread,
)

EXTERN FN KiDispatchUserApcQueue (
    IN current : ^KeThread,
)

EXTERN FN KiDispatchDpcQueue (
    IN prb : ^KiPrb,
)

EXTERN FN KiPreemptThread (
    IN prb : ^KiPrb,
)

EXTERN FN KiQuantumEnd (
    IN prb : ^KiPrb,
)

EXTERN FN KiCheckInteractivity (
    IN prb : ^KiPrb,
)

EXTERN FN KiSwitchAddressSpace (
    IN process : ^KeProcess,
)

EXTERN FN KiSwitchContext (
    IN newthread : ^KeThread,
    IN oldthread : ^KeThread,
)

EXTERN FN KiJumpIntoThread (
    IN thread : ^KeThread,
)

EXTERN FN KiJumpIntoIdleThread (
    IN prb : ^KiPrb,
)

EXTERN FN KiUpdateInteractivity (
    IN thread : ^KeThread,
) : UWORD

EXTERN FN (KeDpcF) KiTimerExpiration (
    IN dpc : ^KeDpc,
    IN context1 : UWORD,
    IN context2 : UWORD,
)

EXTERN FN KiClockTick (
    IN intervalms : UWORD,
    IN usermode : UWORD,
    IN previpl : UWORD,
)

EXTERN FN KiSatisfyObject (
    IN object : ^KiDispatchHeader,
    IN priorityboost : UWORD,
    IN all : UWORD,
    IN status : OsStatus,
) : ^KeThread

EXTERN FN KiUnwaitThread (
    IN thread : ^KeThread,
    IN status : OsStatus,
    IN priorityboost : UWORD,
)

EXTERN FN KiYield (
    IN current : ^KeThread,
    IN prb : ^KiPrb,
)

EXTERN FN KiReadyThread (
    IN thread : ^KeThread,
)

EXTERN FN KiDispatchUserInterrupts ()

EXTERN FN KiWakeBalancedQueue (
    IN queue : ^KeBalancedQueue,
)

EXTERN FN KiDisassociateFromBalancedQueue (
    IN thread : ^KeThread,
)

EXTERN KiUnexpectedInterruptObject : KeInterrupt

#MACRO KiSoftInterruptSelf ( prb, ipl ) [
    KeOrUlong (
        &(prb)^.PendingSoftwareInterrupts, // ptr
        KiPendingIpl ( ipl ), // bitset
    )
]

#IF BLD_MP

EXTERN FN KiPinThread (
    IN prb : ^KiPrb,
)

EXTERN FN KiUnpinThread ()

EXTERN FN (KeDpcF) KiBalanceWork (
    IN dpc : ^KeDpc,
    IN context1 : UWORD,
    IN context2 : UWORD,
)

EXTERN FN KiFreezeOtherProcessors ()

EXTERN FN KiUnfreezeOtherProcessors ()

EXTERN FN KiServiceIpi (
    IN context : ^OsContext,
)

EXTERN FN KiExecuteOnOtherProcessor (
    IN target : ^KiPrb,
    IN function : KiIpiF,
    IN context1 : UWORD,
    IN context2 : UWORD,
)

EXTERN FN KiExecuteOnEveryoneElse (
    IN function : KiIpiF,
    IN context1 : UWORD,
    IN context2 : UWORD,
)

#MACRO KiSoftInterruptOther ( targetprb, ipl ) [
    // Cause a software interrupt on another processor.

    oldvalue := KeOrUlong (
        &(targetprb)^.PendingSoftwareInterrupts, // ptr
        KiPendingIpl ( ipl ), // bitset
    )

    IF oldvalue & KiPendingIpl ( ipl ) == 0 THEN
        // We just set it, so we should send an IPI to get him to check it.

        HalTriggerIpi ( targetprb )
    END
]

EXTERN FN KiAcquireSpinlock (
    IN spinlock : ^KiSpinlock,
)

EXTERN FN KiReleaseSpinlock (
    IN spinlock : ^KiSpinlock,
)

EXTERN FN KiAcquireSpinlockRaise (
    IN spinlock : ^KiSpinlock,
) : UWORD

EXTERN FN KiAcquireSpinlockInPrb (
    IN offset : UWORD,
    OUT prb : ^KiPrb,
) : UWORD

EXTERN FN KiReleaseSpinlockLower (
    IN spinlock : ^KiSpinlock,
    IN oldipl : UWORD,
)

#MACRO KiAcquireObject ( object ) [
    KiAcquireSpinlockRaise ( &(object)^.Spinlock )
]

#MACRO KiReleaseObject ( object, ipl ) [
    KiReleaseSpinlockLower ( &(object)^.Spinlock, ipl )
]

#MACRO KiAcquireObjectElevated ( object ) [
    KiAcquireSpinlock ( &(object)^.Spinlock )
]

#MACRO KiReleaseObjectElevated ( object ) [
    KiReleaseSpinlock ( &(object)^.Spinlock )
]

#IF ( == BLD_BITS 64 )

#DEFINE KI_QUEUE_REMOVAL_LOCKS 32
#DEFINE KI_QUEUE_SHIFT 6

#ELSE

#DEFINE KI_QUEUE_REMOVAL_LOCKS 16
#DEFINE KI_QUEUE_SHIFT 5

#END

EXTERN KiQueueRemovalLocks : KiSpinlock[KI_QUEUE_REMOVAL_LOCKS]

#MACRO KiQueueLockIndex ( queue ) [
    (((queue) >> KI_QUEUE_SHIFT) & (KI_QUEUE_REMOVAL_LOCKS - 1))
]

#MACRO KiAcquireQueueRemoval ( queue ) [
    KiAcquireSpinlockRaise ( &KiQueueRemovalLocks[KiQueueLockIndex(queue)] )
]

#MACRO KiReleaseQueueRemoval ( queue, ipl ) [
    KiReleaseSpinlockLower ( &KiQueueRemovalLocks[KiQueueLockIndex(queue)], ipl )
]

#MACRO KiAcquireQueueRemovalElevated ( queue ) [
    KiAcquireSpinlock ( &KiQueueRemovalLocks[KiQueueLockIndex(queue)] )
]

#MACRO KiReleaseQueueRemovalElevated ( queue ) [
    KiReleaseSpinlock ( &KiQueueRemovalLocks[KiQueueLockIndex(queue)] )
]

#MACRO KiAcquireThread ( thread ) [
    KiAcquireSpinlockRaise ( &(thread)^.Spinlock )
]

#MACRO KiReleaseThread ( thread, oldipl ) [
    KiReleaseSpinlockLower (
        &(thread)^.Spinlock, // spinlock
        oldipl, // oldipl
    )
]

#MACRO KiAcquireThreadElevated ( thread ) [
    KiAcquireSpinlock ( &(thread)^.Spinlock )
]

#MACRO KiReleaseThreadElevated ( thread ) [
    KiReleaseSpinlock ( &(thread)^.Spinlock )
]

#MACRO KiAcquireSwapState ( process ) [
    KiAcquireSpinlockRaise ( &(process)^.SwapStateSpinlock )
]

#MACRO KiReleaseSwapState ( process, ipl ) [
    KiReleaseSpinlockLower ( &(process)^.SwapStateSpinlock, ipl )
]

#MACRO KiAcquireSwapStateElevated ( process ) [
    KiAcquireSpinlock ( &(process)^.SwapStateSpinlock )
]

#MACRO KiReleaseSwapStateElevated ( process ) [
    KiReleaseSpinlock ( &(process)^.SwapStateSpinlock )
]

EXTERN FN KiStealWork ()

EXTERN KiWorkBalanceDpc : KeDpc

#ELSE

#MACRO KiAcquireObject ( object ) [
    KiRaiseIpl ( KI_IPL_DPC )
]

#MACRO KiReleaseObject ( object, ipl ) [
    KiLowerIpl ( ipl )
]

#MACRO KiAcquireObjectElevated ( object ) []

#MACRO KiReleaseObjectElevated ( object ) []

#MACRO KiAcquireQueueRemoval ( queue ) [
    KiRaiseIpl ( KI_IPL_DPC )
]

#MACRO KiReleaseQueueRemoval ( queue, ipl ) [
    KiLowerIpl ( ipl )
]

#MACRO KiAcquireQueueRemovalElevated ( queue ) []

#MACRO KiReleaseQueueRemovalElevated ( queue ) []

#MACRO KiAcquireThread ( thread ) [
    KiRaiseIpl ( KI_IPL_DPC )
]

#MACRO KiReleaseThread ( thread, oldipl ) [
    KiLowerIpl ( oldipl )
]

#MACRO KiAcquireThreadElevated ( thread ) []

#MACRO KiReleaseThreadElevated ( thread ) []

#MACRO KiAcquireSwapState ( process ) [
    KiRaiseIpl ( KI_IPL_DPC )
]

#MACRO KiReleaseSwapState ( process, ipl ) [
    KiLowerIpl ( ipl )
]

#MACRO KiAcquireSwapStateElevated ( process ) []

#MACRO KiReleaseSwapStateElevated ( process ) []

#END

#IF ( == BLD_BITS 32 )

#MACRO KiCaptureCurrentTicks ( uquad ) [
    WHILE TRUE DO
        sup := KeSharedUserPage

        NOTHING (uquad)^.High = (sup)^.Uptime.High
        NOTHING (uquad)^.Low = (sup)^.Uptime.Low

        IF (uquad)^.High == (sup)^.UptimeCheckHigh THEN
            // Didn't change while collecting.

            BREAK
        END
    END
]

#MACRO KiLowTick () [
    (KeSharedUserPage^.Uptime.Low)
]

#MACRO KiUpdateTime ( prb ) [
    sup := KeSharedUserPage

    realtime : RtlUquad

    HalQueryTime ( &realtime )

#IF HAL_RTC_IS_LOCAL
    // Convert to real time by subtracting the time zone offset.

    offset := KeSharedUserPage^.TimeZoneOffset

    RtlSubUlongFromUquad (
        &realtime, // destquad
        offset, // ulong
    )
#END

    sup^.RealTimeCheckHigh = realtime.High
    sup^.RealTime.Low = realtime.Low
    sup^.RealTime.High = realtime.High

    sup^.UptimeCheckHigh = (prb)^.ClockTicks.High
    sup^.Uptime.Low = (prb)^.ClockTicks.Low
    sup^.Uptime.High = (prb)^.ClockTicks.High
]

#ELSE

#MACRO KiCaptureCurrentTicks ( uquad ) [
    NOTHING (uquad)^.Quad = KeSharedUserPage^.Uptime.Quad
]

#MACRO KiLowTick ( prb ) [
    (KeSharedUserPage^.Uptime.Quad)
]

#MACRO KiUpdateTime ( prb ) [
    sup := KeSharedUserPage

    realtime : RtlUquad

    HalQueryTime ( &realtime )

#IF HAL_RTC_IS_LOCAL
    // Convert to real time by subtracting the time zone offset.

    realtime.Quad -= KeSharedUserPage^.TimeZoneOffset
#END

    sup^.RealTime.Quad = realtime.Quad

    sup^.Uptime.Quad = (prb)^.ClockTicks.Quad
]

#END

#MACRO KiPrbFromNumber ( procid ) [
    (CAST KeLoaderBlock.VirtualPrbBase + (procid) * BL_PRB_SIZE TO ^KiPrb)
]

#MACRO KiInitializeDispatchObject ( hdr, name, type ) [
    RtlInitializeList ( &(hdr)^.WaitListHead )
    NOTHING (hdr)^.Name = (name)
    NOTHING (hdr)^.WaiterCount = 0
#IF BLD_MP
    KiInitializeSpinlock ( &(hdr)^.Spinlock )
#END
    NOTHING (hdr)^.Type = (type)
]

EXTERN FN KiInitializeContext (
    IN process : ^KeProcess,
    IN kstack : ^VOID,
    IN startfunc : KeStartThreadF,
    IN context1 : UWORD,
    IN context2 : UWORD,
) : ^OsContext

EXTERN KiIndexFirstBitClear : UBYTE[256]

EXTERN FN KiInsertSwapCandidateListFunc (
    IN thread : ^KeThread,
)

EXTERN FN KiRemoveSwapCandidateListFunc (
    IN thread : ^KeThread,
)

#MACRO KiInsertSwapCandidateList ( thread, waitmode ) [
    IF (waitmode) == KE_USER_MODE AND
        (thread)^.KernelStackSwappable THEN

        KiInsertSwapCandidateListFunc ( thread )
    END
]

#MACRO KiRemoveSwapCandidateList ( thread ) [
    IF (thread)^.SwapCandidatePrb THEN
        KiRemoveSwapCandidateListFunc ( thread )
    END
]

EXTERN FN KiReadyOutswappedThread (
    IN thread : ^KeThread,
) : UWORD

EXTERN FN KiReadyThreadOutswappedProcess (
    IN thread : ^KeThread,
)