//
// Implements the Balance Manager for the MINTIA Executive.
//

#INCLUDE "Mmp.hjk"

#INCLUDE "<ll>/System/OsProcess.hjk"

#DEFINE MMP_BALANCE_MANAGER_INTERVAL_MS 1000

#DEFINE MMP_POOL_ADJUSTMENT_SHORT_INTERVAL_MS 1000
#DEFINE MMP_POOL_ADJUSTMENT_INTERVAL_MS 5000
#DEFINE MMP_POOL_PURGE_INTERVAL_MS 10000

FN (ExWorkItemF) MmpAdjustPagedPoolCacheWorker (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

    // Called from the context of a worker thread to perform periodic adjustment
    // work that is unsafe to perform in the context of the balance manager.

    node := CAST context1 TO ^MmpNode
    partition := &node^.Partition

    node^.PgPoolCacheAdjustActive = FALSE

    empty := partition^.AvailablePageCount < partition^.LowPageCount

    MmpAdjustPoolCaches (
        &node^.PgPoolCacheList, // list
        context2, // purgepercpu
        empty, // empty
    )

    IF empty THEN
        // Also aggressively reap threads and objects.
        // TODO: Make the reaper lists for these things per-node.
        //       The worker thread pool should also be made per-node.

        PsuReaperWorker (
            0, // context1
            0, // context2
        )

        ObuDeferredDeletionWorker (
            0, // context1
            0, // context2
        )
    END
END

FN MmpAdjustAllPoolCachesSafely (
    IN node : ^MmpNode,
    IN purgepercpu : UWORD,
    IN empty : UWORD,
)

    // Adjust all of the pool caches. Called by the balance manager.
    // To be safe, we need to dispatch paged pool cache adjustment to a worker
    // thread because the balance manager cannot safely take page faults as it
    // is a critical memory-making thread.

    IF NOT node^.PgPoolCacheAdjustActive THEN
        node^.PgPoolCacheAdjustActive = TRUE

        ExEnqueueWorkItem (
            &node^.PgPoolCacheAdjustItem, // item
            EX_HIGH_WORK_PRIORITY, // priority
            CAST node TO UWORD, // context1
            purgepercpu, // context2
        )
    END

    // Immediately chuck the nonpaged pool caches from the context
    // of this thread.

    MmpAdjustPoolCaches (
        &node^.NpPoolCacheList, // list
        purgepercpu, // purgepercpu
        empty, // empty
    )
END

FN MmuBalanceManager ()

    // Responsible for:
    // o Kernel thread stack swapping.
    // o Process swapping.
    // o Working set trimming.
    // o Pool cache adjustment.

    thread := PsCurrentThread ()

    thread^.VmPrivileged = TRUE

    KeSetBasePriorityThread (
        &thread^.Tcb, // thread
        OS_PRIORITY_MED_REALTIME, // priority
        TRUE, // setcurrentpriority
    )

    partition := PsuCurrentPartition ()
    node := PsuCurrentNode ()

    IF MmpIsPartitionPhysical ( partition ) THEN
        node^.PgPoolCacheAdjustActive = FALSE

        ExInitializeWorkItem (
            &node^.PgPoolCacheAdjustItem, // item
            &MmpAdjustPagedPoolCacheWorker, // routine
        )
    END

    ms := 0
    mssinceadjust := 0
    mssincepurge := 0

    timer : KeTimer

    interval : RtlUquad

    RtlSetUquadToUlong (
        &interval, // uquad
        MMP_BALANCE_MANAGER_INTERVAL_MS, // ms
    )

    KeInitializeTimer (
        &timer, // timer
        NULLPTR, // dpc
        "ExuBalanceManagerTimer", // name
    )

    waittable : ^VOID[2]
    waittable[0] = &timer
    waittable[1] = &partition^.LowMemoryEvent

    status : OsStatus = 0

    WHILE TRUE DO
        IF status == 0 THEN
            // The timer expired so we have to re-enqueue it.

            KeEnqueueTimer (
                &timer, // timer
                &interval, // interval
                0, // context1
                0, // context2
            )
        END

        status = KeWaitForObjects (
            KE_KERNEL_MODE, // waitmode
            FALSE, // alertable
            NULLPTR, // timeout
            2, // objectcount
            &waittable[0], // objecttable
            NULLPTR, // waitblocktable
        )

        KeAssert ( NOT OsError ( status ) )

        IF status == 0 THEN
            // The timer expired.
            // Perform periodic adjustment work.

            ms += MMP_BALANCE_MANAGER_INTERVAL_MS
            dt := ms - mssinceadjust

            IF MmpIsPartitionPhysical ( partition ) AND
                (dt >= MMP_POOL_ADJUSTMENT_INTERVAL_MS OR
                (partition^.AvailablePageCount < partition^.LowPageCount AND
                dt >= MMP_POOL_ADJUSTMENT_SHORT_INTERVAL_MS)) THEN

                // Adjust pool caches.

                mssinceadjust = ms

                purge := FALSE

                IF (ms - mssincepurge) >= MMP_POOL_PURGE_INTERVAL_MS THEN
                    mssincepurge = ms

                    IF partition^.AvailablePageCount <
                        partition^.SufficientPageCount THEN

                        purge = TRUE
                    END
                END

                MmpAdjustAllPoolCachesSafely (
                    node, // node
                    purge, // purgepercpu
                    partition^.AvailablePageCount < partition^.LowPageCount,
                )
            END

        ELSEIF status == 1 THEN
            // The low memory event was set.
            // Trim working sets.

        END
    END
END