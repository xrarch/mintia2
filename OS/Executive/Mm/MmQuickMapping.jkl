//
// Implements quick-mapping.
//

#INCLUDE "Mi.hjk"
#INCLUDE "../../Loader/Headers/Loader.hjk"

STRUCT MiQuickPteBlock
    Locks : KeLock[MI_QUICK_PER_CPU],
    BasePte : ^MiPte,
    NextIndex : UBYTE,
END

#DEFINE MI_QUICK_PTE_BLOCK_SIZE [((SIZEOF MiQuickPteBlock + KE_CACHE_ALIGN - 1) &
    ~(KE_CACHE_ALIGN - 1))]

PUBLIC MiQuickPteBase : ^MiPte

PUBLIC MiQuickPteBlocks : ^MiQuickPteBlock

#ENTERSECTION "INITtext"

#SECTION "INITtext"
FN MiInitializeQuickPages ()

    // Initialize the quick page mappings.

    procs := KeLoaderBlock.ProcessorCount

    MiQuickPteBlocks = MmAllocatePool (
        MM_NONPAGED_POOL, // poolindex
        MI_QUICK_PTE_BLOCK_SIZE * procs, // bytes
        'Quic', // tag
        FALSE, // wait
    )

    IF NOT MiQuickPteBlocks THEN
        KeCrash ( "Failed to allocate quick PTE blocks\n" )
    END

    i := 0

    WHILE i < procs DO
        block := MiQuickPteBlocks + (i * MI_QUICK_PTE_BLOCK_SIZE)

        block^.NextIndex = 0

        block^.BasePte = MiQuickPteBase +
            ((i * MI_QUICK_PER_CPU) * SIZEOF MiPte)

        j := 0

        WHILE j < MI_QUICK_PER_CPU DO
            KeInitializeLock ( &block^.Locks[j] )

            j += 1
        END

        i += 1

    END
END

#LEAVESECTION

FN MmUseQuickPte (
    IN func : MmUseQuickPteF,
    IN pfn : UWORD,
    IN context : ^VOID,
) : OsStatus

    // Allocate a quick mapping for the given PFN.

    // Disable migration of the current thread to another processor.

    thread := KeCurrentThread ()

    old := KeControlMigration (
        thread, // thread
        TRUE, // pinned
    )

    id := KeCurrentProcessorId ()

    // Trylock all of this processor's quick PTEs.

    block := MiQuickPteBlocks + (id * MI_QUICK_PTE_BLOCK_SIZE)

    i := 0

    WHILE i < MI_QUICK_PER_CPU DO
        IF KeTryAcquireLockExclusive ( &block^.Locks[i] ) THEN
            GOTO GotOne
        END

        i += 1
    END

    // Failed to trylock a page. Increment a counter and lock whatever
    // it lands on.

    i = block^.NextIndex & (MI_QUICK_PER_CPU - 1)
    block^.NextIndex = i + 1

    IF KeGetLockOwner ( &block^.Locks[i] ) == thread THEN
        // The lock is held by the current thread, so we can't block on it or we
        // will self-deadlock. This can happen if this thread previously
        // acquired this quick page and then took an APC which we are running in
        // now. Luckily the solution is easy - we can just skip ahead by one and
        // lock that one instead.

        i = (i + 1) & (MI_QUICK_PER_CPU - 1)
        block^.NextIndex = i + 1

        // It should not be possible for this lock to also be held by the
        // current thread, because thread execution can only nest a maximum of
        // two levels deep (normal execution and KAPC), we're in the second
        // level, and we already skipped the lock held by the first level.

        KeAssert ( KeGetLockOwner ( &block^.Locks[i] ) != thread )
    END

    // Lock the quick page.

    KeAcquireLockExclusive ( &block^.Locks[i] )

@GotOne

    // Calculate the PTE and virtual address.

    pte := block^.BasePte + (i * SIZEOF MiPte)
    vaddr := MiVirtualAddress ( pte )

    // Map the page.

    pte[0] = MiBuildPoolPte ( pfn )

    // Flush TB. We only need to flush the local TB because we disabled
    // migration of the current thread to any other CPU.

    KeFlushMyTbAddress ( vaddr )

    // Call provided function.

    status := func (
        vaddr, // vaddr
        context, // context
    )

    // Release the page lock.

    KeReleaseLock ( &block^.Locks[i] )

    // Restore migration.

    KeControlMigration (
        thread, // thread
        old, // pinned
    )

    RETURN status
END

FN (MmUseQuickPteF) MiZeroPageFunc (
    IN vaddr : ^VOID,
    IN context : ^VOID,
) : OsStatus

    // Called with the pointer to a quick mapping to zero the page through.

    RtlFillMemoryWithUlong (
        vaddr, // ptr
        RTL_PAGE_SIZE, // sz
        0, // ulong
    )
END

FN MmZeroPage (
    IN pfn : UWORD,
)

    // Zero out a page frame.

    MmUseQuickPte (
        &MiZeroPageFunc, // func
        pfn, // pfn
        NULLPTR, // context
    )
END