//
// Implements initialization for the Memory Manager (Mm) component of the MINTIA
// Executive.
//

#INCLUDE "Mi.hjk"
#INCLUDE "<inc>/Ps.hjk"
#INCLUDE "../../Loader/Headers/Loader.hjk"

PUBLIC MiSystemPartition : MiPartition

PUBLIC MiPfnDatabase : ^MiPfe

PUBLIC MiTotalPages := 0

PUBLIC MiSystemSize := 0

MiSystemQuota : MiQuotaBlock

#SECTION "INITtext"
FN MmInitializeStage1 ()

    // Stage 1 initialization for Memory Management. Here we have to initialize
    // the system memory partition enough to get physical memory allocation
    // working.

#IF BLD_CHK
    IF SIZEOF MiPfe > MI_PFE_SIZE THEN
        KeCrash ( "MmInitializeStage1: bad PFE size\n" )
    END
#END

    sys := &MiSystemPartition

    // Copy the address of the PFN database.

    MiPfnDatabase = KeLoaderBlock.PfnDatabase

    // Initialize the integral data structures of the system partition.

    MiInitializePartitionStage1 ( sys )

    // Walk the memory descriptor list.

    head := &KeLoaderBlock.DescriptorListHead
    listentry := head^.Next

    WHILE listentry != head DO
        desc := CONTAINEROF listentry TO BlMemoryDescriptor.Entry

        // Include as part of the total memory of the system.

        sys^.TotalPages += desc^.PageCount

        IF desc^.Type == BL_MEMORY_FREE THEN
            // Place all page frames within this descriptor's bounds on the free
            // list of the system partition.

            pages := desc^.PageCount

            sys^.FluidPageCount += pages
            sys^.AvailablePageCount += pages

            sys^.FreeList.Count += pages

            pfn := desc^.StartPfn
            pfe := MI_PFN_TO_PFE ( pfn )

            WHILE pages DO
                pfe^.Type = MI_FREE_PFE_TYPE

                RtlInsertAtTailList (
                    &sys^.FreeList.Heads[MI_PFN_COLOR(pfn)], // head
                    &pfe^.Entry, // entry
                )

                pfe += MI_PFE_SIZE
                pfn += 1
                pages -= 1
            END
        END

        listentry = listentry^.Next
    END

    membytes := sys^.TotalPages << RTL_PAGE_SHIFT

    RtlPrint ( "MmInitialize: %u KB\n", membytes / 1024 )

    // Determine system size.

    MiSetPartitionSize ( sys )

    // Initialize the system virtual address allocator.

    MiInitializeSystemVa ()

    // Initialize the system pools.

    MiInitializePools ()

    // Initialize commit to something acceptable before creation of the
    // pagefiles.

    sys^.CommitLimit = sys^.AvailablePageCount + 100
    sys^.TheoreticalCommitLimit = sys^.CommitLimit

    // Give the idle process a quota block.

    MiInitializeQuota ()

    MiInitializeQuotaBlock (
        &MiSystemQuota, // quotablock
        -1, // nplimit
        -1, // pglimit
        -1, // vmlimit
        0, // uid
    )

    KeIdleProcess.Paged^.QuotaBlock = &MiSystemQuota

    // Reclaim boot time memory. Nothing in "loader space" is safe to access
    // after this point.

    // MiReclaimMemory ()

    // Hook for the architecture code to do what it wants.

    // MiInitializeArchitecture ()

    // Initialize the zones for quick MDL allocation.

    // MiInitializeMdlZones ()

    // Allocate one page which just remains constantly zeroed for the lifetime
    // of the system.

    // MiInitializeZeroedPage ()
END