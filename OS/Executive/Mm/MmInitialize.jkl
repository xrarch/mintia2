//
// Implements initialization for the Memory Manager (Mm) component of the MINTIA
// Executive.
//

#INCLUDE "Mmp.hjk"
#INCLUDE "<inc>/Psu.hjk"
#INCLUDE "../../Loader/Headers/Loader.hjk"
#INCLUDE "<ll>/Xlo.hjk"

PUBLIC MmpPfnDatabase : ^MmpPfe

PUBLIC MmpTotalPages := 0

MmpWiredPages := 0
MmpFreedPages := 0
MmpPagedPages := 0
MmpDebugPages := 0

MmpSystemQuota : MmpQuotaBlock

MmpUnwireableList : RtlListEntry

ENUM MmpUnwireableType : UBYTE
    MMP_WIRED_REGION,

    MMP_FREE_REGION,
    MMP_PAGED_REGION,
    MMP_DEFERRED_FREE_REGION,
END

STRUCT MmpUnwireableRegion
    Entry : RtlListEntry,
    Type : UWORD,
    Pages : UWORD,
    StartVa : UWORD,
END

#ENTERSECTION "INITtext"

FN MmuJettisonUnusedResources ()

    // We need to release the page frames taken up by any boot resources that
    // were not claimed during the boot process.

    listhead := &KeuLoaderBlock.ResourceListHead
    listentry := listhead^.Next

    partition := &KeBootNode^.Mmp^.Partition

    WHILE listentry != listhead DO
        rsrc := CONTAINEROF listentry TO BlResource.Entry

        IF rsrc^.Jettison THEN
            // Acquire a pointer to the first PTE for this region.

            pte := MmpPteAddress ( rsrc^.Data )

            pages := (rsrc^.Size + RTL_PAGE_OFFSET_MASK) >> RTL_PAGE_SHIFT

            i := 0

            WHILE i < pages DO
                ptecontents := pte[i]

                // Not all boot resources are page aligned (in particular, the
                // IO config files are represented as boot resources and are
                // packed together rather than page aligned). As a result, we
                // need to check if each PTE has already been invalidated and
                // don't do it a second time if so.

                KeAssert ( rsrc^.IoConfig OR MmpIsPteValid ( ptecontents ) )

                IF MmpIsPteValid ( ptecontents ) THEN
                    pte[i] = MMP_INVALID_KERNEL_PTE

                    // Free the page frame.

                    MmpFreePage (
                        partition, // partition
                        MmpPfnToPfe ( MmpPfnFromPte ( ptecontents ) ), // pfe
                    )
                END

                i += 1
            END
        END

        listentry = listentry^.Next
    END
END

FN MmpIdentifyUnwireableSections (
    IN dll : ^BlDll,
)

    // Identify the bounds of this module's unwireable sections, and add them to
    // a list.

    sectiontable := CAST dll^.Head + dll^.Head^.SectionTableOffset
        TO ^XloSectionHeader

    strtab := CAST dll^.Head + dll^.Head^.StringTableOffset TO ^UBYTE

    i := 0
    count := dll^.Head^.SectionCount

    WHILE i < count DO
        section := &sectiontable[i]

        pages := (section^.VirtualLength + RTL_PAGE_OFFSET_MASK) >>
            RTL_PAGE_SHIFT

        name := strtab + section^.NameOffset

        type := MMP_WIRED_REGION

        IF dll^.Flags & BL_DLL_DEFERRED_FREE THEN
            // For whatever reason, the module failed to load.
            // Loader left it to us to free any partial memory its sections took
            // up since it has no way to do that itself. We should also alert
            // the system operator to the driver load failure.

            // We use this special region type because we have no idea how far
            // the loader got, so we might run into invalid PTEs. That's always
            // wrong for MMP_FREE_REGION but not for this type.

            // TODO alert sysop somehow

            type = MMP_DEFERRED_FREE_REGION

            MmpWiredPages -= pages
            MmpFreedPages += pages

        ELSEIF RtlCompareStringWithMax (
            name, // str1
            "INIT", // str2
            4, // count
        ) == 0 THEN

            type = MMP_FREE_REGION

            MmpWiredPages -= pages
            MmpFreedPages += pages

        ELSEIF RtlCompareStringWithMax (
            name, // str1
            "PAGE", // str2
            4, // count
        ) == 0 THEN
            type = MMP_PAGED_REGION

            MmpWiredPages -= pages
            MmpPagedPages += pages
        END

        IF type != MMP_WIRED_REGION THEN
            // Create an unwireable region record.

            region := CAST MmAllocatePool (
                MM_NONPAGED_POOL, // poolindex
                SIZEOF MmpUnwireableRegion, // bytes
                'Unwi', // tag
                FALSE, // wait
            ) TO ^MmpUnwireableRegion

            IF NOT region THEN
                KeCrash ( "%sfailed to allocate unwire\n",
                    "MmpReclaimMemory: " )
            END

            region^.Type = type
            
            region^.Pages = (section^.VirtualLength + RTL_PAGE_OFFSET_MASK) >>
                RTL_PAGE_SHIFT

            region^.StartVa = section^.VirtualAddress

            RtlInsertAtTailList (
                &MmpUnwireableList, // head
                &region^.Entry, // entry
            )
        END

        i += 1
    END
END

FN MmpReclaimMemoryFromNode (
    IN kenode : ^KeuNode,
)

    // Reclaim physical memory regions.

    sys := &kenode^.Mmp^.Partition

    listhead := &kenode^.DescriptorListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        desc := CONTAINEROF listentry TO BlMemoryDescriptor.Entry

        // Physical memory is reclaimable if it's either explicitly
        // reclaimable, or is debug memory and no debugger is installed.

        IF desc^.Type == BL_MEMORY_RECLAIMABLE OR
            (desc^.Type == BL_MEMORY_DEBUG AND NOT KeuLoaderBlock.DbgMain) THEN

            pages := desc^.PageCount

            MmpWiredPages -= pages
            MmpFreedPages += pages

            sys^.FreeList.Count += pages
            sys^.AvailablePageCount += pages
            sys^.FluidPageCount += pages

            pfn := desc^.StartPfn
            pfe := MmpPfnToPfe ( pfn )

            WHILE pages DO
                pfe^.Type = MMP_FREE_PFE_TYPE

                RtlInsertAtTailList (
                    &sys^.FreeList.Heads[MmpPfnColor(pfn)], // head
                    &pfe^.Entry, // entry
                )

                pfe += MMP_PFE_SIZE
                pfn += 1
                pages -= 1
            END
        END

        listentry = listentry^.Next
    END
END

FN MmpReclaimMemory ()

    // We have to lift any lists the loader gave us onto our own pool. Then we
    // free the reclaimable regions of physical memory on the descriptor list.

    RtlInitializeList ( &MmpUnwireableList )

    loaderhunk := MmAllocatePool (
        MM_NONPAGED_POOL, // poolindex
        KeuLoaderBlock.ResourceCount * SIZEOF BlResource +
        KeuLoaderBlock.DllCount * SIZEOF BlDll, // bytes
        'Boot', // tag
        FALSE, // wait
    )

    IF NOT loaderhunk THEN
        KeCrash ( "%sfailed to allocate loader hunk\n",
            "MmpReclaimMemory: " )
    END

    resource := CAST loaderhunk TO ^BlResource

    dll := CAST loaderhunk +
        KeuLoaderBlock.ResourceCount * SIZEOF BlResource TO ^BlDll

    // Move the resource list.

    listhead := &KeuLoaderBlock.ResourceListHead
    listentry := listhead^.Next

    tmplisthead : RtlListEntry

    RtlInitializeList ( &tmplisthead )

    WHILE listentry != listhead DO
        rsrc := CONTAINEROF listentry TO BlResource.Entry

        RtlCopyBytes (
            resource, // dest
            rsrc, // src
            SIZEOF BlResource, // size
        )

        RtlInsertAtTailList (
            &tmplisthead, // head
            &resource^.Entry, // entry
        )

        resource += SIZEOF BlResource
        listentry = listentry^.Next
    END

    listhead^.Next = tmplisthead.Next
    listhead^.Prev = tmplisthead.Prev

    tmplisthead.Next^.Prev = listhead
    tmplisthead.Prev^.Next = listhead

    // Move the module list.

    listhead = &KeuLoaderBlock.DllListHead
    listentry = listhead^.Next

    RtlInitializeList ( &tmplisthead )

    WHILE listentry != listhead DO
        bldll := CONTAINEROF listentry TO BlDll.Entry

        RtlCopyBytes (
            dll, // dest
            bldll, // src
            SIZEOF BlDll, // size
        )

        RtlInsertAtTailList (
            &tmplisthead, // head
            &dll^.Entry, // entry
        )

        // Walk this module's section headers and create a list of unwireable
        // sections.

        MmpIdentifyUnwireableSections ( dll )

        dll += SIZEOF BlDll
        listentry = listentry^.Next
    END

    listhead^.Next = tmplisthead.Next
    listhead^.Prev = tmplisthead.Prev

    tmplisthead.Next^.Prev = listhead
    tmplisthead.Prev^.Next = listhead

    i := 0

    WHILE i < KeuLoaderBlock.NodeCount DO
        kenode := KeNumaNodeById ( i )

        MmpReclaimMemoryFromNode ( kenode )

        i += 1
    END
END

FN MmpInitializeZeroedPage (
    IN kenode : ^KeuNode,
)

    // Allocate the constantly zeroed page frame.

    pfe := MmpAllocatePage (
        &kenode^.Mmp^.Partition, // partition
        TRUE, // zeroed
        TRUE, // low
        0, // color
    )

    IF NOT pfe THEN
        KeCrash ( "Failed to allocate zero page\n" )
    END

    kenode^.ConstantZeroPfn = MmpPfeToPfn ( pfe )
END

FN MmuInitializeStage1 ()

    // Stage 1 initialization for Memory Management. Here we have to initialize
    // the system memory partition enough to get physical memory allocation
    // working.

    KeAssert ( SIZEOF MmpPfe == MMP_PFE_SIZE )

    membytes := 0

    // Copy the address of the PFN database.

    MmpPfnDatabase = KeuLoaderBlock.PfnDatabase

    // Initialize quota management.

    MmpInitializeQuota ()

    MmpInitializeQuotaBlock (
        &MmpSystemQuota, // quotablock
        -1, // nplimit
        -1, // pglimit
        -1, // vmlimit
        0, // uid
    )

    // Initialize all of the nodes.

    i := 0

    WHILE i < KeuLoaderBlock.NodeCount DO
        kenode := KeNumaNodeById ( i )

        // Allocate an Mm-private part.

        kenode^.Mmp = KeuAllocateNodeSpace (
            kenode, // kenode
            SIZEOF MmpNode, // bytes
        )

        KeAssert ( kenode^.Mmp != NULLPTR )

        mmpnode := kenode^.Mmp
        sys := &mmpnode^.Partition

        mmpnode^.KeNode = kenode

        // Initialize the integral data structures of the system partition.

        MmpInitializePartitionStage1 (
            sys, // partition
            mmpnode, // node
        )

        // Walk the memory descriptor list.

        head := &kenode^.DescriptorListHead
        listentry := head^.Next

        WHILE listentry != head DO
            desc := CONTAINEROF listentry TO BlMemoryDescriptor.Entry

            pages := desc^.PageCount

            // Include as part of the total memory of the system.

            sys^.TotalPages += pages

            IF desc^.Type == BL_MEMORY_FREE THEN
                // Place all page frames within this descriptor's bounds on the
                // free list of the system partition.

                sys^.FluidPageCount += pages
                sys^.AvailablePageCount += pages
                sys^.FreeList.Count += pages

                pfn := desc^.StartPfn
                pfe := MmpPfnToPfe ( pfn )

                WHILE pages DO
                    pfe^.Type = MMP_FREE_PFE_TYPE

                    RtlInsertAtTailList (
                        &sys^.FreeList.Heads[MmpPfnColor(pfn)], // head
                        &pfe^.Entry, // entry
                    )

                    pfe += MMP_PFE_SIZE
                    pfn += 1
                    pages -= 1
                END

            ELSE
                MmpWiredPages += pages
            END

            listentry = listentry^.Next
        END

        membytes += sys^.TotalPages << RTL_PAGE_SHIFT

        // Set the idle process's partition to the system partition.

        kenode^.IdleProcess^.Partition = sys

        // Set the node's integral partition.

        kenode^.IntegralPartition = sys

        // Determine system size.

        MmpSetPartitionSize ( sys )

        // Initialize the system virtual address allocator.

        MmpInitializeSystemVa ( kenode )

        // Initialize the system pools.

        MmpInitializePools ( kenode )

        // Initialize the quick map pages.

        MmpInitializeQuickPages ( kenode )

        // Initialize commit to something acceptable before creation of the
        // pagefiles.

        sys^.CommitLimit = sys^.AvailablePageCount + 300
        sys^.TheoreticalCommitLimit = sys^.CommitLimit

        // Give the idle process a quota block. We stash this in the handle table.
        // Idle process has no real handle table.

        kenode^.IdleProcess^.Paged^.HandleTable.QuotaBlock = &MmpSystemQuota

        // Initialize the zones for quick MDL allocation.

        MmpInitializeMdlCache ( kenode )

        // Initialize the zones for quick kernel stack allocation.

        MmpInitializeKernelStackCache ( kenode )

        // Allocate one page which just remains constantly zeroed for the lifetime
        // of the system.

        MmpInitializeZeroedPage ( kenode )

        i += 1
    END

    // Reclaim boot time memory. Nothing in "loader space" is safe to access
    // after this point.

    MmpReclaimMemory ()

    // Hook for the architecture code to do what it wants.

    MmpInitializeArchitecture ()

    // Initialize the MmpPartition object type.

    ObuInitializeType ( &MmuPartitionType )

    RtlPrint ( "MmuInitialize: %u KB\n", membytes / 1024 )
END

#LEAVESECTION