//
// Implements kernel stack management for the memory manager.
//

#INCLUDE "Mi.hjk"

#SECTION "PAGEtext"
FN (MmPoolCacheAllocateF) MiAllocateKernelStack (
    IN context : ^VOID,
    IN wait : UWORD,
) : ^VOID

    // Allocate a kernel stack by request of the cache layer.

    node := CAST context TO ^MiNode
    partition := &node^.Partition

    // Allocate the required system space.

    kstack := MiAllocateDynamicPages (
        node, // node
        KE_STACK_PAGES + 1, // pages
    )

    IF NOT kstack THEN
        // Couldn't acquire them.

        RETURN NULLPTR
    END

    // Skip the guard page.

    kstack += RTL_PAGE_SIZE

    pfes : ^MiPfe[KE_STACK_PAGES]

    // TEMP: Naive implementation. Full implementation will initialize these
    //       pages as modified anonymous memory so that kernel stacks can be
    //       swapped. We don't yet know exactly what anonymous PFEs will
    //       look like at time of writing.

    i := 0
    ptr := kstack

    WHILE i < KE_STACK_PAGES DO
        // Allocate a physical page.

        pfes[i] = MiAllocatePageWait (
            partition, // partition
            FALSE, // zeroed
            FALSE, // low
            MiVirtualAddressColor ( ptr ), // color
        )

        IF NOT pfes[i] THEN
            // Failed to allocate this page frame.
            // Deallocate the ones we did allocate and return the appropriate
            // status.

            WHILE i DO
                i -= 1

                MiFreePage (
                    partition, // partition
                    pfes[i], // pfe
                )
            END

            MiReleaseDynamicPages (
                node, // node
                kstack - RTL_PAGE_SIZE, // ptr
                KE_STACK_PAGES + 1, // pages
                FALSE, // flush
            )

            RETURN NULLPTR
        END

        i += 1
        ptr += RTL_PAGE_SIZE
    END

    // Acquire a pointer to the first PTE for this region.

    pte := MiPteAddress ( kstack - RTL_PAGE_SIZE )

    // Set the guard page invalid.

    pte[0] = MI_INVALID_KERNEL_PTE

    // Skip to the first real stack page.

    pte = &pte[1]

    // Map the stack pages.

    i = 0

    WHILE i < KE_STACK_PAGES DO
        pte[i] = MiBuildPoolPte ( MiPfeToPfn ( pfes[i]) )

        i += 1
    END

    RETURN kstack
END

#SECTION "PAGEtext"
FN (MmPoolCacheFreeF) MiFreeKernelStack (
    IN context : ^VOID,
    IN ptr : ^VOID,
)

    // Free a kernel stack.

    node := CAST context TO ^MiNode
    partition := &node^.Partition

    // Acquire a pointer to the first PTE for this region.

    pte := MiPteAddress ( ptr )

    // Free the kernel stack pages.

    i := 0

    WHILE i < KE_STACK_PAGES DO
        // Load the PTE for this page.

        ptecontents := pte[i]

        KeAssert ( MiIsPteValid ( ptecontents ) )

        // Clear the PTE, makes it more likely we'll see it if a bad pointer
        // within this space is used later. Due to the TB it's not 100% though.

        pte[i] = MI_INVALID_KERNEL_PTE

        // Free the page frame.

        // TEMP: Does not yet handle kernel stacks being private anonymous
        //       memory.

        MiFreePage (
            partition, // partition
            MiPfnToPfe ( MiPfnFromPte ( ptecontents ) ), // pfe
        )

        i += 1
    END

    // Release the system space containing the stack.

    MiReleaseDynamicPages (
        node, // node
        ptr - RTL_PAGE_SIZE, // ptr
        KE_STACK_PAGES + 1, // pages
        TRUE, // flush
    )
END

#SECTION "INITtext"
FN MiInitializeKernelStackCache (
    IN node : ^MiNode,
)

    // Initialize the zones we use for quickly allocating kernel stacks.

    node^.KernelStackCache = MmCreatePoolCacheEx (
        node, // node
        "Kstacks", // name
        KE_STACK_PAGES * RTL_PAGE_SIZE, // size
        TRUE, // pageable
        &MiAllocateKernelStack, // allocfunc
        &MiFreeKernelStack, // freefunc
        NULLPTR, // deletefunc
        node, // context
    )

#ENTERSECTION "INITtext"
    IF NOT node^.KernelStackCache THEN
        KeCrash ( "MiInitializeKernelStackCache: failed to create cache\n" )
    END
#LEAVESECTION

END

#SECTION "PAGEtext"
FN MmCreateKernelStack (
    IN process : ^PsProcess,
    OUT kstack : ^VOID,
) : OsStatus

    // Create a kernel stack.

    // We cache kernel stacks per-node rather than per-partition, so make sure
    // to do VM accounting relative to the node's integral partition.

    partition := &process^.Node^.Partition

    quotablock := PsQuotaBlock ( process )

    // Charge the process's virtual memory quota for the kernel stack.

    status := MmChargeVmQuota (
        partition, // partition
        quotablock, // quotablock
        KE_STACK_PAGES, // pages
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    // Allocate it.

    kstack = MmAllocateFromPoolCache (
        process^.Node^.KernelStackCache, // cache
        TRUE, // wait
    )

    IF NOT kstack THEN
        // Failed to allocate it so uncharge and report an error.

        MmUnchargeVmQuota (
            partition, // partition
            quotablock, // quotablock
            KE_STACK_PAGES, // pages
        )

        status = OS_STATUS_NO_MEMORY
    END

    RETURN status
END

#SECTION "PAGEtext"
FN MmFreeKernelStack (
    IN process : ^PsProcess,
    IN kstack : ^VOID,
)

    // Free a kernel stack. It must be in an inswapped state.

    MmFreeToPoolCache (
        process^.Node^.KernelStackCache, // cache
        kstack, // ptr
    )

    // Uncharge the virtual memory quota consumed by the kernel stack.

    MmUnchargeVmQuota (
        &process^.Node^.Partition, // partition
        PsQuotaBlock ( process ), // quotablock
        KE_STACK_PAGES, // pages
    )
END