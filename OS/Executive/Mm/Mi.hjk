//
// Private header file for the Memory Management component of the MINTIA
// Executive.
//

#INCLUDE "<ll>/Rtl.hjk"
#INCLUDE "<inc>/Ke.hjk"
#INCLUDE "<inc>/Mm.hjk"

#IF ( STRCMP ARCHITECTURE "xr17032" )
    #INCLUDE "xr17032/Mi.hjk"

#ELSEIF ( STRCMP ARCHITECTURE "fox32" )
    #INCLUDE "fox32/Mi.hjk"

#ELSE
    #ERROR "Unknown architecture"
#END

#DEFINE MI_UNINITIALIZED_SYSTEM 0
#DEFINE MI_TINY_SYSTEM 1
#DEFINE MI_SMALL_SYSTEM 2
#DEFINE MI_MEDIUM_SYSTEM 3
#DEFINE MI_LARGE_SYSTEM 4
#DEFINE MI_MASSIVE_SYSTEM 5

#DEFINE MI_UNINITIALIZED_PFE_TYPE 0
#DEFINE MI_FREE_PFE_TYPE 1
#DEFINE MI_BACKED_PFE_TYPE 2
#DEFINE MI_ANON_PFE_TYPE 3

#DEFINE MI_MODIFIED_PFE_FLAG 1
#DEFINE MI_DELETED_PFE_FLAG 2
#DEFINE MI_PAGED_POOL_PFE_FLAG 4

STRUCT MiFreePfe
    Next : ^MiPfe,
END

STRUCT MiBackedPfe
    OffsetInObject : RtlUquad,
    Entry : RtlAvlNode,
END

STRUCT MiAnonPfe
    TrackingTableEntry : ^MiPte,
    Backing : MiPte,
END

UNION MiInUseUnion
    Backed : MiBackedPfe,
    Anon : MiAnonPfe,
END

STRUCT MiPfe
    U : MiInUseUnion,
    Object : ^MmObject,
    Entry : RtlListEntry,

    References : ULONG,
    Type : UBYTE,
    Flags : UBYTE,
END

STRUCT MiAvailablePageList
    Heads : RtlListEntry[MI_COLOR_COUNT],
    Count : UWORD,
END

STRUCT MiPartition
    FreeList : MiAvailablePageList,
    ZeroList : MiAvailablePageList,
    StandbyList : MiAvailablePageList,
    ModifiedListHead : RtlListEntry,

    AvailablePageCount : UWORD,
    FluidPageCount : UWORD,
    ModifiedPageCount : UWORD,

    CommitUsage : UWORD,
    CommitLimit : UWORD,
    PhysicalUsage : UWORD,
    PhysicalLimit : UWORD,
    TheoreticalCommitLimit : UWORD,

    TotalPages : UWORD,

    LowPageCount : UWORD,
    SufficientPageCount : UWORD,
    ModifiedPageMaximum : UWORD,
    ZeroingThreshold : UWORD,

    ListLock : KePushlock,

    LowMemoryEvent : KeEvent,
    PageAvailableEvent : KeEvent,
    LowPageAvailableEvent : KeEvent,
    ModifiedPageEvent : KeEvent,
    ZeroPageEvent : KeEvent,

    SizeLevel : UBYTE,
END

EXTERN MiSystemPartition : MiPartition

EXTERN MiPfnDatabase : ^MiPfe

EXTERN MiSystemSize : UWORD

// Keep this synchronized with Loader.hjk

#IF ( == BLD_BITS 32 )
    #DEFINE MI_PFE_SIZE 40
#ELSE
    #DEFINE MI_PFE_SIZE 64
#END

#MACRO MI_PFN_TO_PFE ( pfn ) [
    (CAST ((pfn) * MI_PFE_SIZE) + MiPfnDatabase TO ^MiPfe)
]

#MACRO MI_PFE_TO_PFN ( pfe ) [
    (CAST (((pfe) - MiPfnDatabase) / MI_PFE_SIZE) TO UWORD)
]

EXTERN FN MiInitializePartitionStage1 (
    IN partition : ^MiPartition,
)

EXTERN FN MiSetPartitionSize (
    IN partition : ^MiPartition,
)

EXTERN FN MiAllocateChunkSpace (
    IN chunkspace : ^MiChunkSpace,
) : ^VOID

EXTERN FN MiFreeChunkSpace (
    IN chunkspace : ^MiChunkSpace,
    IN ptr : ^VOID,
)

EXTERN MiPoolSpaceChunkPages : UWORD
EXTERN MiCacheSpaceChunkPages : UWORD

EXTERN FN MiAllocatePoolSpace () : ^VOID

EXTERN FN MiFreePoolSpace (
    IN ptr : ^VOID,
)

EXTERN FN MiInitializeSystemVa ()

EXTERN FN MiInitializePools ()

#DEFINE MI_BLOCK_FOR_PAGES_THRESHOLD 16

STRUCT MiDynamicSpaceNode
    Entry : RtlAvlNode,
    
    StartVa : ^VOID,
    EndVa : ^VOID,

    MappedObject : ^MmObject,
END

EXTERN FN MiFindDynamicSpaceNode (
    IN ptr : ^VOID,
) : ^MiDynamicSpaceNode

EXTERN FN MiAllocatePage (
    IN partition : ^MiPartition,
    IN zeroed : UWORD,
    IN low : UWORD,
    IN color : UWORD,
) : ^MiPfe

EXTERN FN MiFreePage (
    IN partition : ^MiPartition,
    IN pfe : ^MiPfe,
)

EXTERN MiPoolSpaceChunkMask : UWORD

#MACRO MiAcquireListExclusive ( partition ) [
    KeAcquireApcSafePushlockExclusive ( &(partition)^.ListLock )
]

#MACRO MiAcquireListShared ( partition ) [
    KeAcquireApcSafePushlockShared ( &(partition)^.ListLock )
]

#MACRO MiReleaseList ( partition, ipl ) [
    KeReleaseApcSafePushlock ( &(partition)^.ListLock, ipl )
]

#MACRO MiAcquireObjectExclusive ( object ) [
    KeAcquireApcSafePushlockExclusive ( &(object)^.Pushlock )
]

#MACRO MiAcquireObjectShared ( object ) [
    KeAcquireApcSafePushlockShared ( &(object)^.Pushlock )
]

#MACRO MiReleaseObject ( object, ipl ) [
    KeReleaseApcSafePushlock ( &(object)^.Pushlock, ipl )
]