//
// Implementation of pool caches for the MINTIA Executive.
//
// A "slabs and magazines" type cache is implemented, inspired by Solaris.
// Magazines provide a per-cpu caching mechanism.
//
// It is recommended that for best performance on NUMA systems, pool caches
// be duplicated per NUMA node, because the slab caches and depots are not
// automatically duplicated on that basis.
//

#INCLUDE "Mi.hjk"

#DEFINE MI_HEADER_FITS_IN_ALIGNMENT [
    (SIZEOF MiSlabHeader <= (RTL_ALIGN_BYTES - SIZEOF ^VOID))
]

#DEFINE MI_MAX_SMALL_BLOCKS_PER_SLAB 16
#DEFINE MI_MAX_BIG_BLOCKS_PER_SLAB 8

#DEFINE MI_SMALL_POOL_BLOCK [(MI_BLOCK_MAX_REQUEST_SIZE / 5)]

STRUCT MiSlabHeader
    References : ULONG,
END

#MACRO MiLockSlabCache ( scache ) [
    KeAcquireApcLockExclusive ( &(scache)^.Lock )
]

#MACRO MiUnlockSlabCache ( scache, ipl ) [
    KeReleaseApcLock ( &(scache)^.Lock, ipl )
]

STRUCT MiPoolCachePerCpu
    MagLock : KeLock,

    Loaded : ^^VOID,
    Previous : ^^VOID,

    Rounds : BYTE,
    PreviousRounds : BYTE,

    MagazineSize : UBYTE,
END

STRUCT MiDepotList
    Head : ^^VOID,

    Total : ULONG,
    Min : ULONG,
    ReapLimit : ULONG,
END

STRUCT MiSlabBackedPoolCacheContext
    Slabs : MiSlabCache,
END

STRUCT MiPoolCache
    Name : ^UBYTE,

    DepotLock : KeLock,

    FullMagazineList : MiDepotList,
    EmptyMagazineList : MiDepotList,

    MasterListEntry : RtlListEntry,

    MagazineType : ^MiMagazineType,

    Allocate : MmPoolCacheAllocateF,
    Free : MmPoolCacheFreeF,
    Delete : MmPoolCacheDeleteF,

    Context : ^VOID,

    Node : ^MiNode,

    Pageable : UBYTE,
END

#DEFINE MI_PCPCPU_SIZE [((SIZEOF MiPoolCachePerCpu + KE_CACHE_ALIGN - 1) &
    ~(KE_CACHE_ALIGN - 1))]

#DEFINE MI_PC_SIZE [((SIZEOF MiPoolCache + KE_CACHE_ALIGN - 1) &
    ~(KE_CACHE_ALIGN - 1))]

#MACRO MiPoolCachePerCpuById ( cache, id ) [
    (CAST cache + MI_PC_SIZE + (id * MI_PCPCPU_SIZE) TO ^MiPoolCachePerCpu)
]

#MACRO MiLockPoolCacheList ( list ) [
    KeAcquireLockExclusive ( &(list)^.MasterListLock )
]

#MACRO MiUnlockPoolCacheList ( list ) [
    KeReleaseLock ( &(list)^.MasterListLock )
]

#MACRO MiLockPoolCacheDepot ( cache ) [
    KeAcquireApcLockExclusive ( &(cache)^.DepotLock )
]

#MACRO MiUnlockPoolCacheDepot ( cache, ipl ) [
    KeReleaseApcLock ( &(cache)^.DepotLock, ipl )
]

#MACRO MiLockMagazineCache ( pcpcpu ) [
    KeAcquireApcLockExclusive ( &(pcpcpu)^.MagLock )
]

#MACRO MiUnlockMagazineCache ( pcpcpu, ipl ) [
    KeReleaseApcLock ( &(pcpcpu)^.MagLock, ipl )
]

#MACRO MiInitializeDepotList ( list ) [
    NOTHING (list)^.Head = NULLPTR
    NOTHING (list)^.Total = 0
    NOTHING (list)^.Min = 0
    NOTHING (list)^.ReapLimit = 0
]

#DEFINE MI_LARGE_MAGAZINE_SIZE 4
#DEFINE MI_SMALL_MAGAZINE_SIZE 8

#SECTION "PAGEtext"
FN MiInitializeSlabCache (
    IN node : ^MiNode,
    IN scache : ^MiSlabCache,
    IN size : UWORD,
    IN poolindex : UWORD,
    IN tag : UWORD,
)

    // Initialize a slab cache.

    // Add a pointer to the block size which will be used as the back-pointer to
    // the slab header, and round it up.

    IF size < SIZEOF RtlListEntry THEN
        size = SIZEOF RtlListEntry
    END

    size = (size + SIZEOF ^VOID + RTL_ALIGN_BYTES - 1) & ~(RTL_ALIGN_BYTES - 1)

    scache^.Size = size
    scache^.PoolIndex = poolindex
    scache^.Tag = tag
    scache^.ActiveSlabCount = 0
    scache^.Node = node
    
    RtlInitializeList ( &scache^.FreeListHead )

    KeInitializeLock ( &scache^.Lock )

    blocksperslab : UWORD
    slabsize : UWORD

    // Calculate the maximum size of a slab that we're willing to allocate.
    // This is configured to try to minimize fragmentation.

    IF size < MI_SMALL_POOL_BLOCK THEN
        // Size of one block is less than a fifth of the maximum pool request
        // size. Note that this divisor *must* be smaller than the value of
        // MI_MAX_BIG_BLOCKS_PER_SLAB or this attempt to minimize fragmentation
        // will actually worsen it.
        //
        // Pack as many as can fit in a maximum request.

        slabsize = size * MI_MAX_SMALL_BLOCKS_PER_SLAB

        IF slabsize >= MI_BLOCK_MAX_REQUEST_SIZE THEN
            slabsize = MI_BLOCK_MAX_REQUEST_SIZE - 1
        END

        // RtlPrint ( "small slabsize %d\n", slabsize )

    ELSE
        // Each slab allocation will trigger a page-aligned pool allocation.
        // To minimize fragmentation we anticipate this and try to fill each
        // page to the top.

        slabsize = (size * MI_MAX_BIG_BLOCKS_PER_SLAB + (RTL_PAGE_SIZE - 1))
            & ~(RTL_PAGE_SIZE - 1)

        // RtlPrint ( "big slabsize %d\n", slabsize )
    END

    // Calculate how many blocks can fit in the slab.
    //
    // First assume 1 block because we do special packing for the header of the
    // first block to pack both the slab header and back-pointer into the
    // pre-alignment space.

    blocksperslab = 1

    // First align down.

    blockbytes := slabsize & ~(RTL_ALIGN_BYTES - 1)

    // Now calculate how many bytes are available for blocks.
    // Remove the bytes for the first block which we optimistically assume can
    // also contain the slab header within its pre-alignment.

    blockbytes -= size

    IF NOT MI_HEADER_FITS_IN_ALIGNMENT THEN
        // The slab header doesn't fit in the alignment, so it needs to be
        // accounted for after all.

        blockbytes -= (SIZEOF MiSlabHeader + (RTL_ALIGN_BYTES - 1))
            & ~(RTL_ALIGN_BYTES - 1)
    END

    // Calculate how many blocks can fit in the remaining space.

    blocksperslab += blockbytes / size

    // Calculate the final slab size.

    slabsize = blocksperslab * size

    IF NOT MI_HEADER_FITS_IN_ALIGNMENT THEN
        // The slab header doesn't fit in the alignment, so it needs to be
        // accounted for after all.

        slabsize =
            (slabsize + SIZEOF MiSlabHeader + (RTL_ALIGN_BYTES - 1))
            & ~(RTL_ALIGN_BYTES - 1)
    END

    // RtlPrint ( "real slabsize %d blocksperslab %d blocksize %d\n", slabsize, blocksperslab, size )

    scache^.BlocksPerSlab = blocksperslab
    scache^.SlabSize = slabsize
END

FN MiExtendSlabCache (
    IN scache : ^MiSlabCache,
    IN ipl : UWORD,
    IN wait : UWORD,
) : ^VOID

    // Extend the slab cache. Its lock is held.
    // Returns TRUE if extended, FALSE otherwise.

@Retry

    slab := MmAllocatePoolEx (
        scache^.Node, // node
        scache^.PoolIndex, // poolindex
        scache^.SlabSize, // bytes
        scache^.Tag, // tag
        FALSE, // wait
    )

    // RtlPrint ( "extend %p\n", slab )

    IF NOT slab THEN
        // Failure.

        IF NOT wait THEN
            // Caller specified not to wait, so break out.

            RETURN FALSE
        END

        // We can't wait for pages with a slab cache lock held or we'll deadlock
        // memory management so instead we first try with wait=FALSE, and failing
        // that we wait for free pages outside of the lock.

        MiUnlockSlabCache ( scache, ipl )

        MiWaitForPages (
            &scache^.Node^.Partition, // partition
            PsCurrentThread()^.VmPrivileged, // low
        )

        MiLockSlabCache ( scache )

        GOTO Retry
    END

    scache^.ActiveSlabCount += 1

    // Initialize the slab header.

    slabheader : ^MiSlabHeader = slab
    slabheader^.References = 0

    // Initialize each block in the slab.

    block := (slab + SIZEOF MiSlabHeader + SIZEOF ^VOID + (RTL_ALIGN_BYTES - 1))
        & ~(RTL_ALIGN_BYTES - 1)

    firstblock := block

    blocksize := scache^.Size

    i := 0
    count := scache^.BlocksPerSlab

    WHILE i < count DO
        // Set back pointer to header.

        (CAST (block - SIZEOF ^VOID) TO ^^MiSlabHeader)^ = slabheader

        // Add to free list.

        RtlInsertAtTailList (
            &scache^.FreeListHead, // head
            CAST block TO ^RtlListEntry, // entry
        )

        i += 1
        block += blocksize
    END

    // Return the first block.

    RETURN firstblock
END

FN MiFreeSlab (
    IN scache : ^MiSlabCache,
    IN slab : ^MiSlabHeader,
)

    // Free a slab.

    // RtlPrint ( "free %p\n", slab )

    scache^.ActiveSlabCount -= 1

    KeAssert ( slab^.References == 0 )

    // First unlink all of the free blocks.

    block := (slab + SIZEOF MiSlabHeader + SIZEOF ^VOID + (RTL_ALIGN_BYTES - 1))
        & ~(RTL_ALIGN_BYTES - 1)

    i := 0
    count := scache^.BlocksPerSlab
    blocksize := scache^.Size

    WHILE i < count DO
        RtlRemoveEntryList ( CAST block TO ^RtlListEntry )

        i += 1
        block += blocksize
    END

    // Now free the actual pool allocation.

    MmFreePool (
        slab, // ptr
        scache^.Tag, // tag
    )
END

FN (MmPoolCacheAllocateF) MiAllocateFromSlabCache (
    IN context : ^VOID,
    IN wait : UWORD,
) : ^VOID

    // Allocate a single entry from a slab cache.
    // Return NULLPTR upon failure.

    scache := CAST context TO ^MiSlabCache

    ipl := MiLockSlabCache ( scache )

    block := scache^.FreeListHead.Next

    IF block == &scache^.FreeListHead THEN
        // There are no entries so we need to make more.

        block = MiExtendSlabCache (
            scache, // scache
            ipl, // ipl
            wait, // wait
        )

        IF NOT block THEN
            GOTO Exit
        END
    END

    // Increment the reference count on the slab header.

    (CAST (block - SIZEOF ^VOID) TO ^^MiSlabHeader)^^.References += 1

    // Pop the block from the free list.

    RtlRemoveEntryList ( CAST block TO ^RtlListEntry )

@Exit

    MiUnlockSlabCache ( scache, ipl )

    RETURN block
END

FN (MmPoolCacheFreeF) MiFreeToSlabCache (
    IN context : ^VOID,
    IN ptr : ^VOID,
)

    // Free a block to the given slab cache.

    scache := CAST context TO ^MiSlabCache

    ipl := MiLockSlabCache ( scache )

    slabheader := (CAST (ptr - SIZEOF ^VOID) TO ^^MiSlabHeader)^

    oldcount := slabheader^.References

    slabheader^.References = oldcount - 1

    // Add to free list.

    RtlInsertAtHeadList (
        &scache^.FreeListHead, // head
        CAST ptr TO ^RtlListEntry, // entry
    )

    IF oldcount == 1 THEN
        // Free the whole slab.

        MiFreeSlab (
            scache, // scache
            slabheader, // slabheader
        )
    END

    MiUnlockSlabCache ( scache, ipl )
END

#SECTION "PAGEtext"
EXPORT FN MmCreatePoolCacheEx (
    IN node : ^MiNode,
    IN name : ^UBYTE,
    IN size : UWORD,
    IN pageable : UWORD,
    IN allocfunc : MmPoolCacheAllocateF,
    IN freefunc : MmPoolCacheFreeF,
    IN deletefunc : MmPoolCacheDeleteF,
    IN context : ^VOID,
) : ^MiPoolCache

    // Allocate and return a new pool cache structure.

    cache : ^MiPoolCache = MiAllocateFromSlabCache (
        &node^.PoolCacheSlabs, // scache
        TRUE, // wait
    )

    IF NOT cache THEN
        RETURN NULLPTR
    END

    // Determine the magazine size based on whether the size of each cached
    // block is smaller or larger than what the slab layer considers a small
    // pool block.

    IF size < MI_SMALL_POOL_BLOCK THEN
        cache^.MagazineType = &node^.MagazineTypeTable[MI_MAGAZINE_SMALL]
    ELSE
        cache^.MagazineType = &node^.MagazineTypeTable[MI_MAGAZINE_LARGE]
    END

    // Save the name of the cache.

    cache^.Name = name

    cache^.Allocate = allocfunc
    cache^.Free = freefunc
    cache^.Delete = deletefunc
    cache^.Context = context

    cache^.Node = node

    KeInitializeLock ( &cache^.DepotLock )

    // Set the depot lists to empty.

    MiInitializeDepotList ( &cache^.FullMagazineList )
    MiInitializeDepotList ( &cache^.EmptyMagazineList )

    // Insert on global list.

    list : ^MiPoolCacheList

    IF NOT pageable THEN
        list = &node^.NpPoolCacheList
    ELSE
        list = &node^.PgPoolCacheList
    END

    MiLockPoolCacheList ( list )

    RtlInsertAtTailList (
        &list^.Head, // head
        &cache^.MasterListEntry, // entry
    )

    // Initialize the per-CPU caches with the global list lock still held to
    // synchronize against changes to the magazine type size.

    cpus := KeQueryProcessorCount ()

    i := 0

    percpu := MiPoolCachePerCpuById (
        cache, // cache
        0, // id
    )

    WHILE i < cpus DO
        KeInitializeLock ( &percpu^.MagLock )

        percpu^.Loaded = NULLPTR
        percpu^.Previous = NULLPTR
        percpu^.Rounds = -1
        percpu^.PreviousRounds = -1
        percpu^.MagazineSize = cache^.MagazineType^.Size

        i += 1
        percpu += MI_PCPCPU_SIZE
    END

    MiUnlockPoolCacheList ( list )

    RETURN cache
END

FN (MmPoolCacheDeleteF) MiDeleteSlabBackedCache (
    IN context : ^VOID,
)

    // A slab-backed pool cache is being deleted.
    // First, make sure all of the slabs are gone.

    scache := CAST context TO ^MiSlabCache

    KeAssert ( scache^.ActiveSlabCount == 0 )

    // Now release the slab cache.

    MiFreeToSlabCache (
        &scache^.Node^.SlabCacheSlabs, // scache
        scache, // ptr
    )
END

EXPORT FN MmCreatePoolCache (
    IN node : ^MiNode,
    IN name : ^UBYTE,
    IN size : UWORD,
    IN poolindex : UWORD,
    IN tag : UWORD,
) : ^MiPoolCache

    // Create a slab-backed pool cache.

    scache : ^MiSlabCache = MiAllocateFromSlabCache (
        &node^.SlabCacheSlabs, // scache
        TRUE, // wait
    )

    IF NOT scache THEN
        RETURN NULLPTR
    END

    // Initialize the slab cache used for allocating cached blocks.

    MiInitializeSlabCache (
        node, // node
        scache, // scache
        size, // size
        poolindex, // poolindex
        tag, // tag
    )

    // Create the pool cache with the appropriate slab callbacks.

    cache := MmCreatePoolCacheEx (
        node, // node
        name, // name
        size, // size
        poolindex != MM_NONPAGED_POOL, // pageable
        &MiAllocateFromSlabCache, // allocfunc
        &MiFreeToSlabCache, // freefunc
        &MiDeleteSlabBackedCache, // deletefunc
        scache, // context
    )

    IF NOT cache THEN
        // Failed to allocate the pool cache, so release the slab cache.

        MiFreeToSlabCache (
            &node^.SlabCacheSlabs, // scache
            scache, // ptr
        )
    END

    RETURN cache
END

FN MiDestroyAndFreeMagazine (
    IN cache : ^MiPoolCache,
    IN magazine : ^^VOID,
    IN rounds : UWORD,
)

    // Destroy the magazine.

    // Skip over the depot list link.

    magazine += SIZEOF ^VOID

    // Destroy and free each block contained in the magazine.

    i := 0

    WHILE i < rounds DO
        cache^.Free (
            cache^.Context, // context
            magazine[i], // ptr
        )

        i += 1
    END

    // Un-skip depot list link and free magazine.

    MmFreeToPoolCache (
        cache^.MagazineType^.PoolCache, // cache
        magazine - SIZEOF ^VOID, // ptr
    )
END

FN MiAllocateMagazineFromDepot (
    IN cache : ^MiPoolCache,
    IN list : ^MiDepotList,
) : ^^VOID

    // Allocate a magazine from the depot.

    ipl := MiLockPoolCacheDepot ( cache )

    magazine := list^.Head

    IF magazine THEN
        list^.Head = magazine^

        list^.Total -= 1

        IF list^.Total < list^.Min THEN
            // Increase the working set size by decreasing the number of
            // magazines that can be reaped.

            list^.Min = list^.Total
        END
    END

    MiUnlockPoolCacheDepot ( cache, ipl )

    RETURN magazine
END

FN MiFreeMagazineToDepot (
    IN cache : ^MiPoolCache,
    IN list : ^MiDepotList,
    IN magazine : ^^VOID,
)

    // Free a magazine to the depot.

    ipl := MiLockPoolCacheDepot ( cache )

    magazine^ = list^.Head
    list^.Head = magazine

    list^.Total += 1

    MiUnlockPoolCacheDepot ( cache, ipl )
END

FN MiReapDepotList (
    IN cache : ^MiPoolCache,
    IN list : ^MiDepotList,
    IN rounds : UWORD,
)

    // Reap magazines from the depot list until it is shrunk to its working set
    // size. Each magazine has the number of rounds specified.

    reap := list^.ReapLimit

    IF reap > list^.Min THEN
        // Don't reap more than was actually used since the last reaping.

        reap = list^.Min
    END

    // rept := 0

    WHILE reap DO
        magazine := MiAllocateMagazineFromDepot (
            cache, // cache
            list, // list
        )

        IF NOT magazine THEN
            BREAK
        END

        MiDestroyAndFreeMagazine (
            cache, // cache
            magazine, // magazine
            rounds, // rounds
        )

        // rept += 1
        reap -= 1
    END

    // IF rept THEN
    //     RtlPrint ( "[%s %d] ", cache^.Name, rept )
    // END
END

FN MiReapPoolCacheDepot (
    IN cache : ^MiPoolCache,
)

    // Reap magazines from the pool cache depot until all unused entries are
    // gone.

    MiReapDepotList (
        cache, // cache
        &cache^.FullMagazineList, // list
        cache^.MagazineType^.Size, // rounds
    )

    MiReapDepotList (
        cache, // cache
        &cache^.EmptyMagazineList, // list
        0, // rounds
    )
END

FN MiSetPoolCacheWsToZero (
    IN cache : ^MiPoolCache,
)

    // Set pool cache working set size to zero by making all entries reapable.

    ipl := MiLockPoolCacheDepot ( cache )

    cache^.FullMagazineList.Min = cache^.FullMagazineList.Total
    cache^.FullMagazineList.ReapLimit = cache^.FullMagazineList.Total

    cache^.EmptyMagazineList.Min = cache^.EmptyMagazineList.Total
    cache^.EmptyMagazineList.ReapLimit = cache^.EmptyMagazineList.Total

    MiUnlockPoolCacheDepot ( cache, ipl )
END

FN MiUpdatePoolCacheWs (
    IN cache : ^MiPoolCache,
)

    // Update the pool cache working set size before a round of reaping.

    ipl := MiLockPoolCacheDepot ( cache )

    cache^.FullMagazineList.ReapLimit = cache^.FullMagazineList.Min
    cache^.FullMagazineList.Min = cache^.FullMagazineList.Total

    cache^.EmptyMagazineList.ReapLimit = cache^.EmptyMagazineList.Min
    cache^.EmptyMagazineList.Min = cache^.EmptyMagazineList.Total

    MiUnlockPoolCacheDepot ( cache, ipl )
END

FN MiPurgeCpuMagazinesPoolCache (
    IN cache : ^MiPoolCache,
)

    // Purge the per-CPU magazine caches.

    percpu := MiPoolCachePerCpuById (
        cache, // cache
        0, // id
    )

    cpus := KeQueryProcessorCount ()
    i := 0

    WHILE i < cpus DO
        ipl := MiLockMagazineCache ( percpu )

        currentmag := percpu^.Loaded
        prevmag := percpu^.Previous
        rounds := CAST percpu^.Rounds TO UWORD
        prevrounds := CAST percpu^.PreviousRounds TO UWORD

        percpu^.Loaded = NULLPTR
        percpu^.Previous = NULLPTR
        percpu^.Rounds = -1
        percpu^.PreviousRounds = -1

        MiUnlockMagazineCache ( percpu, ipl )

        IF currentmag THEN
            MiDestroyAndFreeMagazine (
                cache, // cache
                currentmag, // magazine
                rounds, // rounds
            )
        END

        IF prevmag THEN
            MiDestroyAndFreeMagazine (
                cache, // cache
                prevmag, // magazine
                prevrounds, // rounds
            )
        END

        i += 1
        percpu += MI_PCPCPU_SIZE
    END
END

FN MiPurgeMagazinesPoolCache (
    IN cache : ^MiPoolCache,
)

    // Purge the magazines of the given pool cache.
    // If this is a result of a resize operation then the global cache list
    // lock is held. If it's the result of an MmDeletePoolCache then no lock is
    // needed.

    MiPurgeCpuMagazinesPoolCache ( cache )

    // Set the working set size of the pool cache to zero.

    MiSetPoolCacheWsToZero ( cache )

    // Reap down to the new working set size, which is zero.

    MiReapPoolCacheDepot ( cache )
END

#SECTION "PAGEtext"
EXPORT FN MmDeletePoolCache (
    IN cache : ^MiPoolCache,
)

    // Delete a pool cache.

    node := cache^.Node

    // Remove from global list.

    list : ^MiPoolCacheList

    IF NOT cache^.Pageable THEN
        list = &node^.NpPoolCacheList
    ELSE
        list = &node^.PgPoolCacheList
    END

    MiLockPoolCacheList ( list )

    RtlRemoveEntryList ( &cache^.MasterListEntry )

    MiUnlockPoolCacheList ( list )

    // Empty out the magazine depot.

    MiPurgeMagazinesPoolCache ( cache )

    // Call the destructor.

    IF cache^.Delete THEN
        cache^.Delete ( cache^.Context )
    END

    // Free pool cache to pool cache slab cache.
    // Say that ten times fast.

    MiFreeToSlabCache (
        &node^.PoolCacheSlabs, // scache
        cache, // ptr
    )
END

FN MiReloadMagazines (
    IN percpu : ^MiPoolCachePerCpu,
    IN newloaded : ^^VOID,
    IN rounds : WORD,
)

    // Swap the previous and loaded magazines.

    percpu^.Previous = percpu^.Loaded
    percpu^.PreviousRounds = percpu^.Rounds

    percpu^.Loaded = newloaded
    percpu^.Rounds = rounds
END

EXPORT FN MmAllocateFromPoolCache (
    IN cache : ^MiPoolCache,
    IN wait : UWORD,
) : ^VOID

    // Allocate a block from the pool cache.

    block : ^VOID
    rounds : WORD

    // Acquire a pointer to the pool cache's per-cpu magazine cache.

    percpu := MiPoolCachePerCpuById (
        cache, // cache
        KeCurrentProcessorId (), // id
    )

    ipl := MiLockMagazineCache ( percpu )

@Retry

    // Try to grab a block from the loaded magazine.

    rounds = percpu^.Rounds

    IF rounds > 0 THEN
        // NOTE: The cache link pointer in the zeroth element of the magazine is
        //       skipped in a subtle way here that shouldn't be confused with an
        //       off-by-one bug.

        block = percpu^.Loaded[rounds]
        percpu^.Rounds = rounds - 1

        MiUnlockMagazineCache ( percpu, ipl )

        RETURN block
    END

    // Loaded magazine was empty, try to reload.

    rounds = percpu^.PreviousRounds

    IF rounds > 0 THEN
        MiReloadMagazines (
            percpu, // percpu
            percpu^.Previous, // newloaded
            rounds, // rounds
        )

        GOTO Retry
    END

    // Can't reload the previous magazine, allocate from the depot.

    magazine := MiAllocateMagazineFromDepot (
        cache, // cache
        &cache^.FullMagazineList, // list
    )

    IF magazine THEN
        // Got a full magazine.

        IF percpu^.Previous THEN
            // First free the previous magazine to the empty magazine list.

            KeAssert ( percpu^.PreviousRounds == 0 )

            MiFreeMagazineToDepot (
                cache, // cache
                &cache^.EmptyMagazineList, // list
                percpu^.Previous, // magazine
            )
        END

        MiReloadMagazines (
            percpu, // percpu
            magazine, // newloaded
            CAST percpu^.MagazineSize TO WORD, // rounds
        )

        GOTO Retry
    END

    MiUnlockMagazineCache ( percpu, ipl )

    // Magazine layer wasn't of any help so we need to drop through to the slab
    // layer of this cache.

    RETURN cache^.Allocate (
        cache^.Context, // context
        wait, // wait
    )
END

EXPORT FN MmFreeToPoolCache (
    IN cache : ^MiPoolCache,
    IN ptr : ^VOID,
)

    // Free a block to the pool cache.

    rounds : WORD

    // Acquire a pointer to the pool cache's per-cpu magazine cache.

    percpu := MiPoolCachePerCpuById (
        cache, // cache
        KeCurrentProcessorId (), // id
    )

    ipl := MiLockMagazineCache ( percpu )

@Retry

    rounds = percpu^.Rounds

    IF (CAST rounds TO UWORD) < percpu^.MagazineSize THEN
        // There's room in the loaded magazine.
        // Make sure to skip over the depot list link, which occupies the zeroth
        // element of the magazine.

        percpu^.Loaded[rounds + 1] = ptr
        percpu^.Rounds = rounds + 1

        MiUnlockMagazineCache ( percpu, ipl )

        LEAVE
    END

    // Loaded magazine is full. Swap with previous if empty.

    IF percpu^.PreviousRounds == 0 THEN
        MiReloadMagazines (
            percpu, // percpu
            percpu^.Previous, // newloaded
            0, // rounds
        )

        GOTO Retry
    END

    IF PsCurrentNode () != cache^.Node THEN
        // This is a CPU foreign to the preferred NUMA node of the pool cache.
        // Bypass the magazine layer since it won't do any good to have some
        // foreign CPU take up magazines in another NUMA node's pool cache.

        GOTO BypassMagazines
    END

    // Allocate a new magazine into the CPU layer.

    magazine := MiAllocateMagazineFromDepot (
        cache, // cache
        &cache^.EmptyMagazineList, // list
    )

    IF magazine THEN
        // Got an empty magazine to load.

        IF percpu^.Previous THEN
            // First free the previous magazine to the full magazine list.

            KeAssert ( percpu^.PreviousRounds == percpu^.MagazineSize )

            MiFreeMagazineToDepot (
                cache, // cache
                &cache^.FullMagazineList, // list
                percpu^.Previous, // magazine
            )
        END

        // Load it and free the block into it.

        MiReloadMagazines (
            percpu, // percpu
            magazine, // newloaded
            0, // rounds
        )

        GOTO Retry
    END

    // The depot is out of empty magazines.
    // Unlock the magazine cache and allocate a new one.

    magtype := cache^.MagazineType

    MiUnlockMagazineCache ( percpu, ipl )

    magazine = MmAllocateFromPoolCache (
        magtype^.PoolCache, // cache
        FALSE, // wait
    )

    ipl = MiLockMagazineCache ( percpu )

    IF magazine THEN
        // Got a magazine.

        IF percpu^.MagazineSize != magtype^.Size THEN
            // The magazine type size was changed.
            // Retry.

            MiUnlockMagazineCache ( percpu, ipl )

            MmFreeToPoolCache (
                magtype^.PoolCache, // cache
                magazine, // ptr
            )

            ipl = MiLockMagazineCache ( percpu )

            GOTO Retry
        END

        // Add to the depot and retry.

        MiFreeMagazineToDepot (
            cache, // cache
            &cache^.EmptyMagazineList, // list
            magazine, // magazine
        )

        GOTO Retry
    END

@BypassMagazines

    MiUnlockMagazineCache ( percpu, ipl )

    // Failed to get a magazine, our last resort is to just free the block
    // directly to the slab layer.

    cache^.Free (
        cache^.Context, // context
        ptr, // ptr
    )
END

#SECTION "INITtext"
FN MiInitializeMagazineType (
    IN node : ^MiNode,
    IN magtype : ^MiMagazineType,
    IN name : ^UBYTE,
    IN size : UWORD,
)

    // Initialize a magazine type.

    magtype^.Size = size

    magtype^.PoolCache = MmCreatePoolCache (
        node, // node
        name, // name
        (size + 1) * SIZEOF ^VOID, // size
        MM_NONPAGED_POOL, // poolindex
        'Magz', // tag
    )

#ENTERSECTION "INITtext"
    IF NOT magtype^.PoolCache THEN
        KeCrash ( "MiInitializeMagazineType: failed to create pool cache\n" )
    END
#LEAVESECTION

END

FN MiAdjustPoolCache (
    IN cache : ^MiPoolCache,
)

    // Adjust a pool cache.
    // This involves reaping the working set.

    MiUpdatePoolCacheWs ( cache )

    MiReapPoolCacheDepot ( cache )
END

FN MiAdjustPoolCaches (
    IN list : ^MiPoolCacheList,
    IN purge : UWORD,
)

    // Adjust all of the pool caches on the given node.

    MiLockPoolCacheList ( list )

    listhead := &list^.Head
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        cache := CONTAINEROF listentry TO MiPoolCache.MasterListEntry

        IF purge THEN
            MiPurgeCpuMagazinesPoolCache ( cache )
        END

        MiAdjustPoolCache ( cache )

        listentry = listentry^.Next
    END

    MiUnlockPoolCacheList ( list )
END

#DEFINE MI_POOL_ADJUSTMENT_INTERVAL_MS 5000
#DEFINE MI_POOL_PURGE_INTERVAL_MS 10000

FN MiEnqueuePoolCacheAdjustment (
    IN node : ^MiNode,
    IN counter : UWORD,
)

    // Enqueue the pool cache adjustment item.

    intervalms := MI_POOL_ADJUSTMENT_INTERVAL_MS

    interval : RtlUquad

    RtlSetUquadToUlong (
        &interval, // interval
        intervalms, // ulong
    )

    ExEnqueueTimedWorkItem (
        &node^.PoolCacheAdjustmentItem, // item
        EX_HIGH_WORK_PRIORITY, // priority
        &interval, // interval
        CAST node TO UWORD, // context1
        counter + intervalms, // context2
    )
END

FN (ExWorkItemF) MiAdjustPoolCachesWorker (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

    // Called periodically to adjust the pool caches on a node.

    node := CAST context1 TO ^MiNode

    purge := context2 >= MI_POOL_PURGE_INTERVAL_MS

    IF purge THEN
        context2 = 0

        IF node^.Partition.AvailablePageCount >=
            node^.Partition.SufficientPageCount THEN

            purge = 0
        END
    END

    MiAdjustPoolCaches (
        &node^.PgPoolCacheList, // list
        purge, // purge
    )

    MiAdjustPoolCaches (
        &node^.NpPoolCacheList, // list
        purge, // purge
    )

    MiEnqueuePoolCacheAdjustment (
        node, // node
        context2, // counter
    )
END

#MACRO MiInitializePoolCacheList ( list ) [
    KeInitializeLock ( &(list)^.MasterListLock )
    RtlInitializeList ( &(list)^.Head )
]

#SECTION "INITtext"
FN MiInitializePoolCache (
    IN node : ^MiNode,
)

    // Initialize the pool cache.

    MiInitializePoolCacheList ( &node^.PgPoolCacheList )
    MiInitializePoolCacheList ( &node^.NpPoolCacheList )

    // Initialize a slab cache to allocate pool caches from.

    MiInitializeSlabCache (
        node, // node
        &node^.PoolCacheSlabs, // scache
        MI_PC_SIZE + KeQueryProcessorCount () * MI_PCPCPU_SIZE, // size
        MM_NONPAGED_POOL, // poolindex
        'PoCa', // tag
    )

    // Initialize a slab cache to allocate slab caches from.

    MiInitializeSlabCache (
        node, // node
        &node^.SlabCacheSlabs, // scache
        SIZEOF MiSlabCache, // size
        MM_NONPAGED_POOL, // poolindex
        'PoSl', // tag
    )

    // Initialize the magazine types.

    MiInitializeMagazineType (
        node, // node
        &node^.MagazineTypeTable[MI_MAGAZINE_SMALL], // magtype
        "Small Block Magazines", // name
        MI_SMALL_MAGAZINE_SIZE, // size
    )

    MiInitializeMagazineType (
        node, // node
        &node^.MagazineTypeTable[MI_MAGAZINE_LARGE], // magtype
        "Large Block Magazines", // name
        MI_LARGE_MAGAZINE_SIZE, // size
    )

    // Initialize the adjustment item.

    ExInitializeTimedWorkItem (
        &node^.PoolCacheAdjustmentItem, // item
        &MiAdjustPoolCachesWorker, // routine
    )

    // And set it pending for the first time.

    MiEnqueuePoolCacheAdjustment ( node, 0 )
END