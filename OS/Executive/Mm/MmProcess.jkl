//
// Implements process support in the Memory Manager.
//

#INCLUDE "Mmp.hjk"

#INCLUDE "<ll>/System/OsProcess.hjk"

#SECTION "PAGEtext"
FN MmuInitializeProcess (
    IN parentprocess : ^PsuProcess,
    IN process : ^PsuProcess,
    IN partition : ^MmpPartition,
) : OsStatus

    // Initialize the process so it can be used by the memory manager.

    IF NOT MmpIsPartitionPhysical ( partition ) THEN
        // This is not a partition inherent to a NUMA node so we need to up the
        // refcount. NUMA node partitions are eternal and don't have refcounts,
        // so we don't do this in that case.

        ObReferenceObject ( partition )
    END

    process^.WorkingSetSize = 0
    process^.PageFaultCount = 0

    // Set the partition object.

    process^.Partition = partition

    IF NOT partition^.Node^.KeNode^.SystemProcess THEN
        // There's no system process for this node yet, so we're creating it
        // right now. Give it the system page directory.

        process^.Pcb.PageDirectoryPfn =
            partition^.Node^.KeNode^.SystemPageDirectoryPfn

    ELSE
        KeCrash ( "NYI create address space\n" )
    END

    RETURN OS_STATUS_SUCCESS
END

#SECTION "PAGEtext"
FN MmuUninitializeProcess (
    IN process : ^PsuProcess,
)

    // Uninitialize a process that was previously initialized.

    // We uninitialize everything, except for the page directory. We still need
    // that because we might be in the address space of that process right now.

    KeCrash ( "MmuUninitializeProcess NYI\n" )
END

#SECTION "PAGEtext"
FN MmuDeleteProcess (
    IN process : ^PsuProcess,
)

    // Finish deleting a process.

    // First delete the page directory.

    KeCrash ( "MmuDeleteProcess NYI\n" )

    partition := process^.Partition

    IF NOT MmpIsPartitionPhysical ( partition ) THEN
        // Unreference the partition object.

        // Only do this after every page frame the process might possibly have
        // ever consumed (including page directory, tables, etc) has been
        // returned.

        ObUnreferenceObject ( process^.Partition )
    END
END

#SECTION "PAGEtext"
FN MmuInitializeThread (
    IN process : ^PsuProcess,
    IN thread : ^PsuThread,
    IN mode : UWORD,
) : OsStatus

    // Initialize the thread's virtual memory state.
    // If it's a usermode thread, this involves creating a TEB and user stack.
    // XXX Or don't, review discussions on runtime responsibility for this

    thread^.VmPrivileged = FALSE

    IF mode == KE_USER_MODE THEN
        KeCrash ( "MmuInitializeThread NYI\n" )
    END

    RETURN OS_STATUS_SUCCESS
END

#SECTION "PAGEtext"
FN MmuUninitializeThread (
    IN process : ^PsuProcess,
    IN thread : ^PsuThread,
)

    // Uninitialize the thread's virtual memory state.
    // If it's a usermode thread, free its TEB and user stack.
    // XXX Or don't, review discussions on runtime responsibility for this

    IF thread^.Paged^.Mode == KE_USER_MODE THEN
        KeCrash ( "MmuUninitializeThread NYI\n" )
    END
END

#SECTION "PAGEtext"
FN MmuQueryProcess (
    IN process : ^PsuProcess,
    IN query : ^OsProcessQuery,
)

    // Fill in the memory management specific parts of the process query.

    query^.WorkingSetSize = process^.WorkingSetSize
    query^.PageFaultCount = process^.PageFaultCount
END

// The following functions are defined as macros for speed purposes within the
// Executive but are exported as real functions for the benefit of kernel
// modules, so we don't need to export these structures.

#UNDEFINE MmCurrentNode
#UNDEFINE MmCurrentPartition

EXPORT FN MmCurrentNode () : ^MmpNode

    // Return the current node.

    RETURN PsCurrentNode()^.Mmp
END

EXPORT FN MmCurrentPartition () : ^MmpPartition

    // Return the current partition.

    RETURN PsCurrentProcess()^.Partition
END