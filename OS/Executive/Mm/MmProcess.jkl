//
// Implements process support in the Memory Manager.
//

#INCLUDE "Mmp.hjk"

#INCLUDE "<ll>/System/OsProcess.hjk"

#SECTION "PAGEtext"
FN MmuInitializeProcess (
    IN parentprocess : ^PsuProcess,
    IN process : ^PsuProcess,
    IN partition : ^MmpPartition,
) : OsStatus

    // Initialize the process so it can be used by the memory manager.

    IF NOT partition THEN
        // No partition object supplied, use the parent process's partition.

        partition = parentprocess^.Partition
    END

    IF NOT MmpIsPartitionPhysical ( partition ) THEN
        // This is not a partition inherent to a NUMA node so we need to up the
        // refcount. NUMA node partitions are eternal and don't have refcounts,
        // so we can't do this in that case.

        ObuReferenceObject ( partition )
    END

    process^.WorkingSetSize = 0
    process^.PageFaultCount = 0

    // Set the partition object.

    process^.Partition = partition
    process^.Node = partition^.Node

    IF NOT PsuSystemProcess THEN
        // This is the system process, so give it the system page directory.

        process^.Pcb.PageDirectoryPfn = KeuSystemPageDirectoryPfn

    ELSE
        KeCrash ( "NYI create address space\n" )
    END

    RETURN OS_STATUS_SUCCESS
END

#SECTION "PAGEtext"
FN MmuUninitializeProcess (
    IN process : ^PsuProcess,
)

    // Uninitialize a process that was previously initialized.

    // We uninitialize everything, except for the page directory. We still need
    // that because we might be in the address space of that process right now.

    KeCrash ( "MmuUninitializeProcess NYI\n" )
END

#SECTION "PAGEtext"
FN MmuDeleteProcess (
    IN process : ^PsuProcess,
)

    // Finish deleting a process.

    // First delete the page directory.

    KeCrash ( "MmuDeleteProcess NYI\n" )

    partition := process^.Partition

    IF NOT MmpIsPartitionPhysical ( partition ) THEN
        // Unreference the partition object.

        // Only do this after every page frame the process might possibly have
        // ever consumed (including page directory, tables, etc) has been
        // returned.

        ObuUnreferenceObject ( process^.Partition )
    END
END

#SECTION "PAGEtext"
FN MmuInitializeThread (
    IN process : ^PsuProcess,
    IN thread : ^PsuThread,
    IN mode : UWORD,
) : OsStatus

    // Initialize the thread's virtual memory state.
    // If it's a usermode thread, this involves creating a TEB and user stack.
    // XXX Or don't, review discussions on runtime responsibility for this

    thread^.VmPrivileged = FALSE

    IF mode == KE_USER_MODE THEN
        KeCrash ( "MmuInitializeThread NYI\n" )
    END

    RETURN OS_STATUS_SUCCESS
END

#SECTION "PAGEtext"
FN MmuUninitializeThread (
    IN process : ^PsuProcess,
    IN thread : ^PsuThread,
)

    // Uninitialize the thread's virtual memory state.
    // If it's a usermode thread, free its TEB and user stack.
    // XXX Or don't, review discussions on runtime responsibility for this

    IF thread^.Paged^.Mode == KE_USER_MODE THEN
        KeCrash ( "MmuUninitializeThread NYI\n" )
    END
END

#SECTION "PAGEtext"
FN MmuQueryProcess (
    IN process : ^PsuProcess,
    IN query : ^OsProcessQuery,
)

    // Fill in the memory management specific parts of the process query.

    query^.WorkingSetSize = process^.WorkingSetSize
    query^.PageFaultCount = process^.PageFaultCount
END