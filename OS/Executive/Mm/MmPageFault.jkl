//
// Implements the MINTIA page fault handler.
//

#INCLUDE "Mmp.hjk"

FN MmuPageFault (
    IN address : ^VOID,
    IN writing : UWORD,
    IN usermode : UWORD,
) : OsStatus

    thread := PsCurrentThread ()

    // TEMP
    RtlPrint ( "fault on %x\n", address )

    IF writing THEN
        RETURN OS_STATUS_WRITE_FAULT
    ELSE
        RETURN OS_STATUS_READ_FAULT
    END

    IF thread^.VmPrivileged THEN
        // A VM-privileged thread must never take a page fault or deadlock could
        // result.

        KeCrash ( "VM-privileged thread faulted upon %p\n", address )
    END
END

FN MmuWriteFaultOnLockWord (
    IN lockptr : ^VOID,
)

    // Called by the turnstile package when a fault was taken on the lock word.
    // We need to fault in the containing page and make sure it's set modified.

    // Ignore the return status from MmuPageFault because if it failed, we want
    // the turnstile package to find that out later and die in a "normal" way.
    // Simple dirty faults are infallible so we don't have to worry about that
    // case.

    MmuPageFault (
        lockptr, // address
        TRUE, // writing
        FALSE, // usermode
    )
END

FN MmuShouldAccessCrash (
    IN abortblock : ^KeAbortBlock,
    IN badaddr : ^VOID,
    IN status : OsStatus,
) : UWORD

    // Returns TRUE if the access should crash the system, FALSE if it should
    // cause an abort. Called by architecture specific code upon various types
    // of address errors, if an abort block was set up by KeExceptionJacket.

    // This was an address error, so check where the address was.
    // The abort block will contain flags telling us whether to catch this
    // exception or not. If we shouldn't, we'll crash. This is a basic
    // security/debugging measure and not strictly necessary for
    // functionality.

    IF badaddr >= MMP_SYSTEM_SPACE THEN
        // Check if we should catch system space errors.
        // If we shouldn't, or if the status was not an inpage IO error, crash
        // the system.

        // In system space we ONLY catch inpage IO errors because this is the
        // only valid type of fallible memory access in the kernel. Kernel mode
        // code should not be using pointers to bad addresses in kernel space
        // and they should never be forgiven for doing so.

        IF abortblock^.Flags & KE_ABORT_CATCH_SYSTEM_SPACE == 0
            OR status != OS_STATUS_INPAGE_IO_ERROR THEN

            // Nope.

            RETURN TRUE
        END

    ELSEIF abortblock^.Flags & KE_ABORT_CATCH_USER_SPACE == 0 THEN
        // This was a userspace error and we aren't catching those.

        RETURN TRUE
    END

    RETURN FALSE
END