//
// Implements the MINTIA Zero Page Worker thread.
//

#INCLUDE "Mi.hjk"
#INCLUDE "<ll>/System/OsProcess.hjk"

#DEFINE MI_ZERO_BATCH 4
#DEFINE MI_ZERO_MAXIMUM 64
#DEFINE MI_ZERO_DELAY 100

FN (KeStartThreadF) MmZeroPageWorker (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

    // Loop waiting on an event object which is signaled when there are more
    // than a threshold of free pages. Then, zero them out and place them on
    // the zeroed page list.

    partition := PsCurrentPartition ()

    zerobatch : ^MiPfe[MI_ZERO_BATCH]

    interval : RtlUquad

    RtlSetUquadToUlong (
        &interval, // uquad
        MI_ZERO_DELAY, // ulong
    )

    // Set myself to the idle priority.

    KeSetBasePriorityThread (
        KeCurrentThread (), // thread
        OS_PRIORITY_IDLE, // priority
        TRUE, // setcurrentpriority
    )

    WHILE TRUE DO
        // Wait for there to be more than a threshold of free pages.

        KeWaitForSingleObject (
            KE_KERNEL_MODE, // waitmode
            KE_UNALERTABLE, // alertable
            NULLPTR, // timeout
            &partition^.ZeroPageEvent.Header, // object
        )

        // Zero at most 64 pages during each 100ms interval.
        // We will zero a maximum of 640 pages per second which is about 2.5MB.

        count : WORD = MI_ZERO_MAXIMUM

        WHILE count > 0 DO
            IF partition^.FreeList.Count < MI_ZERO_BATCH THEN
                BREAK
            END

            i := 0

            ipl := MiAcquireListExclusive ( partition )

            IF partition^.AvailablePageCount < partition^.SufficientPageCount OR
                partition^.FreeList.Count < MI_ZERO_BATCH THEN

                // Don't zero any pages if people are trying to make memory
                // right now. We'd only step on their toes by holding pages
                // hostage at idle priority.

                MiReleaseList ( partition, ipl )

                BREAK
            END

            WHILE i < MI_ZERO_BATCH DO
                zerobatch[i] = MiAllocatePageFromList (
                    &partition^.FreeList, // list
                    0, // color
                )

                i += 1
            END

            // Decrement available pages to reflect the ones we removed from
            // the zero page list.

            avail := partition^.AvailablePageCount - MI_ZERO_BATCH
            partition^.AvailablePageCount = avail

            MiReleaseList ( partition, ipl )

            // Zero the pages.

            i = 0

            WHILE i < MI_ZERO_BATCH DO
                MmZeroPage ( MiPfeToPfn ( zerobatch[i] ) )

                i += 1
            END

            // Place on zeroed list.

            i = 0

            ipl = MiAcquireListExclusive ( partition )

            WHILE i < MI_ZERO_BATCH DO
                MiInsertPageIntoList (
                    &partition^.ZeroList, // list
                    zerobatch[i], // pfe
                    TRUE, // head
                )

                i += 1
            END

            // Increment available pages to reflect the ones added to the zero
            // page list.

            avail = partition^.AvailablePageCount + MI_ZERO_BATCH
            partition^.AvailablePageCount = avail

            MiReleaseList ( partition, ipl )

            // Wake waiters for available pages.

            MiNewAvailablePage ( partition, avail )

            count -= MI_ZERO_BATCH
        END

        // Sleep for 100ms to avoid using too much memory bandwidth.

        KeSleep (
            &interval, // interval
            KE_KERNEL_MODE, // waitmode
            KE_UNALERTABLE, // alertable
        )
    END
END