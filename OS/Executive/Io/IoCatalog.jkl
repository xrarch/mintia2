//
// The I/O Catalog tracks the device drivers known to the system and enables
// driver matching.
//

#INCLUDE "Iop.hjk"
#INCLUDE "../../Loader/Headers/Loader.hjk"

IopCatalogLock : KeLock = KE_INITIAL_LOCK

#SECTION "PAGEtext"
FN IopForgetModule (
    IN modulename : ^UBYTE,
) : OsStatus

    // Forcibly forget a module. The catalog lock is held on entry.

    // First look up the module.

    // If the module wasn't found, nothing to do.

    // If the module was found and is currently loaded, unlock the catalog lock
    // and initiate an unload and then retry the whole operation. If the unload
    // fails, propagate the status to the caller.

    // If the module was found and is unloaded, forget about it from the
    // catalog.

    RETURN OS_STATUS_NOT_IMPLEMENTED
END

#SECTION "PAGEtext"
FN IopProcessConfiguration (
    IN modulename : ^UBYTE,
    IN configtext : ^UBYTE,
    IN configsize : UWORD,
) : OsStatus

    // Process a driver configuration file.

    class : ^IopKnownClass

    // First parse the configuration and create an IopKnownClass for each
    // described class.

    status := IopParseConfiguration (
        configtext, // configtext
        configsize, // configsize
        OUT class, // class
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    // Now take the catalog lock.

    KeAcquireLockExclusive ( &IopCatalogLock )

    // If we already processed a configuration file for this module, we want to
    // forget whatever we learned there. 

    status = IopForgetModule ( modulename )

    IF OsError ( status ) THEN
        GOTO Exit
    END

    // Insert all of the known classes into the IO catalog.

    // ...

@Exit

    KeReleaseLock ( &IopCatalogLock )

    RETURN status
END

#ENTERSECTION "INITtext"

FN IopInitializeCatalog ()

    // Initialize the IO Catalog.
    //
    // We need to process all of the configuration files loaded by the
    // bootloader.

    listhead := &KeuLoaderBlock.ResourceListHead
    listentry := listhead^.Next

    WHILE listentry != listhead DO
        rsrc := CONTAINEROF listentry TO BlResource.Entry

        IF rsrc^.IoConfig THEN
            IopProcessConfiguration (
                &rsrc^.Name[0], // modulename
                rsrc^.Data, // configtext
                rsrc^.Size, // configsize
            )
        END

        listentry = listentry^.Next
    END
END

#LEAVESECTION