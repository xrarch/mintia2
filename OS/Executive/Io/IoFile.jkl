//
// Implements the File object type for the I/O subsystem of the MINTIA
// Executive.
//

#INCLUDE "Iop.hjk"

#SECTION "PAGEtext"
FN (ObuTypeOpenF) IopOpenFileObject (
    IN process : ^PsuProcess,
    IN object : ^VOID,
    IN access : UWORD,
) : OsStatus

    // Call the driver's file object open function, if present.

    file := CAST object TO ^IoFile

    fcb := file^.Fcb

    IF NOT fcb THEN
        // This is a file object for a namespace container.

        RETURN OS_STATUS_SUCCESS
    END

    RETURN fcb^.Dispatch^.OpenFileObject (
        process, // process
        file, // file
        access, // access
    )
END

#SECTION "PAGEtext"
FN (ObuTypeCloseF) IopCloseFileObject (
    IN object : ^VOID,
    IN access : UWORD,
    IN lasthandlecount : UWORD,
)

    // Call the driver's file object close function, if present.

    file := CAST object TO ^IoFile

    fcb := file^.Fcb

    IF NOT fcb THEN
        // This is a file object for a namespace container.

        LEAVE
    END

    fcb^.Dispatch^.CloseFileObject (
        file, // file
        access, // access
        lasthandlecount, // lasthandlecount
    )
END

#SECTION "PAGEtext"
FN (ObuTypeDeleteF) IopDeleteFileObject (
    IN object : ^VOID,
) : UWORD

    // Delete a file object.

    file := CAST object TO ^IoFile

    // Call the driver's file object deletion function, if present.

    fcb := file^.Fcb

    IF fcb THEN
        fcb^.Dispatch^.DeleteFileObject ( file )
    END

    // Unreference the namespace handle tracked by the file object.

    NsuUnreferenceHandle ( &file^.Handle )

    RETURN TRUE
END

#SECTION "PAGEtext"
FN (ObuTypeSetSecurityF) IopSetSecurityFileObject (
    IN object : ^VOID,
    IN permissions : ^ObPermissions,
) : OsStatus

    // Acquire a pointer to the namespace entry and call the driver's file
    // object security function, if present.

    file := CAST object TO ^IoFile

    fcb := file^.Fcb

    IF NOT fcb THEN
        // This is a file object for a namespace container.

        RETURN OS_STATUS_SUCCESS
    END

    RETURN fcb^.Dispatch^.SetSecurityFcb (
        fcb, // fcb
        permissions, // permissions
    )
END

#SECTION "PAGEtext"
FN (ObuTypeDeleteF) IopDeleteFcbObject (
    IN object : ^VOID,
) : UWORD

    // Delete an FCB object.

    fcb := CAST object TO ^IoFcb

    // Call the driver's FCB deletion function, if present.

    RETURN fcb^.Dispatch^.DeleteFcb ( fcb )
END

#SECTION "PAGEtext"
FN (ObuTypeNamespaceLookupF) IopNamespaceLookupFcbObject (
    IN context : ^NsuLookupContext,
) : OsStatus

    // Lookup a name under this FCB.

    fcb := CAST context^.Object TO ^IoFcb

    RETURN fcb^.Dispatch^.NamespaceLookup ( context )
END

PUBLIC IoFileType : ObuType = {
    [Name] = "File",

    [Open] = &IopOpenFileObject,
    [Close] = &IopCloseFileObject,
    [Delete] = &IopDeleteFileObject,
    [SetSecurity] = &IopSetSecurityFileObject,

    [WaitOffset] = OBU_TYPE_NO_WAIT_OFFSET,
    [TypeIdentifier] = OS_FILE_TYPE,
    [Tag] = 'File',

    [TypicalBodySize] = SIZEOF IoFile,

    [IsPaged] = TRUE,
}

PUBLIC IoFcbType : ObuType = {
    [Name] = "Fcb",

    [Delete] = &IopDeleteFcbObject,
    [NamespaceLookup] = &IopNamespaceLookupFcbObject,

    [WaitOffset] = OBU_TYPE_NO_WAIT_OFFSET,
    [TypeIdentifier] = OS_FCB_TYPE,
    [Tag] = 'Fcb',

    [TypicalBodySize] = SIZEOF IoFcb,

    [IsPaged] = FALSE,
}