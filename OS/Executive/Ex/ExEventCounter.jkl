//
// Implements event counters, which are little refcounted memory blocks
// containing event objects.
//

#INCLUDE "Exp.hjk"

ExpEventCounterCache : ^MmpPoolCache

#SECTION "INITtext"
FN ExpInitializeEventCounters ()

    // Initialize the event counter list.

    ExpEventCounterCache = MmCreatePoolCache (
        PsuCurrentNode (), // node
        "Event Counters", // name
        SIZEOF ExuEventCounter, // size
        MM_NONPAGED_POOL, // poolindex
        'EvCn', // tag
    )

#ENTERSECTION "INITtext"
    IF NOT ExpEventCounterCache THEN
        KeCrash ( "ExpInitializeEventCounters: failed to create cache\n" )
    END
#LEAVESECTION

END

FN ExAllocateEventCounter (
    IN wait : UWORD,
) : ^ExuEventCounter

    // Allocate an event counter.

    counter : ^ExuEventCounter = MmAllocateFromPoolCache (
        ExpEventCounterCache, // cache
        wait, // wait
    )

    IF NOT counter THEN
        RETURN NULLPTR
    END

    KeInitializeEvent (
        &counter^.Event, // event
        "Collision Counter", // name
        TRUE, // notification
        FALSE, // signalstate
    )

    counter^.References = 1

    RETURN counter
END

FN ExReferenceEventCounter (
    IN counter : ^ExuEventCounter,
)

    // Increment the refcount of the counter.

    oldcount := KeIncrementUlong (
        &counter^.References, // ptr
        1, // inc
    )

    KeAssert ( oldcount != 0 )
END

FN ExUnreferenceEventCounter (
    IN counter : ^ExuEventCounter,
)

    // Decrement the refcount of the counter.

    oldcount := KeIncrementUlong (
        &counter^.References, // ptr
        0xFFFFFFFF, // inc
    )

    KeAssert ( oldcount != 0 )

    IF oldcount == 1 THEN
        // This was the last user of this event counter. Put it on the list.

        MmFreeToPoolCache (
            ExpEventCounterCache, // cache
            counter, // ptr
        )
    END
END