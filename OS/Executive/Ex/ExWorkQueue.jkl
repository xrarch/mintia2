//
// Implements system work queue threads.
//

#INCLUDE "Exp.hjk"
#INCLUDE "../../Loader/Headers/Loader.hjk"

ExpWorkQueues : KeBalancedQueue[EXU_MAX_WORK_PRIORITY]

FN (KeStartThreadF) ExpWorkQueueLoop (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

    // This is the main loop for all of the worker threads.
    // My priority was already set by ExpInitializeWorkQueues.
    // I will spin waiting for work forever.

    queue := CAST context1 TO ^KeBalancedQueue

    WHILE TRUE DO
        entry : ^RtlListEntry

        status := KeRemoveFromBalancedQueue (
            queue, // queue
            KE_KERNEL_MODE, // waitmode
            FALSE, // alertable
            NULLPTR, // timeout
            OUT entry, // item
        )

        KeAssert ( NOT OsError ( status ) )

        item := CONTAINEROF entry TO ExuWorkItem.QueueEntry

        // Got a work item. Call the routine.

        item^.Routine (
            item^.Context1, // context1
            item^.Context2, // context2
        )
    END
END

FN ExuEnqueueWorkItem (
    IN item : ^ExuWorkItem,
    IN priority : ExuWorkQueuePriority,
    IN context1 : UWORD,
    IN context2 : UWORD,
)

    // Enqueue a work item to the appropriate thread.
    //
    // Custody of the work item is passed off the the worker thread pool - its
    // lifetime must be guaranteed by the caller. Custody is returned when the
    // work routine is called, at which point it may be freed.

    item^.Context1 = context1
    item^.Context2 = context2

    KeInsertIntoBalancedQueue (
        &ExpWorkQueues[priority], // queue
        &item^.QueueEntry, // item
        FALSE, // head
        0, // priorityboost
    )
END

FN ExuEnqueueTimedWorkItem (
    IN item : ^ExuTimedWorkItem,
    IN priority : ExuWorkQueuePriority,
    IN interval : ^RtlUquad,
    IN context1 : UWORD,
    IN context2 : UWORD,
)

    // Enqueue the timer embedded in the work item.

    item^.Priority = priority

    KeEnqueueTimer (
        &item^.Timer, // timer
        interval, // interval
        context1, // context1
        context2, // context2
    )
END

FN (KeDpcF) ExpTimedWorkItemDpc (
    IN dpc : ^KeDpc,
    IN context1 : UWORD,
    IN context2 : UWORD,
)

    // The KeTimer embedded in a timed work item expired.
    // We have to enqueue the work item for real now.

    item := CONTAINEROF dpc TO ExuTimedWorkItem.Dpc

    ExuEnqueueWorkItem (
        &item^.Item, // item
        item^.Priority, // priority
        context1, // context1
        context2, // context2
    )
END

FN ExuInitializeTimedWorkItem (
    IN item : ^ExuTimedWorkItem,
    IN routine : ExuWorkItemF,
)

    // Initialize a timed work item.

    ExuInitializeWorkItem (
        &item^.Item, // item
        routine, // routine
    )

    KeInitializeDpc (
        &item^.Dpc, // dpc
        &ExpTimedWorkItemDpc, // func
    )

    KeInitializeTimer (
        &item^.Timer, // timer
        &item^.Dpc, // dpc
        "TimedWorkItem", // name
    )
END

#ENTERSECTION "INITtext"

ExpWorkPriorities : UBYTE[EXU_MAX_WORK_PRIORITY] = {
    [EXU_LOW_WORK_PRIORITY] = OS_PRIORITY_LOW_REALTIME,
    [EXU_HIGH_WORK_PRIORITY] = OS_PRIORITY_MED_REALTIME,
    [EXU_NONPAGED_WORK_PRIORITY] = OS_PRIORITY_MED_REALTIME,
}

ExpWorkVmPrivileged : UBYTE[EXU_MAX_WORK_PRIORITY] = {
    [EXU_NONPAGED_WORK_PRIORITY] = TRUE,
}

FN ExpInitializeWorkQueues ()

    // Initialize the system work queues.

    i := 0

    WHILE i < EXU_MAX_WORK_PRIORITY DO
        // Initialize the work queue for this priority.
        // maxthreads == 0 causes it to be equal to the number of processors in
        // the system.

        KeInitializeBalancedQueue (
            &ExpWorkQueues[i], // queue
            "SysQ", // name
            0, // maxthreads
        )

        i += 1
    END

    // Compute how many threads of each priority there should be.
    // We base this off the system size.

    workthreads : UBYTE[EXU_MAX_WORK_PRIORITY]
    
    systemsize := MmuGetSystemSize ()

    IF systemsize <= MMU_TINY_SYSTEM THEN
        workthreads[EXU_NONPAGED_WORK_PRIORITY] = 1
        workthreads[EXU_HIGH_WORK_PRIORITY] = 1
        workthreads[EXU_LOW_WORK_PRIORITY] = 1

    ELSEIF systemsize <= MMU_SMALL_SYSTEM THEN
        workthreads[EXU_NONPAGED_WORK_PRIORITY] = 1
        workthreads[EXU_HIGH_WORK_PRIORITY] = 2
        workthreads[EXU_LOW_WORK_PRIORITY] = 3

    ELSEIF systemsize <= MMU_MEDIUM_SYSTEM THEN
        workthreads[EXU_NONPAGED_WORK_PRIORITY] = 2
        workthreads[EXU_HIGH_WORK_PRIORITY] = 3
        workthreads[EXU_LOW_WORK_PRIORITY] = 5

    ELSE
        workthreads[EXU_NONPAGED_WORK_PRIORITY] = 2
        workthreads[EXU_HIGH_WORK_PRIORITY] = 4
        workthreads[EXU_LOW_WORK_PRIORITY] = 7
    END

    // Initialize a name string for the threads.

    name : RtlString
    RtlInitializeString ( &name, "WorkerThread" )

    // Create the worker threads.

    j := 0

    WHILE j < EXU_MAX_WORK_PRIORITY DO
        i = 0

        threads := workthreads[j]

        WHILE i < threads DO
            thread : ^PsuThread

            status := PsuCreateExecutiveThread (
                &name, // name
                &ExpWorkQueueLoop, // startfunc
                &ExpWorkQueues[j], // context1
                0, // context2
                0, // flags
                OUT thread, // thread
            )

            IF OsError ( status ) THEN
                KeCrash ( "Failed to create workers (%x)\n", status )
            END

            // Set priority here instead of in the context of the thread itself
            // so that we have a guarantee that the worker threads have their
            // correct priority by the time we leave this function. Otherwise
            // there could be a window of time where user programs could perform
            // priority-based DOS attacks if these threads don't happen to get
            // scheduled in by the time we initialize usermode.

            KeSetBasePriorityThread (
                &thread^.Tcb, // thread
                ExpWorkPriorities[j], // priority
                TRUE, // setcurrentpriority
            )

            thread^.VmPrivileged = ExpWorkVmPrivileged[j]

            // Remove the reference we got by virtue of creating the thread.

            ObuUnreferenceObject ( thread )

            i += 1
        END

        j += 1
    END
END

#LEAVESECTION