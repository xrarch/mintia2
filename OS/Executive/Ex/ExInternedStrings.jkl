//
// Management for string internment for the MINTIA Executive.
//

#INCLUDE "Exp.hjk"

#DEFINE EXP_NAME_BUCKETS 64

STRUCT ExpNameBucket
    TreeRoot : RtlAvlNode,
    Lock : KeLock,
END

ExpNameBuckets : ExpNameBucket[EXP_NAME_BUCKETS]

#SECTION "INITtext"
FN ExpInitializeNames ()

    // Initialize the interned name buckets.

    i := 0

    WHILE i < EXP_NAME_BUCKETS DO
        RtlInitializeAvl ( &ExpNameBuckets[i].TreeRoot )
        KeInitializeLock ( &ExpNameBuckets[i].Lock )

        i += 1
    END
END

#SECTION "PAGEtext"
FN (RtlAvlLessThanF) ExpCompareNameNodes (
    IN a : ^RtlAvlNode,
    IN b : ^RtlAvlNode,
) : UWORD

    // Return whether A < B, lexicographically.

    RETURN CAST RtlCompareRtlString (
        ExNameToString ( CONTAINEROF a TO ExuName.Entry ), // str1
        ExNameToString ( CONTAINEROF b TO ExuName.Entry ), // str2
    ) TO WORD < 0
END

#SECTION "PAGEtext"
FN ExpHash (
    IN str : ^UBYTE,
) : UWORD

    // Simple hash for a string.

    hash := 0

    WHILE str^ DO
        hash += str^
        hash += hash << 10
        hash $= hash >> 6

        str += 1
    END

    hash += hash << 3
    hash $= hash >> 11
    hash += hash << 15

    RETURN hash
END

#SECTION "PAGEtext"
FN ExFindName (
    IN str : ^RtlString,
) : ^ExuName

    // Find a name in the string internment buckets.

    // Hash the name.

    len := str^.Length

    hash := ExpHash ( str^.Data )

    // Get the hash bucket.

    bucket := &ExpNameBuckets[hash & (EXP_NAME_BUCKETS - 1)]

@Retry

    // Lock the bucket.

    KeAcquireLockExclusive ( &bucket^.Lock )

    // Look up the name in the bucket, which is an AVL tree keyed by string and
    // ordered lexicographically.

    avlnode := bucket^.TreeRoot.Right

    WHILE TRUE DO
        IF NOT avlnode THEN
            // Didn't find it, we'll need to create it.

            BREAK
        END

        checknode := CONTAINEROF avlnode TO ExuName.Entry

        res := CAST RtlCompareRtlString (
            str, // str1
            ExNameToString ( checknode ), // str2
        ) TO WORD

        IF res == 0 THEN
            // Found it! Unlock the bucket and return the node.

            checknode^.References += 1

            KeReleaseLock ( &bucket^.Lock )

            RETURN checknode
        END

        IF res < 0 THEN
            avlnode = avlnode^.Left
        ELSE
            avlnode = avlnode^.Right
        END
    END

    node : ^ExuName = MmAllocatePool (
        MM_PAGED_POOL, // poolindex
        SIZEOF ExuName + SIZEOF RtlString + len + 1, // bytes
        'Name', // tag
        FALSE, // wait
    )

    IF NOT node THEN
        KeReleaseLock ( &bucket^.Lock )

        MmWaitForPoolMemory ()

        GOTO Retry
    END

    // Initialize the name.

    node^.References = 1
    node^.BucketIndex = hash & (EXP_NAME_BUCKETS - 1)

    newstr := ExNameToString ( node )

    newstr^.Length = len
    newstr^.Data = CAST newstr + SIZEOF RtlString TO ^UBYTE

    RtlCopyBytes (
        newstr + SIZEOF RtlString, // dest
        str^.Data, // src
        len + 1, // sz
    )

    // Insert into the tree.

    RtlInsertAvl (
        &bucket^.TreeRoot, // root
        &node^.Entry, // node
        &ExpCompareNameNodes, // comparisonfunc
    )

    // Unlock bucket and return node.

    KeReleaseLock ( &bucket^.Lock )

    RETURN node
END

#SECTION "PAGEtext"
FN ExUnreferenceName (
    IN name : ^ExuName,
)

    // Unreference the name node.

    bucket := &ExpNameBuckets[name^.BucketIndex]

    // Lock the bucket.

    KeAcquireLockExclusive ( &bucket^.Lock )

    // Decrement the reference count.

    oldcount := name^.References
    name^.References = oldcount - 1

    IF oldcount == 1 THEN
        // Remove from tree.

        RtlRemoveAvl (
            &bucket^.TreeRoot, // root
            &name^.Entry, // node
        )

        KeReleaseLock ( &bucket^.Lock )

        // Free outside the bucket lock.

        MmFreePool (
            name, // ptr
            'Name', // tag
        )

        LEAVE
    END

    // Unlock the bucket.

    KeReleaseLock ( &bucket^.Lock )
END

#SECTION "PAGEtext"
FN ExReferenceName (
    IN name : ^ExuName,
)

    // Reference the name node.

    bucket := &ExpNameBuckets[name^.BucketIndex]

    // Lock the bucket.

    KeAcquireLockExclusive ( &bucket^.Lock )

    // Increment the reference count.

    name^.References += 1

    // Unlock the bucket.

    KeReleaseLock ( &bucket^.Lock )
END

#SECTION "PAGEtext"
FN ExDuplicateString (
    IN outputstring : ^RtlString,
    IN inputstring : ^RtlString,
    IN poolindex : UWORD,
    IN tag : UWORD,
) : OsStatus

    // Duplicate a string into an output string.

    // Copy the length.

    outputstring^.Length = inputstring^.Length

    // Create a new string buffer (this is the important work).

    outputstring^.Data = MmAllocatePool (
        poolindex, // poolindex
        inputstring^.Length + 1, // bytes
        tag, // tag
        TRUE, // wait
    )

    IF NOT outputstring^.Data THEN
        RETURN OS_STATUS_NO_MEMORY
    END

    // Copy the old string into the new one, including the null terminator.

    RtlCopyBytes (
        outputstring^.Data, // dest
        inputstring^.Data, // src
        inputstring^.Length + 1, // sz
    )

    RETURN OS_STATUS_SUCCESS
END

// The following functions are defined as macros for speed purposes within the
// Executive but are exported as real functions for the benefit of kernel
// modules, so we don't need to export these structures.

#UNDEFINE ExNameToString

EXPORT FN ExNameToString (
    IN name : ^ExuName,
) : ^RtlString

    RETURN CAST ((name) + SIZEOF ExuName) TO ^RtlString
END