//
// Implements handle management for the Object Manager.
//

#INCLUDE "Obp.hjk"

#SECTION "PAGEtext"
FN (ExuHandleTableEnumerationF) ObpDestroyHandle (
    IN handletable : ^ExuHandleTable,
    IN handle : UWORD,
    IN entryptr : ^VOID,
    IN context : UWORD,
)

    process := CAST context TO ^PsuProcess

    // Destroy the handle.

    ObuCloseObject (
        process, // process
        handle, // handle
    )
END

#SECTION "PAGEtext"
FN ObuInitializeProcess (
    IN parentprocess : ^PsuProcess,
    IN process : ^PsuProcess,
    IN quotablock : ^MmpQuotaBlock,
)

    // Initialize a process such that the object manager will play nice with it.

    // Note that entrysizelog = 0 means the size of a handle table entry will be
    // two pointers, which fits our ObpHandleEntry structure, since the size of
    // an entry is calculated by (SIZEOF ^VOID * 2) << entrysizelog.

    ExuInitializeHandleTable (
        &process^.Paged^.HandleTable, // handletable
        0, // entrysizelog
        quotablock, // quotablock
    )

    // Initialize the handle table lock.

    KeInitializeLock ( &process^.Paged^.HandleTableLock )

    // Inherit the credentials from the parent process.

    parentcred := &parentprocess^.Paged^.Cred
    mycred := &process^.Paged^.Cred

    ObMoveCredentials (
        mycred, // dest
        parentcred, // src
    )
END

#SECTION "PAGEtext"
FN ObuUninitializeProcess (
    IN process : ^PsuProcess,
)

    // Uninitialize a process with respect to the object manager. This involves
    // forcibly closing all of its handles.

    ExuDeleteHandleTable (
        &process^.Paged^.HandleTable, // handletable
        &ObpDestroyHandle, // func
        process, // context
    )
END

#SECTION "PAGEtext"
FN ObuInsertObject (
    IN process : ^PsuProcess,
    IN object : ^VOID,
    IN access : UWORD,
    OUT handle : UWORD,
) : OsStatus

    // Insert an object into the process's handle table.
    //
    // A single reference on the object's pointer count should be considered
    // consumed by this operation, since it will be decremented upon a close,
    // which can be performed by the user as soon as we release the handle table
    // lock.
    //
    // Any relevant access checks should have already been performed.

    paged := process^.Paged

    handletable := &paged^.HandleTable

    // Acquire the process's handle table lock.

    KeAcquireLockExclusive ( &paged^.HandleTableLock )

    // Create the handle.

    entry : ^ObpHandleEntry

    status := ExuCreateHandle (
        handletable, // handletable
        NULLPTR, // lock
        OUT handle, // handle
        OUT entry, // entryptr
    )

    IF OsError ( status ) THEN
        KeReleaseLock ( &paged^.HandleTableLock )

        RETURN status
    END

    // Initialize the handle table entry with the object and the access bits.

    entry^.Object = object
    entry^.Access = access

    header := ObuFindHeader ( object )

    IF header^.Type^.Open THEN
        // Call the open method of the type.

        status = header^.Type^.Open (
            process, // process
            object, // object
            access, // access
        )

        IF OsError ( status ) THEN
            // The type decided not to let us open this object, so back out.

            ExuDeleteHandle (
                handletable, // handletable
                handle, // handle
                NULLPTR, // entry
            )

            KeReleaseLock ( &paged^.HandleTableLock )

            RETURN status
        END
    END

    // Increment the handle count of the object.

    KeAcquireLockExclusive ( &header^.Lock )

    header^.HandleCount += 1

    KeReleaseLock ( &header^.Lock )

    // Unlock the handle table and return.

    KeReleaseLock ( &paged^.HandleTableLock )

    // Shift the handle value by three bits (multiply by eight) because we want
    // to be able to stash three bits here.

    handle <<= OS_HANDLE_SHIFT

    RETURN status
END

#SECTION "PAGEtext"
FN ObuCloseObject (
    IN process : ^PsuProcess,
    IN handle : UWORD,
) : OsStatus

    // Close a handle in the specified process.

    handle >>= OS_HANDLE_SHIFT

    paged := process^.Paged

    handletable := &paged^.HandleTable

    entry : ObpHandleEntry

    // Lock the handle table.

    KeAcquireLockExclusive ( &paged^.HandleTableLock )

    // Delete the handle.

    IF NOT ExuDeleteHandle (
        handletable, // handletable
        handle, // handle
        &entry, // entry
    ) THEN
        // No such handle.

        KeReleaseLock ( &paged^.HandleTableLock )

        RETURN OS_STATUS_INVALID_HANDLE
    END

    // Unlock the handle table.

    KeReleaseLock ( &paged^.HandleTableLock )

    object := entry.Object

    header := ObuFindHeader ( object )

    // Decrement the handle count.

    KeAcquireLockExclusive ( &header^.Lock )

    oldcount := header^.HandleCount
    header^.HandleCount = oldcount - 1

    IF oldcount == 1 AND
        header^.Flags & OBU_FLAG_PERMANENT == 0 AND
        header^.NamespaceEntry THEN

        // This was the last handle to a non-permanent object that has a name in
        // the namespace. Remove the name.

        NsuUnlinkObject ( object )
    END

    KeReleaseLock ( &header^.Lock )

    // Unreference the object.

    ObUnreferenceObject ( object )

    RETURN OS_STATUS_SUCCESS
END

#SECTION "PAGEtext"
FN ObuReferenceByHandleObject (
    IN process : ^PsuProcess,
    IN handle : UWORD,
    IN typeid : OsObjectType,
    OUT object : ^VOID,
    OUT access : UWORD,
) : OsStatus

    // Look up the handle in the process's handle table. Return the
    // corresponding object.

    handle >>= OS_HANDLE_SHIFT

    paged := process^.Paged

    handletable := &paged^.HandleTable

    // Lock the handle table.

    KeAcquireLockShared ( &paged^.HandleTableLock )

    // Look up the handle.

    entry : ^ObpHandleEntry = ExuLookupHandle (
        handletable, // handletable
        handle, // handle
    )

    IF NOT entry THEN
        // Failed to look up.

        KeReleaseLock ( &paged^.HandleTableLock )

        RETURN OS_STATUS_INVALID_HANDLE
    END

    object = entry^.Object
    access = entry^.Access

    IF typeid != OS_ANY_TYPE AND
        ObuFindHeader ( object )^.Type^.TypeIdentifier != typeid THEN

        // Wrong type.

        KeReleaseLock ( &paged^.HandleTableLock )

        RETURN OS_STATUS_INVALID_OBJECT_TYPE
    END

    // Reference the object.

    ObReferenceObject ( object )

    // Release the lock and return the object.

    KeReleaseLock ( &paged^.HandleTableLock )

    RETURN OS_STATUS_SUCCESS
END

#SECTION "PAGEtext"
FN ObuReferenceByHandle (
    IN handle : UWORD,
    IN typeid : OsObjectType,
    OUT object : ^VOID,
    OUT access : UWORD,
) : OsStatus

    // Look up the handle in the current process's handle table. Return the
    // corresponding object.

    IF handle == OS_CURRENT_PROCESS THEN
        IF typeid != OS_ANY_TYPE AND
            typeid != OS_PROCESS_TYPE THEN

            RETURN OS_STATUS_INVALID_OBJECT_TYPE
        END

        object = PsCurrentProcess ()

        access = OS_ACCESS_ALL

        ObReferenceObject ( object )

        RETURN OS_STATUS_SUCCESS

    ELSEIF handle == OS_CURRENT_THREAD THEN
        IF typeid != OS_ANY_TYPE AND
            typeid != OS_THREAD_TYPE THEN

            RETURN OS_STATUS_INVALID_OBJECT_TYPE
        END

        object = PsCurrentThread ()

        access = OS_ACCESS_ALL

        ObReferenceObject ( object )

        RETURN OS_STATUS_SUCCESS
    END

    RETURN ObuReferenceByHandleObject (
        PsCurrentProcess (), // process
        handle, // handle
        typeid, // type
        OUT object, // object
        OUT access, // access
    )
END

#SECTION "PAGEtext"
FN ObuOpenObject (
    IN params : ^NsOpenParameters,
    IN type : OsObjectType,
    OUT handle : UWORD,
) : OsStatus

    // Open a handle to an object of the specified type.

    // TODO: Calling this with OS_ANY_TYPE is maybe broken because of the
    //       special semantics of file objects (which contain namespace handles
    //       and can't be directly opened). We need to make sure that using this
    //       to open a file object works right later.

    IF type != OS_ANY_TYPE THEN
        IF type >= OS_MAX_TYPE THEN
            RETURN OS_STATUS_INVALID_TYPE
        END

        obtype := &PsCurrentNode()^.ObTypes[type]

        IF obtype^.Flags & OBU_TYPE_FLAG_OPENABLE == 0 THEN
            RETURN OS_STATUS_INVALID_TYPE
        END
    END

    object : ^VOID

    status := NsuLookupObject (
        params, // params
        type, // typeid
        OUT object, // event
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    status = ObuInsertObject (
        PsCurrentProcess (), // process
        object, // object
        params^.Captured.Access, // access
        OUT handle, // handle
    )

    IF OsError ( status ) THEN
        ObUnreferenceObject ( object )
    END

    RETURN status
END

#SECTION "PAGEtext"
FN OsOpenObject (
    IN params : ^OsOpenParameters,
    IN type : UWORD,
    OUT handle : UWORD,
) : OsStatus

    // Open an object, system service.

    sysparams : NsOpenParameters

    status := NsuCaptureOpenParameters (
        params, // userparams
        &sysparams, // sysparams
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    status = ObuOpenObject (
        &sysparams, // params
        type, // type
        OUT handle, // handle
    )

    NsuFreeOpenParameters ( &sysparams )

    RETURN status
END

#SECTION "PAGEtext"
FN OsClose (
    IN handle : UWORD,
) : OsStatus

    // Close the specified handle.

    RETURN ObuCloseObject (
        PsCurrentProcess (), // process
        handle, // handle
    )
END