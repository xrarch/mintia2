//
// Manipulation of reference counted objects.
//

#INCLUDE "Obp.hjk"

#MACRO ObpCalculatePagedBlockSize ( bodysize ) [
    (SIZEOF ObuHeader + SIZEOF ObpCommonHeader + (bodysize))
]

#MACRO ObpCalculateNpBlockSize ( bodysize ) [
    (SIZEOF ObpCommonHeader + (bodysize))
]

#MACRO ObpCalculateNpHeaderSize ( pgsize ) [
    (SIZEOF ObuHeader + (pgsize))
]

#ENTERSECTION "INITtext"
FN ObuInitializeType (
    IN type : ^ObuType,
) : OsStatus

    // Initialize an object type.

    error := "ObuInitializeType: %s: %s"

    npsize : UWORD
    psize : UWORD

    id := type^.TypeIdentifier

    IF type^.IsPaged THEN
        npsize = 0
        psize = ObpCalculatePagedBlockSize ( type^.TypicalBodySize )

    ELSE
        npsize = ObpCalculateNpBlockSize ( type^.TypicalBodySize )
        psize = ObpCalculateNpHeaderSize ( type^.TypicalPgBodySize )
    END

    typenamelen := RtlMeasureString ( type^.Name )
    npname : ^UBYTE
    pgname : ^UBYTE

    IF npsize THEN
        npname = MmAllocatePool (
            MM_NONPAGED_POOL, // poolindex
            typenamelen + 2 + 1, // bytes
            'PcNm', // tag
            TRUE, // wait
        )

        IF NOT npname THEN
            KeCrash ( error, type^.Name, "failed to allocate np name\n" )
        END

        RtlCopyString (
            npname, // dest
            type^.Name, // src
            -1, // bufsize
        )

        npname[typenamelen] = 'N'
        npname[typenamelen + 1] = 'p'
        npname[typenamelen + 2] = 0
    END

    IF psize THEN
        pgname = MmAllocatePool (
            MM_NONPAGED_POOL, // poolindex
            typenamelen + 2 + 1, // bytes
            'PcNm', // tag
            TRUE, // wait
        )

        IF NOT pgname THEN
            KeCrash ( error, type^.Name, "failed to allocate pg name\n" )
        END

        RtlCopyString (
            pgname, // dest
            type^.Name, // src
            -1, // bufsize
        )

        pgname[typenamelen] = 'P'
        pgname[typenamelen + 1] = 'g'
        pgname[typenamelen + 2] = 0
    END

    // The object type structures are duplicated between NUMA nodes.

    i := 0
    nodes := KeQueryNodeCount ()

    WHILE i < nodes DO
        kenode := KeNumaNodeById ( i )

        pernodetype := &kenode^.ObTypes[id]

        pernodetype^.CachedPgBodySize = psize
        pernodetype^.CachedNpBodySize = npsize

        RtlCopyBytes (
            pernodetype, // dest
            type, // src
            SIZEOF ObuType, // sz
        )

        IF npsize THEN
            pernodetype^.NpPartCache = MmCreatePoolCache (
                kenode^.Mmp, // node
                npname, // name
                npsize, // size
                MM_NONPAGED_POOL, // poolindex
                type^.Tag, // tag
            )

            IF NOT pernodetype^.NpPartCache THEN
                KeCrash ( error, type^.Name, "failed to allocate np cache\n" )
            END
        END

        IF psize THEN
            pernodetype^.PgPartCache = MmCreatePoolCache (
                kenode^.Mmp, // node
                pgname, // name
                psize, // size
                MM_PAGED_POOL, // poolindex
                type^.Tag, // tag
            )

            IF NOT pernodetype^.PgPartCache THEN
                KeCrash ( error, type^.Name, "failed to allocate pg cache\n" )
            END
        END

        i += 1
    END

    RETURN OS_STATUS_SUCCESS
END
#LEAVESECTION

#DEFINE OBP_PG_FROM_CACHE 1
#DEFINE OBP_NP_FROM_CACHE 2

#SECTION "PAGEtext"
FN ObuAllocateObject (
    IN obparams : ^ObParameters,
    OUT object : ^VOID,
) : OsStatus

    // Allocate an object of the specified type.

    // Calculate the sizes of the paged and nonpaged part of the object.

    psize : UWORD
    npsize : UWORD

    type := &obparams^.AllocationNode^.ObTypes[obparams^.TypeId]

    internalflags := 0

    IF type^.IsPaged THEN
        npsize = 0
        psize = ObpCalculatePagedBlockSize ( obparams^.BodySize )

    ELSE
        npsize = ObpCalculateNpBlockSize ( obparams^.BodySize )
        psize = ObpCalculateNpHeaderSize ( obparams^.PagedBodySize )
    END

    // Charge pool quota.

    npquota := MmGetOverheadOfBytes ( npsize ) + obparams^.NpQuotaBias
    pquota := MmGetOverheadOfBytes ( psize ) + obparams^.PgQuotaBias

    process := PsCurrentProcess ()

    quotablock := PsuQuotaBlock ( process )

    status := MmuChargePoolQuota (
        quotablock, // quotablock
        npquota, // charge
        MM_NONPAGED_POOL, // poolindex
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    status = MmuChargePoolQuota (
        quotablock, // quotablock
        pquota, // charge
        MM_PAGED_POOL, // poolindex
    )

    IF OsError ( status ) THEN
        GOTO Error1
    END

    nppart := NULLPTR

    IF npsize THEN
        IF npsize <= type^.CachedNpBodySize THEN
            // Use a pool cache.

            internalflags |= OBP_NP_FROM_CACHE

            nppart = MmAllocateFromPoolCache (
                type^.NpPartCache, // cache
                TRUE, // wait
            )
        
        ELSE
            nppart = MmAllocatePool (
                MM_NONPAGED_POOL, // poolindex
                npsize, // bytes
                type^.Tag, // tag
                TRUE, // wait
            )
        END

        IF NOT nppart THEN
            status = OS_STATUS_NO_MEMORY

            GOTO Error2
        END
    END

    pgpart := NULLPTR

    IF psize THEN
        IF psize <= type^.CachedPgBodySize THEN
            // Use a pool cache.

            internalflags |= OBP_PG_FROM_CACHE

            pgpart = MmAllocateFromPoolCache (
                type^.PgPartCache, // cache
                TRUE, // wait
            )
        
        ELSE
            pgpart = MmAllocatePool (
                MM_PAGED_POOL, // poolindex
                psize, // bytes
                type^.Tag, // tag
                TRUE, // wait
            )
        END

        IF NOT pgpart THEN
            status = OS_STATUS_NO_MEMORY

            GOTO Error3
        END
    END

    header : ^ObuHeader
    commonheader : ^ObpCommonHeader

    IF type^.IsPaged THEN
        header = pgpart
        commonheader = pgpart + SIZEOF ObuHeader

    ELSE
        header = pgpart
        commonheader = nppart
    END

    commonheader^.Header = header

    header^.PagedQuotaCharge = pquota
    header^.NonpagedQuotaCharge = npquota

    MmuReferenceQuotaBlock ( quotablock )

    header^.QuotaBlock = quotablock

    header^.Flags = obparams^.Flags
    header^.InternalFlags = internalflags

    ObMoveCredentials (
        &header^.Permissions.Cred, // dest
        &obparams^.Permissions.Cred, // src
    )

    header^.Permissions.Access = obparams^.Permissions.Access

    commonheader^.PointerCount = 1
    header^.HandleCount = 0

    header^.NamespaceEntry = NULLPTR

    header^.Type = type

    KeInitializeLock ( &header^.Lock )

    object = commonheader + SIZEOF ObpCommonHeader

    IF type^.Initialize THEN
        // Call the initialization callback.

        status = type^.Initialize (
            object, // object
            obparams^.Context, // context
        )

        IF OsError ( status ) THEN
            // Initialization failed so just free everything we did.

            ObuFreeObject ( object )

            RETURN status
        END
    END

    RETURN OS_STATUS_SUCCESS

@Error3

    IF nppart THEN
        IF internalflags & OBP_NP_FROM_CACHE THEN
            MmFreeToPoolCache (
                type^.NpPartCache, // cache
                nppart, // ptr
            )

        ELSE
            MmFreePool (
                nppart, // ptr
                type^.Tag, // tag
            )
        END
    END

@Error2

    MmuUnchargePoolQuota (
        quotablock, // quotablock
        pquota, // charge
        MM_PAGED_POOL, // poolindex
    )

@Error1

    MmuUnchargePoolQuota (
        quotablock, // quotablock
        npquota, // charge
        MM_NONPAGED_POOL, // poolindex
    )

    RETURN status
END

#SECTION "PAGEtext"
FN ObuFreeObject (
    IN object : ^VOID,
)

    // Free an object. Don't call the deletion routine.

    header := ObuFindHeader ( object )

    // Shouldn't be possible because temporary objects are removed from the
    // namespace when their handle count reaches zero, which happened before
    // now. Permanent objects have their refcount biased when inserted into
    // the namespace.

    KeAssert ( header^.NamespaceEntry == NULLPTR )

    quotablock := header^.QuotaBlock

    pquota := header^.PagedQuotaCharge
    npquota := header^.NonpagedQuotaCharge
    type := header^.Type
    flags := header^.InternalFlags

    // Free the object parts.

    IF type^.IsPaged THEN
        // Only a single part.

        IF flags & OBP_PG_FROM_CACHE THEN
            MmFreeToPoolCache (
                type^.PgPartCache, // cache
                header, // ptr
            )

        ELSE
            MmFreePool (
                header, // ptr
                type^.Tag, // tag
            )
        END

    ELSE
        // Two parts.

        IF flags & OBP_PG_FROM_CACHE THEN
            MmFreeToPoolCache (
                type^.PgPartCache, // cache
                header, // ptr
            )

        ELSE
            MmFreePool (
                header, // ptr
                type^.Tag, // tag
            )
        END

        IF flags & OBP_NP_FROM_CACHE THEN
            MmFreeToPoolCache (
                type^.NpPartCache, // cache
                object - SIZEOF ObpCommonHeader, // ptr
            )

        ELSE
            MmFreePool (
                object - SIZEOF ObpCommonHeader, // ptr
                type^.Tag, // tag
            )
        END
    END

    // Uncharge quota.

    IF pquota THEN
        MmuUnchargePoolQuota (
            quotablock, // quotablock
            pquota, // charge
            MM_PAGED_POOL, // poolindex
        )
    END

    IF npquota THEN
        MmuUnchargePoolQuota (
            quotablock, // quotablock
            npquota, // charge
            MM_NONPAGED_POOL, // poolindex
        )
    END

    MmuUnreferenceQuotaBlock ( quotablock )
END

#SECTION "PAGEtext"
FN ObuDeleteObject (
    IN object : ^VOID,
)

    // Delete an object. Call the deletion routine.

    header := ObuFindHeader ( object )

    IF header^.Type^.Delete AND
        NOT header^.Type^.Delete ( object ) THEN

        // Type routine said nevermind, don't delete.

        LEAVE
    END

    ObuFreeObject ( object )
END

EXPORT FN ObReferenceObject (
    IN object : ^VOID,
)

    // Reference an object by pointer.

    commonheader := ObuFindCommonHeader ( object )

    oldcount := KeIncrementPtr (
        &commonheader^.PointerCount, // ulong
        1, // inc
    )

    KeAssert ( oldcount != 0 )
END

#SECTION "PAGEtext"
FN ObpEmptyDeferredList (
    IN paged : ^PsuPagedThread,
)

    // Empty the deferred object deletion list of the thread.

    KeAssert ( paged^.DeletingObject != FALSE )

    // Loop this whole process because we might enqueue even more objects while
    // deleting the objects we have.

    WHILE paged^.DeferredObjectHead DO
        // Detach the whole chain.

        object := paged^.DeferredObjectHead
        paged^.DeferredObjectHead = NULLPTR

        // Free every object in the chain.

        WHILE object DO
            next := ObuFindCommonHeader ( object )^.NextToReap

            ObuDeleteObject ( object )

            object = next
        END
    END
END

#SECTION "PAGEtext"
FN (KeuProcessCustodyListF) ObpDeferredDeleteObject (
    IN list : ^KeuCustodyList,
    IN object : ^VOID,
    IN context : ^VOID,
)

    // Called to delete an object as a KeuProcessCustodyList callback.

    commonheader := CONTAINEROF object TO ObpCommonHeader.NextToReap

    ObuDeleteObject ( ObuFindObjectFromCommonHeader ( commonheader ) )
END

#SECTION "PAGEtext"
FN (ExWorkItemF) ObuDeferredDeletionWorker (
    IN context1 : UWORD,
    IN context2 : UWORD,
)

    // An object deletion was deferred to worker thread context and WE are that
    // worker thread.

    kenode := CAST context1 TO ^KeuNode
    obpnode := kenode^.Obp

    paged := PsCurrentThread ()^.Paged

    paged^.DeletingObject = TRUE

    KeuProcessCustodyList (
        &obpnode^.DeferredDeletionList, // list
        &ObpDeferredDeleteObject, // callback
        kenode, // context
    )

    IF paged^.DeferredObjectHead THEN
        ObpEmptyDeferredList ( paged )
    END

    paged^.DeletingObject = FALSE
END

FN (KeuCustodyListActivateF) ObpActivateDeletionWorker (
    IN list : ^KeuCustodyList,
)

    // The list was previously empty, so we should enqueue the work item.
    // Note that this guarantees that the work item is not actively in the
    // queue, because the list is only emptied by the worker itself.

    kenode := CAST list^.Context TO ^KeuNode
    obpnode := kenode^.Obp

    interval : RtlUquad

    RtlSetUquadToUlong (
        &interval, // uquad
        100, // interval
    )

    ExEnqueueTimedWorkItem (
        &obpnode^.DeferredDeletionTimedWorkItem, // item
        EX_HIGH_WORK_PRIORITY, // priority
        &interval, // interval
        kenode, // context1
        0, // context2
    )
END

FN ObpDeferDeletion (
    IN object : ^VOID,
)

    // Enqueue deleting this object as some work to the worker thread pool.

    commonheader := ObuFindCommonHeader ( object )

    // Atomically add it to the list.

    kenode := KeNumaNodeFromSpacePointer ( object )

    KeuInsertCustodyList (
        &kenode^.Obp^.DeferredDeletionList, // list
        &commonheader^.NextToReap, // link
    )
END

EXPORT FN ObUnreferenceObject (
    IN object : ^VOID,
)

    // Unreference an object by pointer.

    commonheader := ObuFindCommonHeader ( object )

    oldcount := KeIncrementPtr (
        &commonheader^.PointerCount, // ulong
        -1, // inc
    )

    KeAssert ( oldcount != 0 )

    IF oldcount == 1 THEN
        // Delete it.

        thread := PsCurrentThread ()

        IF NOT KeAreApcsDeliverable () OR
            thread^.VmPrivileged THEN

            // APCs are not deliverable so we're gonna defer this deletion to
            // worker thread context. This is to avoid illegally trying to
            // recursively acquire locks inside deletion routines that are not
            // APC-safe.
            //
            // We also defer deletion if the current thread is VM privileged.
            // This is because actually deleting an object will invariably touch
            // paged pool (to delete the paged part of the header) and we assume
            // a VM privileged thread is involved in page-out and so this could
            // otherwise cause deadlock.

            ObpDeferDeletion ( object )

            LEAVE
        END

        // If APCs are deliverable then we aren't in an APC and are not
        // holding a lock depended upon by APCs, so we can delete this
        // object inline.

        paged := thread^.Paged

        IF paged^.DeletingObject THEN 
            // We're already deleting an object. To avoid causing a big
            // call stack due to recursively deleting lots of objects, and
            // potentially overflowing our kernel stack, enqueue this
            // object to a thread-local list of pending deletions. It'll
            // get handled when the outermost object deletion returns.

            // Note that there's no need to synchronize this list since we
            // only access it from our own context.

            commonheader^.NextToReap = paged^.DeferredObjectHead
            paged^.DeferredObjectHead = object

        ELSE
            // Delete the object right away.

            paged^.DeletingObject = TRUE

            KeuIgnoreEvents ()

            ObuDeleteObject ( object )

            IF paged^.DeferredObjectHead THEN
                ObpEmptyDeferredList ( paged )
            END

            KeuAcceptEvents ()

            paged^.DeletingObject = FALSE
        END
    END
END

EXPORT FN ObUnreferenceObjectDeferDelete (
    IN object : ^VOID,
)

    // Unreference an object by pointer.

    // Unconditionally defer deletion instead of doing it in the context of this
    // thread. This is useful when a lock is held that is also taken in the
    // deletion routine.

    commonheader := ObuFindCommonHeader ( object )

    oldcount := KeIncrementPtr (
        &commonheader^.PointerCount, // ulong
        -1, // inc
    )

    KeAssert ( oldcount != 0 )

    IF oldcount == 1 THEN
        // Delete it.

        ObpDeferDeletion ( object )
    END
END

EXPORT FN ObConditionallyReferenceObject (
    IN object : ^VOID,
) : UWORD

    // Reference an object only if the pointer count would not increase from
    // zero. Only the caller can know whether this is safe, for instance, by
    // holding a lock that the object's deletion routine must take before it
    // finally frees the object. Returns TRUE if referenced successfully, FALSE
    // otherwise.

    commonheader := ObuFindCommonHeader ( object )

    oldcount := commonheader^.PointerCount

    WHILE TRUE DO
        IF oldcount == 0 THEN
            // Count is already zero, so it may be undergoing deletion. Not safe
            // to reference this object.

            RETURN FALSE
        END

        new := KeCompareSwapPtr (
            &commonheader^.PointerCount, // ptr
            oldcount + 1, // newvalue
            oldcount, // expectedvalue
        )

        IF new == oldcount THEN
            // Got it. The previous count was nonzero so we know the object is
            // safe.

            RETURN TRUE
        END

        oldcount = new
    END
END

#SECTION "PAGEtext"
FN ObCheckAccess (
    IN permissions : ^ObPermissions,
    IN cred : ^ObCredentials,
    IN access : UWORD,
) : UWORD

    // Check the requested access against the permissions.

    shift := 0

    IF permissions^.Cred.Uid == cred^.Uid THEN
        shift = 6 // owner
    ELSEIF permissions^.Cred.Gid == cred^.Gid THEN
        shift = 3 // group
    END

    permbits := (permissions^.Access >> shift) & OS_ACCESS_ALL

    IF permbits | access == permbits THEN
        // Access is a subset of the permissions we have.

        RETURN TRUE
    END

    IF cred^.Uid == OS_SYSTEM_UID THEN
        // Access isn't a subset, but we are the system user.

        RETURN TRUE
    END

    IF permissions^.Cred.Uid == OS_SYSTEM_UID THEN
        // Access isn't a subset, and we aren't the system user, and the owner
        // of this object is the system user. Permission is denied.

        RETURN FALSE
    END

    // As an admin, we can access all objects except those owned by the system
    // user.

    RETURN PsuCheckPrivilege ( PsCurrentProcess (), OS_PRIVILEGE_ADMIN )
END

#SECTION "PAGEtext"
FN ObCheckAccessForCurrent (
    IN object : ^VOID,
    IN access : UWORD,
) : UWORD

    // Check the requested access against the object's permissions, with respect
    // to the current process's credentials.

    RETURN ObCheckAccess (
        &ObuFindHeader ( object )^.Permissions, // permissions
        PsuCurrentCredentials (), // cred
        access, // access
    )
END