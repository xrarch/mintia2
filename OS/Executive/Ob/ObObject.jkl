//
// Manipulation of reference counted objects.
//

#INCLUDE "Obp.hjk"

PUBLIC ObFullyNonpagedObjects := TRUE

#SECTION "PAGEtext"
FN ObpValidateObjectName (
    IN name : ^UBYTE,
) : UWORD

    // Validate the name of an object. Returns the length of the name.
    // A length of zero indicates an invalid object.

    IF name[0] == '.' THEN
        // . and .. are not allowed.

        IF name[1] == 0 THEN
            RETURN 0
        END

        IF name[1] == '.' AND name[2] == 0 THEN
            RETURN 0
        END

    ELSEIF name[0] == 0 THEN
        // Empty names not allowed.

        RETURN 0
    END

    length := 0

    WHILE name[length] DO
        IF length >= OB_NAME_MAX THEN
            RETURN 0
        END

        IF name[length] == '/' THEN
            RETURN 0
        END

        length += 1
    END

    RETURN length
END

#SECTION "PAGEtext"
FN ObCreateObject (
    IN obparams : ^ObParameters,
    OUT object : ^VOID,
) : OsStatus

    // Create an object of the specified type.

    namelen := 0

    IF obparams^.Name THEN
        namelen = ObpValidateObjectName ( obparams^.Name )

        IF namelen == 0 THEN
            RETURN OS_STATUS_INVALID_NAME
        END

        // Round up to a pointer size.

        namelen = (namelen + RTL_MACHINE_WORD_SIZE - 1) &
            ~(RTL_MACHINE_WORD_SIZE - 1)
    END

    // Calculate the sizes of the paged and nonpaged part of the object.

    psize : UWORD
    npsize : UWORD

    IF ObFullyNonpagedObjects THEN
        psize = 0

        npsize = SIZEOF ObHeader +
            SIZEOF ObpCommonHeader +
            obparams^.BodySize +
            namelen

    ELSEIF obparams^.Type^.IsPaged THEN
        npsize = 0

        psize = SIZEOF ObHeader +
            SIZEOF ObpCommonHeader +
            obparams^.BodySize +
            namelen

    ELSE
        npsize = obparams^.BodySize + SIZEOF ObpCommonHeader

        psize = SIZEOF ObHeader + namelen
    END

    // Charge pool quota.

    npquota := MmGetOverheadOfBytes ( npsize ) + obparams^.NpQuotaBias
    pquota := MmGetOverheadOfBytes ( psize ) + obparams^.PgQuotaBias

    process := PsCurrentProcess ()

    quotablock := PsQuotaBlock ( process )

    status := MmChargePoolQuota (
        quotablock, // quotablock
        npquota, // charge
        MM_NONPAGED_POOL, // poolindex
    )

    IF OsError ( status ) THEN
        RETURN status
    END

    status = MmChargePoolQuota (
        quotablock, // quotablock
        pquota, // charge
        MM_PAGED_POOL, // poolindex
    )

    IF OsError ( status ) THEN
        GOTO Error1
    END

    nppart := NULLPTR

    IF npsize THEN
        nppart = MmAllocatePool (
            MM_NONPAGED_POOL, // poolindex
            npsize, // bytes
            obparams^.Type^.Tag, // tag
            TRUE, // wait
        )

        IF NOT nppart THEN
            status = OS_STATUS_NO_MEMORY

            GOTO Error2
        END
    END

    pgpart := NULLPTR

    IF psize THEN
        pgpart = MmAllocatePool (
            MM_PAGED_POOL, // poolindex
            psize, // bytes
            obparams^.Type^.Tag, // tag
            TRUE, // wait
        )

        IF NOT pgpart THEN
            status = OS_STATUS_NO_MEMORY

            GOTO Error3
        END
    END

    header : ^ObHeader
    commonheader : ^ObpCommonHeader

    IF ObFullyNonpagedObjects THEN
        header = nppart
        header^.Name = nppart + SIZEOF ObHeader
        commonheader = nppart + SIZEOF ObHeader + namelen

    ELSEIF obparams^.Type^.IsPaged THEN
        header = pgpart
        header^.Name = pgpart + SIZEOF ObHeader
        commonheader = pgpart + SIZEOF ObHeader + namelen

    ELSE
        header = pgpart
        header^.Name = pgpart + SIZEOF ObHeader

        commonheader = nppart
    END

    commonheader^.Header = header

    IF namelen THEN
        RtlCopyString (
            header^.Name, // dest
            obparams^.Name, // src
            -1, // bufsize
        )

    ELSE
        header^.Name = NULLPTR
    END

    header^.PagedQuotaCharge = pquota
    header^.NonpagedQuotaCharge = npquota

    MmReferenceQuotaBlock ( quotablock )

    header^.QuotaBlock = quotablock

    header^.Flags = obparams^.Flags
    header^.Permissions = obparams^.Permissions

    header^.Uid = process^.Paged^.Uid
    header^.Gid = process^.Paged^.Gid

    header^.U.Used.PointerCount = 1
    header^.U.Used.HandleCount = 0

    header^.NamespaceEntry = NULLPTR

    KeInitializeLock ( &header^.Lock )

    object = commonheader + SIZEOF ObpCommonHeader

    RETURN OS_STATUS_SUCCESS

@Error3

    IF nppart THEN
        MmFreePool (
            nppart, // ptr
            obparams^.Type^.Tag, // tag
        )
    END

@Error2

    MmUnchargePoolQuota (
        quotablock, // quotablock
        pquota, // charge
        MM_PAGED_POOL, // poolindex
    )

@Error1

    MmUnchargePoolQuota (
        quotablock, // quotablock
        npquota, // charge
        MM_NONPAGED_POOL, // poolindex
    )

    RETURN status
END

#SECTION "PAGEtext"
FN ObFreeObject (
    IN object : ^VOID,
)

    // Free an object. Don't call the deletion routine.

    header := ObFindHeader ( object )

#IF BLD_CHK
    IF header^.NamespaceEntry THEN
        // Shouldn't be possible because temporary objects are removed from the
        // namespace when their handle count reaches zero, which happened before
        // now. Permanent objects have their refcount biased when inserted into
        // the namespace.

        KeCrash ( "ObFreeObject: has namespace entry\n" )
    END
#END

    quotablock := header^.QuotaBlock

    pquota := header^.PagedQuotaCharge
    npquota := header^.NonpagedQuotaCharge
    type := header^.Type

    // Free the object parts.

    IF type^.IsPaged THEN
        // Only a single part.

        MmFreePool (
            header, // ptr
            type^.Tag, // tag
        )

    ELSE
        // Two parts.

        MmFreePool (
            header, // ptr
            type^.Tag, // tag
        )

        MmFreePool (
            object - SIZEOF ObpCommonHeader, // ptr
            type^.Tag, // tag
        )
    END

    // Uncharge quota.

    MmUnchargePoolQuota (
        quotablock, // quotablock
        pquota, // charge
        MM_PAGED_POOL, // poolindex
    )

    MmUnchargePoolQuota (
        quotablock, // quotablock
        npquota, // charge
        MM_NONPAGED_POOL, // poolindex
    )

    MmUnreferenceQuotaBlock ( quotablock )
END

#SECTION "PAGEtext"
FN ObDeleteObject (
    IN object : ^VOID,
)

    // Delete an object. Call the deletion routine.

    header := ObFindHeader ( object )

    IF header^.Type^.Delete THEN
        header^.Type^.Delete ( object )
    END

    ObFreeObject ( object )
END

#SECTION "PAGEtext"
FN ObReferenceObject (
    IN object : ^VOID,
)

    // Reference an object by pointer.

    header := ObFindHeader ( object )

    oldcount := KeIncrementPtr (
        &header^.U.Used.PointerCount, // ulong
        1, // inc
    )

#IF BLD_CHK
    IF oldcount == 0 THEN
        KeCrash ( "ObReferenceObject: zero refcount\n" )
    END
#END

END

#SECTION "PAGEtext"
FN ObUnreferenceObject (
    IN object : ^VOID,
)

    // Unreference an object by pointer.

    header := ObFindHeader ( object )

    oldcount := KeIncrementPtr (
        &header^.U.Used.PointerCount, // ulong
        -1, // inc
    )

#IF BLD_CHK
    IF oldcount == 0 THEN
        KeCrash ( "ObUnreferenceObject: underflow\n" )
    END
#END

    IF oldcount == 1 THEN
        // Delete it.

        IF KeAreApcsDeliverable () THEN
            // If APCs are deliverable then we aren't in an APC and are not
            // holding a lock depended upon by APCs, so we can delete this
            // object inline.

            KeIgnoreEvents ()

            ObDeleteObject ( object )

            KeAcceptEvents ()

            LEAVE
        END

        // APCs are not deliverable so we're gonna defer this deletion to worker
        // thread context.

        KeCrash ( "TODO ObUnreferenceObject worker item enqueue\n" )
    END
END

#SECTION "PAGEtext"
FN ObConditionallyReferenceObject (
    IN object : ^VOID,
) : UWORD

    // Reference an object only if the pointer count would not increase from
    // zero. Only the caller can know whether this is safe, for instance, by
    // holding a lock that the object's deletion routine must take before it
    // finally frees the object. Returns TRUE if referenced successfully, FALSE
    // otherwise.

    header := ObFindHeader ( object )

    oldcount := header^.U.Used.PointerCount

    WHILE TRUE DO
        IF oldcount == 0 THEN
            // Count is already zero, so it may be undergoing deletion. Not safe
            // to reference this object.

            RETURN FALSE
        END

        new := KeCompareSwapPtr (
            &header^.U.Used.PointerCount, // ptr
            oldcount + 1, // newvalue
            oldcount, // expectedvalue
        )

        IF new == oldcount THEN
            // Got it. The previous count was nonzero so we know the object is
            // safe.

            RETURN TRUE
        END

        oldcount = new
    END
END